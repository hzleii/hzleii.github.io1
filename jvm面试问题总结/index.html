<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>JVM面试问题总结 - 磊子的菜园子</title><meta name=Description content="腹有诗书气自华。"><meta property="og:title" content="JVM面试问题总结"><meta property="og:description" content="JVM 篇 1. 什么情况下会发生栈内存溢出在 HotSpot 虚拟机中是不区分虚拟机栈和本地方法栈，栈是线程私有的，它的生命周期与线程相同，每个方法在执行的时候都会创"><meta property="og:type" content="article"><meta property="og:url" content="https://hzleii.github.io/hzleii.github.io1/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"><meta property="og:image" content="https://hzleii.github.io/images/avatar.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-13T22:15:45+00:00"><meta property="article:modified_time" content="2021-01-13T22:15:45+00:00"><meta property="og:site_name" content="磊子的菜园子"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hzleii.github.io/images/avatar.jpg"><meta name=twitter:title content="JVM面试问题总结"><meta name=twitter:description content="JVM 篇 1. 什么情况下会发生栈内存溢出在 HotSpot 虚拟机中是不区分虚拟机栈和本地方法栈，栈是线程私有的，它的生命周期与线程相同，每个方法在执行的时候都会创"><meta name=application-name content="hzlei"><meta name=apple-mobile-web-app-title content="hzlei"><meta name=theme-color content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://hzleii.github.io/hzleii.github.io1/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/><link rel=prev href=https://hzleii.github.io/hzleii.github.io1/java-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/><link rel=next href=https://hzleii.github.io/hzleii.github.io1/viim/><link rel=stylesheet href=/hzleii.github.io1/css/main.css><link rel=stylesheet href=/hzleii.github.io1/lib/normalize/normalize.min.css><link rel=stylesheet href=/hzleii.github.io1/css/color.css><link rel=stylesheet href=/hzleii.github.io1/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/hzleii.github.io1/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/hzleii.github.io1/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/hzleii.github.io1/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/hzleii.github.io1/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"JVM面试问题总结","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/hzleii.github.io\/hzleii.github.io1\/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93\/"},"image":["https:\/\/hzleii.github.io\/images\/Apple-Devices-Preview.png"],"genre":"posts","keywords":"Java, JVM, 面试","wordcount":9507,"url":"https:\/\/hzleii.github.io\/hzleii.github.io1\/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93\/","datePublished":"2021-01-13T22:15:45+00:00","dateModified":"2021-01-13T22:15:45+00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"hzlei","logo":"https:\/\/hzleii.github.io\/images\/avatar.jpg"},"author":{"@type":"Person","name":"磊子"},"description":""}</script><script src=//instant.page/5.2.0 defer type=module integrity=sha384-jnZyxPjiipYXnSU0ygqeac2q7CVYMbh84q0uHVRRxEtvFPiQYbXWUorga2aqZJ0z></script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e),document.documentElement.style.setProperty("color-scheme",e==="light"?"light":"dark"),window.theme=e,window.isDark=window.theme!=="light"}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(e){const t=document.getElementsByTagName("meta");for(let n=0;n<t.length;n++)if(t[n].getAttribute("name")===e)return t[n];return""}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}else"auto"==="light"||"auto"==="dark"||"auto"==="black"?(setTheme("auto"),saveTheme("auto")):(saveTheme("auto"),setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")],window.switchThemeEventSet=new Set</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/hzleii.github.io1/ title=磊子的菜园子><span class=header-title-pre><i class='far fa-edit fa-fw'></i></span>hzlei</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/hzleii.github.io1/posts/>所有文章 </a><a class=menu-item href=/hzleii.github.io1/tags/>标签 </a><a class=menu-item href=/hzleii.github.io1/categories/>分类 </a><a class=menu-item href=/hzleii.github.io1/about/>关于 </a><a class=menu-item href=https://github.com/hzleii title=GitHub rel="noopener noreferrer" target=_blank><i class='fab fa-github fa-fw'></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/hzleii.github.io1/ title=磊子的菜园子><span class=header-title-pre><i class='far fa-edit fa-fw'></i></span>hzlei</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/hzleii.github.io1/posts/ title>所有文章</a><a class=menu-item href=/hzleii.github.io1/tags/ title>标签</a><a class=menu-item href=/hzleii.github.io1/categories/ title>分类</a><a class=menu-item href=/hzleii.github.io1/about/ title>关于</a><a class=menu-item href=https://github.com/hzleii title=GitHub rel="noopener noreferrer" target=_blank><i class='fab fa-github fa-fw'></i></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto><nav id=TableOfContents><ul><li><a href=#1-什么情况下会发生栈内存溢出>1. 什么情况下会发生栈内存溢出</a></li><li><a href=#2-jvm-的内存结构eden-和-survivor-比例>2. JVM 的内存结构，Eden 和 Survivor 比例</a></li><li><a href=#3-jvm-内存为什么要分成新生代老年代和持久代新生代中为什么要分-eden-和-survivor>3. JVM 内存为什么要分成新生代、老年代和持久代。新生代中为什么要分 Eden 和 Survivor。</a></li><li><a href=#4-jvm-中一次完整的-gc-流程是什么样子的对象如何晋升到老年代说说你知道的几种主要的-jvm-参数>4. JVM 中一次完整的 GC 流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的 JVM 参数。</a></li><li><a href=#5-你知道哪几种垃圾收集器各自的优缺点重点讲下-cms-和-g1包括原理流程优缺点>5. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms 和 G1，包括原理，流程，优缺点。</a></li><li><a href=#6-垃圾回收算法的实现原理>6. 垃圾回收算法的实现原理。</a></li><li><a href=#7-当出现了内存溢出怎么排错>7. 当出现了内存溢出，怎么排错。</a></li><li><a href=#8-jvm-内存模型的相关知识了解多少比如重排序内存屏障happen-before主内存工作内存等>8. JVM 内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。</a></li><li><a href=#9-讲讲-java-的反射机制>9. 讲讲 JAVA 的反射机制</a></li><li><a href=#10-你们线上应用的-jvm-参数有哪些>10. 你们线上应用的 JVM 参数有哪些。</a></li><li><a href=#11-g1-和-cms-区别吞吐量优先和响应优先的垃圾收集器选择>11. g1 和 cms 区别，吞吐量优先和响应优先的垃圾收集器选择。</a></li><li><a href=#12-怎么打印线程栈信息>12. 怎么打印线程栈信息。</a></li><li><a href=#13-请解释如下-jvm-参数的含义>13. 请解释如下 jvm 参数的含义。</a></li><li><a href=#14-java-中对象创建的几种方式>14. Java 中对象创建的几种方式。</a></li><li><a href=#15-java中的对象一定在堆上分配内存吗>15. Java中的对象一定在堆上分配内存吗？</a></li><li><a href=#16-运行时数据中哪些区域是线程共享的那些是独享的>16. 运行时数据中哪些区域是线程共享的，那些是独享的？</a></li><li><a href=#17-java-中数组是存储在堆上还是栈上>17. Java 中数组是存储在堆上还是栈上。</a></li><li><a href=#18-java-对象创建的过程是怎么样的>18. Java 对象创建的过程是怎么样的？</a></li><li><a href=#19-怎么获取堆和栈的-dump-文件>19. 怎么获取堆和栈的 dump 文件。</a></li><li><a href=#20-minor-gc-和-full-gc-的触发条件>20. Minor GC 和 Full GC 的触发条件。</a></li><li><a href=#21-在-java-语言中可以作为-gc-roots-的对象有什么>21. 在 Java 语言中，可以作为 GC Roots 的对象有什么。</a></li><li><a href=#22-类加载过程>22. 类加载过程。</a></li><li><a href=#23-java-内存泄漏的场景>23. Java 内存泄漏的场景。</a></li><li><a href=#24-jdk18-的虚拟机中内存模型变化>24. jdk1.8 的虚拟机中内存模型变化。</a></li><li><a href=#25-频繁-gc-的原因>25. 频繁 GC 的原因。</a></li><li><a href=#26-高并发时jvm-调优>26. 高并发时，JVM 调优。</a></li><li><a href=#27-systemgc和-runtimegc的区别>27. System.gc()和 Runtime.gc()的区别。</a></li></ul></nav></div></div><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">JVM面试问题总结</h1><div class=post-meta><div class=post-meta-line><span class=post-author><span class="author fas fa-user-circle fa-fw"></span><a href=/hzleii.github.io1/ title=Author rel=author class=author>磊子</a>
</span>&nbsp;<span class=post-category>收录于 </span>&nbsp;<span class=post-category>类别 <a href=/hzleii.github.io1/categories/%E9%9D%A2%E8%AF%95/><i class="far fa-folder fa-fw"></i>面试</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-01-13>2021-01-13</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2021-01-13>2021-01-13</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 9507 字&nbsp;<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 19 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#1-什么情况下会发生栈内存溢出>1. 什么情况下会发生栈内存溢出</a></li><li><a href=#2-jvm-的内存结构eden-和-survivor-比例>2. JVM 的内存结构，Eden 和 Survivor 比例</a></li><li><a href=#3-jvm-内存为什么要分成新生代老年代和持久代新生代中为什么要分-eden-和-survivor>3. JVM 内存为什么要分成新生代、老年代和持久代。新生代中为什么要分 Eden 和 Survivor。</a></li><li><a href=#4-jvm-中一次完整的-gc-流程是什么样子的对象如何晋升到老年代说说你知道的几种主要的-jvm-参数>4. JVM 中一次完整的 GC 流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的 JVM 参数。</a></li><li><a href=#5-你知道哪几种垃圾收集器各自的优缺点重点讲下-cms-和-g1包括原理流程优缺点>5. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms 和 G1，包括原理，流程，优缺点。</a></li><li><a href=#6-垃圾回收算法的实现原理>6. 垃圾回收算法的实现原理。</a></li><li><a href=#7-当出现了内存溢出怎么排错>7. 当出现了内存溢出，怎么排错。</a></li><li><a href=#8-jvm-内存模型的相关知识了解多少比如重排序内存屏障happen-before主内存工作内存等>8. JVM 内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。</a></li><li><a href=#9-讲讲-java-的反射机制>9. 讲讲 JAVA 的反射机制</a></li><li><a href=#10-你们线上应用的-jvm-参数有哪些>10. 你们线上应用的 JVM 参数有哪些。</a></li><li><a href=#11-g1-和-cms-区别吞吐量优先和响应优先的垃圾收集器选择>11. g1 和 cms 区别，吞吐量优先和响应优先的垃圾收集器选择。</a></li><li><a href=#12-怎么打印线程栈信息>12. 怎么打印线程栈信息。</a></li><li><a href=#13-请解释如下-jvm-参数的含义>13. 请解释如下 jvm 参数的含义。</a></li><li><a href=#14-java-中对象创建的几种方式>14. Java 中对象创建的几种方式。</a></li><li><a href=#15-java中的对象一定在堆上分配内存吗>15. Java中的对象一定在堆上分配内存吗？</a></li><li><a href=#16-运行时数据中哪些区域是线程共享的那些是独享的>16. 运行时数据中哪些区域是线程共享的，那些是独享的？</a></li><li><a href=#17-java-中数组是存储在堆上还是栈上>17. Java 中数组是存储在堆上还是栈上。</a></li><li><a href=#18-java-对象创建的过程是怎么样的>18. Java 对象创建的过程是怎么样的？</a></li><li><a href=#19-怎么获取堆和栈的-dump-文件>19. 怎么获取堆和栈的 dump 文件。</a></li><li><a href=#20-minor-gc-和-full-gc-的触发条件>20. Minor GC 和 Full GC 的触发条件。</a></li><li><a href=#21-在-java-语言中可以作为-gc-roots-的对象有什么>21. 在 Java 语言中，可以作为 GC Roots 的对象有什么。</a></li><li><a href=#22-类加载过程>22. 类加载过程。</a></li><li><a href=#23-java-内存泄漏的场景>23. Java 内存泄漏的场景。</a></li><li><a href=#24-jdk18-的虚拟机中内存模型变化>24. jdk1.8 的虚拟机中内存模型变化。</a></li><li><a href=#25-频繁-gc-的原因>25. 频繁 GC 的原因。</a></li><li><a href=#26-高并发时jvm-调优>26. 高并发时，JVM 调优。</a></li><li><a href=#27-systemgc和-runtimegc的区别>27. System.gc()和 Runtime.gc()的区别。</a></li></ul></nav></div></div><div class=content id=content><div class="details admonition warning open"><div class="details-summary admonition-title"><i class="icon fas fa-exclamation-triangle fa-fwwarning"></i>警告<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content>本文最后更新于 <span class=timeago datetime=2021-01-13T22:15:45 title="January 13, 2021">2021-01-13</span>，文中内容可能已过时。</div></div></div><h1 id=jvm-篇 class=headerLink><a href=#jvm-%e7%af%87 class=header-mark></a>JVM 篇</h1><h2 id=1-什么情况下会发生栈内存溢出 class=headerLink><a href=#1-%e4%bb%80%e4%b9%88%e6%83%85%e5%86%b5%e4%b8%8b%e4%bc%9a%e5%8f%91%e7%94%9f%e6%a0%88%e5%86%85%e5%ad%98%e6%ba%a2%e5%87%ba class=header-mark></a>1. 什么情况下会发生栈内存溢出</h2><p>在 HotSpot 虚拟机中是不区分虚拟机栈和本地方法栈，栈是线程私有的，它的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈桢在虚拟机栈中入栈到出栈的过程。本地方法栈与虚拟机栈相似，区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</p><p>栈内存溢出是指线程请求的栈深度大于虚拟机所允许的最大深度，则将抛出 StackOverflowError 异常（StackOverflowError 不属于 OOM 异常）。最有可能的原因就是方法递归产生的这种结果。</p><p>另一个可能是引用了大的变量，在拓展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常（这个属于内存溢出）。</p><h2 id=2-jvm-的内存结构eden-和-survivor-比例 class=headerLink><a href=#2-jvm-%e7%9a%84%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84eden-%e5%92%8c-survivor-%e6%af%94%e4%be%8b class=header-mark></a>2. JVM 的内存结构，Eden 和 Survivor 比例</h2><p>Java 虚拟机在执行 Java 程序的过程中把它所管理的内存划分为若干个不同的数 据区域，这些区域都有各自的用途。</p><ul><li>程序计数器。当前线程执行的字节码的行号指示器，是线程私有的。也是唯一一个不会发生内存溢出的区域。</li><li>Java 虚拟机栈。也是线程私有的，描述的是 Java 方法执行的内存模型，线程请求的栈深度大于虚拟机所允许的最大深度，则将抛出StackOverflowError 异常。</li><li>本地方法栈。与虚拟机栈相似，区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</li><li>Java 堆。是 Java 虚拟机中管理的内存中最大的一块，所有线程共享区域，唯一目的就是存放对象实例。所有的对象实例以及<strong>数组</strong>都要在堆上分配内存。Java 堆也是垃圾回收器管理的主要区域，也被称为 gc 堆，收集器基本都采用分代收集算法，Java 堆中还可以细分为：新生代和老年代。</li><li>方法区。所有线程共享区域，用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。很多人也愿意称之为“永久代”。</li><li>运行时常量池。是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。</li><li>直接内存。并不是虚拟机运行时数据区的一部分。例如 NIO，它可以使用 Native 函数直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样避免了在 Java 堆和 Native 堆中来回复制数据，提高了性能。</li></ul><p>JVM 中要对堆进行分代，分代的理由是优化 GC 性能，很多对象都是朝生夕死的，如果分代的话，我们把新创建的对象放到某一地方，当 GC 的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><p>HotSpot JVM 把新生代分为了三部分：1个 Eden 区和 2 个Survivor 区（分别叫 from 和 to）。默认比例为 8 ：1。一般情况下，新创建的对象都会被分配到Eden 区(一些大对象特殊处理),这些对象经过第一次 Minor GC后，如果仍然存活，将会被移到 Survivor 区。对象在 Survivor 区中每熬过一次Minor GC，年龄就会增加 1 岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p><p>因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制]算法不会产生内存碎片。</p><h2 id=3-jvm-内存为什么要分成新生代老年代和持久代新生代中为什么要分-eden-和-survivor class=headerLink><a href=#3-jvm-%e5%86%85%e5%ad%98%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%88%86%e6%88%90%e6%96%b0%e7%94%9f%e4%bb%a3%e8%80%81%e5%b9%b4%e4%bb%a3%e5%92%8c%e6%8c%81%e4%b9%85%e4%bb%a3%e6%96%b0%e7%94%9f%e4%bb%a3%e4%b8%ad%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%88%86-eden-%e5%92%8c-survivor class=header-mark></a>3. JVM 内存为什么要分成新生代、老年代和持久代。新生代中为什么要分 Eden 和 Survivor。</h2><p>堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中。给堆内存分代是为了提高对象内存分配和垃圾回收的效率。试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾收集，而每次回收都要遍历所有的对象，遍历这些对象所花费的时间代价是巨大的，会严重影响我们的 GC 效率，这简直太可怕了。</p><p>有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放在老年代中，静态属性、类信息等存放在永久代中，新生代中的对象存活时间短，只需要在新生代区域中频繁进行 GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收，永久代中回收效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾收集算法。分代收集大大提升了收集效率，这些都是内存分代带来的好处。</p><p>HotSpot 将新生代划分为三块，一块较大的 Eden 空间和两块较小的 Survivor 空间，默认比例为 8：1：1。划分的目的是因为 HotSpot 采用复制算法来回收新生代，设置这个比例是为了充分利用内存空间，减少浪费。新生成的对象在Eden 区分配（大对象除外，大对象直接进入老年代），当 Eden 区没有足够的空间进行分配时，虚拟机将发起一次 Minor GC。</p><h2 id=4-jvm-中一次完整的-gc-流程是什么样子的对象如何晋升到老年代说说你知道的几种主要的-jvm-参数 class=headerLink><a href=#4-jvm-%e4%b8%ad%e4%b8%80%e6%ac%a1%e5%ae%8c%e6%95%b4%e7%9a%84-gc-%e6%b5%81%e7%a8%8b%e6%98%af%e4%bb%80%e4%b9%88%e6%a0%b7%e5%ad%90%e7%9a%84%e5%af%b9%e8%b1%a1%e5%a6%82%e4%bd%95%e6%99%8b%e5%8d%87%e5%88%b0%e8%80%81%e5%b9%b4%e4%bb%a3%e8%af%b4%e8%af%b4%e4%bd%a0%e7%9f%a5%e9%81%93%e7%9a%84%e5%87%a0%e7%a7%8d%e4%b8%bb%e8%a6%81%e7%9a%84-jvm-%e5%8f%82%e6%95%b0 class=header-mark></a>4. JVM 中一次完整的 GC 流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的 JVM 参数。</h2><p>GC 开始时，对象只会存在于 Eden 区和 From Survivor 区，To Survivor 区是空的（作为保留区域）。GC 进行时，Eden 区中所有存活的对象都会被复制到 To Survivor 区，而在 From Survivor 区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阀值（默认为 15，新生代中的对象每熬过一轮垃圾回收，年龄值就加 1，GC 分代年龄存储在对象的 header 中）的对象会被移到老年代中，没有达到阀值的对象会被复制到 To Survivor 区。接着清空 Eden 区和 From Survivor 区，新生代中存活的对象都在 To Survivor 区。接着， From Survivor 区和 To Survivor 区会交换它们的角色，也就是新的 To Survivor 区就是上次 GC 清空的 From Survivor 区，新的 From Survivor 区就是上次 GC 的 To Survivor 区，总之，不管怎样都会保证 To Survivor 区在一轮 GC 后是空的。GC时当 To Survivor 区没有足够的空间存放上一次新生代收集下来的存活对象时，需要依赖老年代进行分配担保，将这些对象存放在老年代中。</p><p>对象晋升老年代有三种可能：</p><ol><li>当对象达到成年，经历过 15 次 GC（默认是 15，可配置），对象就晋升到老年代了。</li><li>大的对象会直接在老年代创建。</li><li>新生代的 Survivor 空间内存不足时，对象可能直接晋升到老年代。</li></ol><p>JVM参数：</p><ul><li>-Xms：初始堆大小</li><li>-Xmx：堆最大内存</li><li>-Xss：栈内存</li><li>-XX:PermSize 初始永久代内存</li><li>-XX:MaxPermSize 最大永久带内存</li></ul><h2 id=5-你知道哪几种垃圾收集器各自的优缺点重点讲下-cms-和-g1包括原理流程优缺点 class=headerLink><a href=#5-%e4%bd%a0%e7%9f%a5%e9%81%93%e5%93%aa%e5%87%a0%e7%a7%8d%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8%e5%90%84%e8%87%aa%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9%e9%87%8d%e7%82%b9%e8%ae%b2%e4%b8%8b-cms-%e5%92%8c-g1%e5%8c%85%e6%8b%ac%e5%8e%9f%e7%90%86%e6%b5%81%e7%a8%8b%e4%bc%98%e7%bc%ba%e7%82%b9 class=header-mark></a>5. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms 和 G1，包括原理，流程，优缺点。</h2><p>常见的垃圾收集器主要有以下四种：</p><ul><li>串行收集器（Serial、ParNew 收集器）：简单高效，但它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束，中间停顿时间长。</li><li>并行收集器（Parallel Scavenge 收集器）：吞吐量优先，主要关注点在于精确控制吞吐量，即减少 GC 停顿时间，但收集次数变多。</li><li>CMS：以获取最短回收停顿时间为目标的收集器，并发标记-清除，主要步骤有，初始标记，并发标记，重新标记和并发清除。其中，整个过程耗时最长的并发标记和并发清除过程收集器线程都可以和用户线程一起工作，CMS 收集器的内存回收过程始于用户线程一起并发执行的。重新标记是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。但缺点有，CMS 收集器对 CPU 资源非常敏感，并且无法处理浮动垃圾。</li><li>G1：可预测停顿的收集器，并发标记-整理，主要步骤分为，初始标记，并发标记，最终标记和筛选回收。G1 把内存“化整为零”，并且可以分代收集。注意：CMS 是清除，所以会存在很多的内存碎片。G1 是整理，所以碎片空间较小。</li></ul><h2 id=6-垃圾回收算法的实现原理 class=headerLink><a href=#6-%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e7%ae%97%e6%b3%95%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86 class=header-mark></a>6. 垃圾回收算法的实现原理。</h2><p>垃圾收集算法主要分为以下三种：</p><ol><li>标记-清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</li><li>复制算法：将可用内存按容量分为两块（Eden 和 Survivor 空间），每次只使用一块，当这一块内存用完后，就将还活着的对象复制到另外一块上面，然后再把已使用过内存空间一次清理掉。</li><li>标记-整理算法：标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界外的内存。</li></ol><p>需要注意的是，“标记-清除”算法存在两个不足：</p><ul><li>一个是效率问题，标记和清除两个过程的效率都不高；</li><li>另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一个垃圾收集动作。作为对比，复制算法每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</li></ul><h2 id=7-当出现了内存溢出怎么排错 class=headerLink><a href=#7-%e5%bd%93%e5%87%ba%e7%8e%b0%e4%ba%86%e5%86%85%e5%ad%98%e6%ba%a2%e5%87%ba%e6%80%8e%e4%b9%88%e6%8e%92%e9%94%99 class=header-mark></a>7. 当出现了内存溢出，怎么排错。</h2><ol><li><p>首先控制台查看错误日志。</p></li><li><p>然后使用 jdk 自带的 VisualVM 来查看系统的堆栈日志（也可以用 jmap 查看堆转储快照）。</p></li><li><p>定位出内存溢出的空间：堆，栈还是永久代（jdk8 后没有永久代的溢出了）。</p></li><li><p>如果是堆内存溢出，看是否创建了超大的对象。</p></li><li><p>如果是栈内存溢出，看是否创建了超大的对象，或者产生了死循环，或者递归调用。</p></li></ol><h2 id=8-jvm-内存模型的相关知识了解多少比如重排序内存屏障happen-before主内存工作内存等 class=headerLink><a href=#8-jvm-%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e7%9a%84%e7%9b%b8%e5%85%b3%e7%9f%a5%e8%af%86%e4%ba%86%e8%a7%a3%e5%a4%9a%e5%b0%91%e6%af%94%e5%a6%82%e9%87%8d%e6%8e%92%e5%ba%8f%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9chappen-before%e4%b8%bb%e5%86%85%e5%ad%98%e5%b7%a5%e4%bd%9c%e5%86%85%e5%ad%98%e7%ad%89 class=header-mark></a>8. JVM 内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。</h2><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。</p><p>内存屏障是一种 CPU 指令，用于控制特定条件下的重排序和内存可见性问题。Java 编译器也会根据内存屏障的规则禁止重排序。</p><p>happen-before 用来阐述操作之间的内存可见性。在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系。具体原则如下：</p><ul><li><p>程序次序法则：线程中的每个动作 A 都 happens-before 于该线程中的每一个动作 B，其中，在程序中，所有的动作 B 都能出现在 A 之后。</p></li><li><p>监视器锁法则：对一个监视器锁的解锁 happens-before 于每一个后续对同一监视器锁的加锁。</p></li><li><p>volatile 变量法则：对 volatile 域的写入操作 happens-before 于每一个后续对同一个域的读写操作。</p></li><li><p>线程启动法则：在一个线程里，对 Thread.start 的调用会 happens-before 于每个启动线程的动作。</p></li><li><p>线程终结法则：线程中的任何动作都 happens-before 于其他线程检测到这个线程已经终结、或者从 Thread.join 调用中成功返回，或Thread.isAlive 返回 false。</p></li><li><p>中断法则：一个线程调用另一个线程的 interrupt happens-before 于被中断的线程发现中断。</p></li><li><p>终结法则：一个对象的构造函数的结束 happens-before 于这个对象 finalizer 的开始。</p></li><li><p>传递性：如果 A happens-before 于 B，且 B happens-before 于 C，则 A happens-before 于 C。</p></li></ul><p>主内存是指所有线程共享的内存空间。</p><p>工作内存是指每个线程特有的内存空间。工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写在主内存中的变量。</p><p>参考链接：<a href=https://www.cnblogs.com/chenyangyao/p/5269622.html target=_blank rel="noopener noreferrer">JVM 内存模型、指令重排、内存屏障概念解析</a></p><h2 id=9-讲讲-java-的反射机制 class=headerLink><a href=#9-%e8%ae%b2%e8%ae%b2-java-%e7%9a%84%e5%8f%8d%e5%b0%84%e6%9c%ba%e5%88%b6 class=header-mark></a>9. 讲讲 JAVA 的反射机制</h2><p>Java 反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用。我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。</p><h2 id=10-你们线上应用的-jvm-参数有哪些 class=headerLink><a href=#10-%e4%bd%a0%e4%bb%ac%e7%ba%bf%e4%b8%8a%e5%ba%94%e7%94%a8%e7%9a%84-jvm-%e5%8f%82%e6%95%b0%e6%9c%89%e5%93%aa%e4%ba%9b class=header-mark></a>10. 你们线上应用的 JVM 参数有哪些。</h2><ul><li><p>-Xms512m //初始堆大小</p></li><li><p>-Xmx1024m //最大堆大小</p></li><li><p>-XX:PermSize=640m //设置持久代初始值</p></li><li><p>-XX:MaxPermSize=1280m //设置持久代最大值</p></li><li><p>-XX:NewSize=64m //设置年轻代初始值</p></li><li><p>-XX:MaxNewSize=256m //设置年轻代最大值</p></li><li><p>-verbose:gc //表示输出虚拟机中 GC 的详细情况</p></li><li><p>-XX:+PrintGCDetails //日志输出形式</p></li><li><p>-XX:+PrintGCTimeStamps //日志输出形式</p></li></ul><p>在默认情况下，JVM 初始分配的堆内存大小是物理内存的 1/64，最大分配的堆内存大小是物理内存的 1/4。</p><p>默认空余堆内存小于 40%时，JVM 就会增大堆直到-Xmx 的最大限制；空余堆内存大于 70%时，JVM 会减少堆直到-Xms 的最小限制。</p><p>因此服务器一般设置-Xms、-Xmx 相等，来避免每次 GC 后调整堆的大小。</p><h2 id=11-g1-和-cms-区别吞吐量优先和响应优先的垃圾收集器选择 class=headerLink><a href=#11-g1-%e5%92%8c-cms-%e5%8c%ba%e5%88%ab%e5%90%9e%e5%90%90%e9%87%8f%e4%bc%98%e5%85%88%e5%92%8c%e5%93%8d%e5%ba%94%e4%bc%98%e5%85%88%e7%9a%84%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8%e9%80%89%e6%8b%a9 class=header-mark></a>11. g1 和 cms 区别，吞吐量优先和响应优先的垃圾收集器选择。</h2><p>CMS 是基于“标记-清除”实现的，主要步骤是初始标记，并发标记，重新标记和并发清除。</p><p>G1 是基于“标记-整理”实现的，主要步骤是初始标记，并发标记，最终标记和筛选回收。
CMS 的缺点是对 CPU 的要求比较高。</p><p>G1 的缺点是将内存划分了多块，所以对内存段的大小有很大的要求。</p><p>CMS 是清除，所有会有很多的内存碎片。</p><p>G1 是整理，所有碎片空间较小。</p><p>G1 和 CMS 都是响应优先，他们的目的都是尽量控制 stop the world 的时间。</p><p>G1 和 CMS 的 Full GC 都是单线程 mark sweep compact 算法，直到 JDK10 才优化成并行的。</p><p>CMS 目前只用于老年代，而 G1 是将整个 Java 堆划分为多个大小不等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔的了，他们都是一部分 Region（不需要连续）的集合。</p><p>吞吐量优先的话可以选择并行垃圾收集器，Parallel Scavenge 收集器。吞吐量是指 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值。</p><h2 id=12-怎么打印线程栈信息 class=headerLink><a href=#12-%e6%80%8e%e4%b9%88%e6%89%93%e5%8d%b0%e7%ba%bf%e7%a8%8b%e6%a0%88%e4%bf%a1%e6%81%af class=header-mark></a>12. 怎么打印线程栈信息。</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>StackTraceElement</span><span class=o>[]</span> <span class=n>elements</span> <span class=o>=</span> <span class=o>(</span><span class=k>new</span> <span class=n>Throwable</span><span class=o>()).</span><span class=na>getStackTrace</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>StringBuffer</span> <span class=n>buf</span> <span class=o>=</span> <span class=k>new</span> <span class=n>StringBuffer</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=k>for</span><span class=o>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=o>;</span> <span class=n>i</span><span class=o>&lt;</span><span class=n>elements</span><span class=o>.</span><span class=na>length</span><span class=o>;</span> <span class=n>i</span><span class=o>++)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>buf</span><span class=o>.</span><span class=na>append</span><span class=o>(</span><span class=s>&#34;\n&#34;</span>
</span></span><span class=line><span class=cl>        <span class=o>+</span> <span class=n>elements</span><span class=o>[</span><span class=n>i</span><span class=o>].</span><span class=na>getClassName</span><span class=o>()</span><span class=c1>// 打印线程当前执行的详细类名
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>+</span> <span class=s>&#34;.&#34;</span>
</span></span><span class=line><span class=cl>        <span class=o>+</span> <span class=n>elements</span><span class=o>[</span><span class=n>i</span><span class=o>].</span><span class=na>getMethodName</span><span class=o>()</span><span class=c1>// 打印线程当前方法名
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>+</span> <span class=s>&#34;(&#34;</span>
</span></span><span class=line><span class=cl>        <span class=o>+</span> <span class=n>elements</span><span class=o>[</span><span class=n>i</span><span class=o>].</span><span class=na>getFileName</span><span class=o>()</span><span class=c1>// 打印线程当前执行类的文件名
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>+</span> <span class=s>&#34;:&#34;</span>
</span></span><span class=line><span class=cl>        <span class=o>+</span> <span class=n>elements</span><span class=o>[</span><span class=n>i</span><span class=o>].</span><span class=na>getLineNumber</span><span class=o>()</span><span class=c1>// 打印线程当前执行的行数
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>+</span> <span class=s>&#34;)&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=13-请解释如下-jvm-参数的含义 class=headerLink><a href=#13-%e8%af%b7%e8%a7%a3%e9%87%8a%e5%a6%82%e4%b8%8b-jvm-%e5%8f%82%e6%95%b0%e7%9a%84%e5%90%ab%e4%b9%89 class=header-mark></a>13. 请解释如下 jvm 参数的含义。</h2><ul><li><p>-server：服务器模式</p></li><li><p>-Xms512m：初始堆空间</p></li><li><p>-Xmx512m：最大堆空间</p></li><li><p>-Xss1024K：栈空间</p></li><li><p>-XX:PermSize=256m：初始永久代空间</p></li><li><p>-XX:MaxPermSize=512m ：最大永久代空间</p></li><li><p>-XX:MaxTenuringThreshold=20：在新生代对象存活次数（经历 Minor GC 的次数）后依旧存活，就会晋升到老年代。</p></li><li><p>-XX:CMSInitiatingOccupancyFraction=80 ：设定 CMS 在对老年代内存占用率达到 80%的时候开始 GC(因为 CMS 会有浮动垃圾,所以一般都较早启动 GC)。</p></li><li><p>-XX:+UseCMSInitiatingOccupancyOnly：只是用设定的回收阈值(上面指定的 80%),如果不指定,JVM 仅在第一次使用设定值,后续则自动调整.</p></li></ul><h2 id=14-java-中对象创建的几种方式 class=headerLink><a href=#14-java-%e4%b8%ad%e5%af%b9%e8%b1%a1%e5%88%9b%e5%bb%ba%e7%9a%84%e5%87%a0%e7%a7%8d%e6%96%b9%e5%bc%8f class=header-mark></a>14. Java 中对象创建的几种方式。</h2><p>创建对象的方式有四种：</p><ul><li>用 new 关键字创建。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>User</span> <span class=n>user</span> <span class=o>=</span> <span class=k>new</span> <span class=n>User</span><span class=o>();</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>调用对象的 clone 方法。</li><li>利用反射，调用 Class 类的或者是 Constructor 类的 newInstance() 方法。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>User</span> <span class=n>user</span> <span class=o>=</span> <span class=n>User</span><span class=o>.</span><span class=na>class</span><span class=o>.</span><span class=na>newInstance</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=c1>// 或者是
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Constructor</span><span class=o>&lt;</span><span class=n>User</span><span class=o>&gt;</span> <span class=n>constructor</span> <span class=o>=</span> <span class=n>User</span><span class=o>.</span><span class=na>class</span><span class=o>.</span><span class=na>getContructor</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>User</span> <span class=n>user</span> <span class=o>=</span> <span class=n>constructor</span><span class=o>.</span><span class=na>newInstance</span><span class=o>();</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>用反序列化，调用 ObjectInputStream 类的 readObject() 方法。</li></ul><h2 id=15-java中的对象一定在堆上分配内存吗 class=headerLink><a href=#15-java%e4%b8%ad%e7%9a%84%e5%af%b9%e8%b1%a1%e4%b8%80%e5%ae%9a%e5%9c%a8%e5%a0%86%e4%b8%8a%e5%88%86%e9%85%8d%e5%86%85%e5%ad%98%e5%90%97 class=header-mark></a>15. Java中的对象一定在堆上分配内存吗？</h2><p>前面我们说过，Java 堆中主要保存了对象实例，但是，随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p><p>其实，在编译期间，JIT 会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。</p><p>如果 JIT 经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。</p><p>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121615&amp;idx=1&amp;sn=00d412f68fe58dceab6d13fdfefac113&amp;chksm=f36bb8aec41c31b8d62069e2663345c0452ebdded331616496637e19b2cad72725f6ce90daec&amp;scene=21" target=_blank rel="noopener noreferrer">深入理解 Java 中的逃逸分析 </a>和 <a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121307&amp;idx=1&amp;sn=5526473d0248cca8385d2a18ba6b25af&amp;chksm=f36bb97ac41c306c354ebf0335cd2fd77cac03f3434894e4e5b44a01754a5494b04350d26d14&amp;scene=21" target=_blank rel="noopener noreferrer">对象并不一定都是在堆上分配内存的</a></p><h2 id=16-运行时数据中哪些区域是线程共享的那些是独享的 class=headerLink><a href=#16-%e8%bf%90%e8%a1%8c%e6%97%b6%e6%95%b0%e6%8d%ae%e4%b8%ad%e5%93%aa%e4%ba%9b%e5%8c%ba%e5%9f%9f%e6%98%af%e7%ba%bf%e7%a8%8b%e5%85%b1%e4%ba%ab%e7%9a%84%e9%82%a3%e4%ba%9b%e6%98%af%e7%8b%ac%e4%ba%ab%e7%9a%84 class=header-mark></a>16. 运行时数据中哪些区域是线程共享的，那些是独享的？</h2><p>在 JVM 运行时内存区域中，程序计数器、虚拟机栈和本地方法栈是线程独享的。而 Java 堆、方法区是线程共享的。但是值得注意的是，Java 堆其实还为每一个 线程单独分配了一块 TLAB 空间（本地线程分配缓冲），这部分空间在分配时是线程独享的，在使用时是线程共享的。（<a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650124457&amp;idx=1&amp;sn=1c33947700dfb28048df4a913b434077&amp;chksm=f36bad88c41c249ea854b371a1c8597959e2e35c2890bdd6a5945df0b568bdfc980d1dd2cf2b&amp;scene=21" target=_blank rel="noopener noreferrer">TLAB 介绍</a>）</p><p>创建对象时，内存分配过程如何保证线程安全性？有两种解决方案：</p><ul><li>对分配内存空间的动作做同步处理，采用 CAS 机制，配合失败重试的方式保证更新操作的线程安全性。</li><li>每个线程在 Java 堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块"私有"内存中分配，当这部分区域用完之后，再分配新的"私有"内存。这个本地线程分配缓冲就叫做 TLAB。</li></ul><h2 id=17-java-中数组是存储在堆上还是栈上 class=headerLink><a href=#17-java-%e4%b8%ad%e6%95%b0%e7%bb%84%e6%98%af%e5%ad%98%e5%82%a8%e5%9c%a8%e5%a0%86%e4%b8%8a%e8%bf%98%e6%98%af%e6%a0%88%e4%b8%8a class=header-mark></a>17. Java 中数组是存储在堆上还是栈上。</h2><p>在 Java 中，数组同样是一个对象，所以对象在内存中如何存放同样适用于数组；</p><p>所以，数组的实例是保存在堆中，而数组的引用是保存在栈上的。</p><h2 id=18-java-对象创建的过程是怎么样的 class=headerLink><a href=#18-java-%e5%af%b9%e8%b1%a1%e5%88%9b%e5%bb%ba%e7%9a%84%e8%bf%87%e7%a8%8b%e6%98%af%e6%80%8e%e4%b9%88%e6%a0%b7%e7%9a%84 class=header-mark></a>18. Java 对象创建的过程是怎么样的？</h2><p>对于一个普通的 Java 对象的创建，大致过程如下：</p><ul><li><p>虚拟机遇到 new 指令，到常量池定位到这个类的符号引用。</p></li><li><p>检查符号引用代表的类是否被加载、解析、初始化过 ，如果没有的话，则执行相应的类加载过程。</p></li><li><p>虚拟机为对象分配内存。 根据 Java 内存是否规整，分别通过“指针碰撞”或“空闲列表”来分配。</p></li><li><p>虚拟机将分配到的内存空间都初始化为零值。</p></li><li><p>虚拟机对对象进行必要的设置。</p></li><li><p>执行方法，成员变量进行初始化。</p></li></ul><h2 id=19-怎么获取堆和栈的-dump-文件 class=headerLink><a href=#19-%e6%80%8e%e4%b9%88%e8%8e%b7%e5%8f%96%e5%a0%86%e5%92%8c%e6%a0%88%e7%9a%84-dump-%e6%96%87%e4%bb%b6 class=header-mark></a>19. 怎么获取堆和栈的 dump 文件。</h2><p>Java Dump，Java 虚拟机的运行时快照。将 Java 虚拟机运行时的状态和信息保存到文件。</p><p>可以使用在服务器上使用 jmap 命令来获取堆 dump，使用 jstack 命令来获取线程的调用栈 dump。</p><p>参考文章：<a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=402296484&amp;idx=1&amp;sn=8e7fc8197a216afb590b17e15f9b721e&amp;chksm=796493854e131a932b3dd53839820eaba022cb87a601062b6bf6a574d742cd8e92a707432173&amp;scene=21" target=_blank rel="noopener noreferrer">Java 命令学习系列（二）——Jstack </a>和 <a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=402312019&amp;idx=1&amp;sn=97736feb967ecbffb454fa037015ad6d&amp;chksm=7964d6724e135f64a5c0d65e41afbeac45700dd91149375f99071731954e855e13b11cd6c30b&amp;scene=21" target=_blank rel="noopener noreferrer">Java 命令学习系列（三）——Jmap</a></p><h2 id=20-minor-gc-和-full-gc-的触发条件 class=headerLink><a href=#20-minor-gc-%e5%92%8c-full-gc-%e7%9a%84%e8%a7%a6%e5%8f%91%e6%9d%a1%e4%bb%b6 class=header-mark></a>20. Minor GC 和 Full GC 的触发条件。</h2><p>Minor GC 触发条件：当 Eden 区满时，触发 Minor GC。</p><p>Full GC 触发条件：</p><ul><li><p>调用 System.gc 时，系统建议执行 Full GC，但是不必然执行。</p></li><li><p>老年代空间不足。</p></li><li><p>方法区空间不足。</p></li><li><p>concurrent mode failure，当执行 CMS GC 过程时（“标记-清除”，存在内存碎片），同时有对象要放入老年代，而此时老年代空间不足造成的（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC）。</p></li></ul><h2 id=21-在-java-语言中可以作为-gc-roots-的对象有什么 class=headerLink><a href=#21-%e5%9c%a8-java-%e8%af%ad%e8%a8%80%e4%b8%ad%e5%8f%af%e4%bb%a5%e4%bd%9c%e4%b8%ba-gc-roots-%e7%9a%84%e5%af%b9%e8%b1%a1%e6%9c%89%e4%bb%80%e4%b9%88 class=header-mark></a>21. 在 Java 语言中，可以作为 GC Roots 的对象有什么。</h2><p>可作为 GC Roots 的对象包括以下几种：</p><ul><li><p>虚拟机栈（栈桢中的本地变量表）中引用的对象。</p></li><li><p>方法区中类静态属性引用的对象。</p></li><li><p>方法区中常量引用的对象。</p></li><li><p>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。</p></li></ul><p>获取 GC Roots 最主要的部分在解决如果快速找到 JVM 栈的栈桢的局部变量表中的局部变量所引用的对象。大致思路是 JVM 采用了 OopMap 这个数据结构记录了 GC Roots，GC 的标记开始的时候，直接用 <strong>OopMap</strong> 就可以获得 GC Roots。OopMap 记录了特定时刻栈上（内存）和寄存器（CPU）的哪些位置是引用，通过这些引用就可以找到堆中的对象，这些对象就是 GC Roots，而不需要一个一个的去判断某个内存位置的值是不是引用。</p><h2 id=22-类加载过程 class=headerLink><a href=#22-%e7%b1%bb%e5%8a%a0%e8%bd%bd%e8%bf%87%e7%a8%8b class=header-mark></a>22. 类加载过程。</h2><p>Java 虚拟机中类加载的全过程包括：加载、验证、准备、解析和初始化这 5 个阶段。</p><p><strong>加载</strong></p><p>在加载阶段，虚拟机主要完成以下 3 个事情。</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。（这一步骤就是通过类加载器来实现的）</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各类数据的访问入口。</li></ul><p><strong>验证</strong></p><p>验证时连接阶段的第一步，这一阶段的目的是为了<strong>确保</strong> <strong>Class</strong> <strong>文件的字节流中包含的信息符合当前虚拟机的要求</strong>，并且不会危害虚拟机自身的安全。</p><ul><li>文件格式验证：验证字节流是否符合 Class 文件格式的规范，包括文件头部的魔数因子、class 文件主次版本号、class 文件的 MD5 指纹等。</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范。简单来说就是验证 Java 语法的正确性。</li><li>字节码验证：主要验证程序的控制流程，如循环、分支等。</li></ul><p><strong>准备</strong></p><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在<strong>方法区</strong>中分配。需要注意的是，这时候进行内存分配的仅包括<strong>类变量（被</strong> <strong>static</strong> <strong>修饰的变量）</strong>，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</p><p><strong>解析</strong></p><p>解析阶段是虚拟机在常量池内寻找类、接口、字段和方法的符号引用，并且将这些<strong>符号引用替换为直接引用</strong>的过程。符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</p><p><strong>初始化</strong></p><p>初始化阶段是类的加载过程的最后一个阶段，该阶段主要做一件事情就是执行()，该方法<strong>会为所有的静态变量赋予正确的值</strong>。</p><h2 id=23-java-内存泄漏的场景 class=headerLink><a href=#23-java-%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e7%9a%84%e5%9c%ba%e6%99%af class=header-mark></a>23. Java 内存泄漏的场景。</h2><p>内存泄漏是指，一个不再被程序使用的对象或变量还在内存中占有存储空间。虽然 Java 拥有 GC，但还是会出现内存泄漏。举个例子。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>// 首先，要明白，GC 它回收的是不可到达的对象，但是，在 static 的集合类中，引用可以到达，但是却有可能对象已经不用了
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 首先定义一个静态变量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>static</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;();</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>stackOverExam</span><span class=o>(</span><span class=n>Object</span> <span class=n>object</span><span class=o>){</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 当非静态变量被 static 变量持有引用的时候，容易发生内存泄露，因为 object 是一直被 list 引用着的
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>object</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//这里设置为 null 并没有达到释放 object 引用对应对象的效果，毕竟 list 还是持有引用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>object</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>通过上面的代码可以看到，由于 static 指向的对象是不能被垃圾回收器回收的，所以，间接的 object 也是无法被回收的，当业务对象很大而且很多的时候，便有了内存泄漏的风险。所以，可以总结如下规则：</p><p>当全局的静态变量持有局部变量（或者说，大范围的变量持有小范围变量而且小范围变量消耗内存表达、数目变多时），程序便有内存泄漏的风险。一般来说，类似的例子还有，单例模式中的对象，模块之间的调用（后面这个例子提到）等。</p><p>先举一个单例对象的例子。由于单例的静态特征使得其生命周期和应用的生命周期一样长，如果一个对象已经不再被使用，而单例对象还会持有该对象的引用，就会使得该对象不能被正常回收，从而导致了内存泄漏。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Singleton</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=n>singleton</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=kd>private</span> <span class=nf>Singleton</span><span class=o>(</span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>		<span class=k>this</span><span class=o>.</span><span class=na>list</span> <span class=o>=</span> <span class=n>list</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl>	<span class=kd>public</span> <span class=n>Singleton</span> <span class=nf>getInstance</span><span class=o>(</span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>singleton</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>			<span class=n>singleton</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Singleton</span><span class=o>(</span><span class=n>list</span><span class=o>);</span>
</span></span><span class=line><span class=cl>		<span class=o>}</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>singleton</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>另外再举一个模块调用的例子，现在有两个类 A 和 B，其中 B 的默认构造函数上是需要一个 A 的实例作为参数的，这就让 A 和 B 产生了依赖。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=k>new</span> <span class=n>A</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>=</span> <span class=k>new</span> <span class=n>B</span><span class=o>(</span><span class=n>a</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span></code></pre></td></tr></table></div></div><p>a 是对象 A 的引用，b 是对象 B 的引用，对象 B 同时还依赖对象 A，那么这个时候就可以认为对象 B 是可以到达对象 A 的。当 A 对象的引用 a 置为 null 后， a 不再指向对象 A 的引用了，按理说对象 A 可以 GC 了。但是因为 B 依赖着 A，所以这个时候，A 对象是不可能被回收了，造成了内存泄漏。这个时候可以用弱引用 WeakReference 来代替对象 B，就可以解决了这个问题。如下所示。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>A</span> <span class=n>a</span> <span class=o>=</span> <span class=k>new</span> <span class=n>A</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=n>WeakReference</span> <span class=n>wr</span> <span class=o>=</span> <span class=k>new</span> <span class=n>WeakReference</span><span class=o>(</span><span class=n>a</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=kc>null</span><span class=o>;</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=24-jdk18-的虚拟机中内存模型变化 class=headerLink><a href=#24-jdk18-%e7%9a%84%e8%99%9a%e6%8b%9f%e6%9c%ba%e4%b8%ad%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e5%8f%98%e5%8c%96 class=header-mark></a>24. jdk1.8 的虚拟机中内存模型变化。</h2><p>在 jdk1.8 中变化最大的是取消了永久区 Perm，而是用元数据空间 Metaspace 来进行替换。需要注意的是，元空间占用的内存不是虚拟机内部的，而是本地内存空间，当然也不是堆内存。这个变化的理由如下：</p><ul><li><p>在 jdk1.8 之前的 HotSpot 实现中，类的元数据如方法数据、方法信息（字节码、栈和变量的大小）、运行时常量池等保存在永久代。32 位默认永久代为 64M，64 位默认 85M，可以通过参数-XX：MaxPermSize 进行设置，一旦类的元数据超过了永久代的大小，就会抛出 OOM 异常了。</p></li><li><p>对永久代的调优过程很困难，因为永久代的大小很难确定，其中涉及到很多因素，如类的总数、常量池大小和方法数量等，而且永久代的护具可能会随着每一次 Full GC 而发生移动。</p></li><li><p>在 jdk1.8 中，类的元数据保存在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</p></li></ul><h2 id=25-频繁-gc-的原因 class=headerLink><a href=#25-%e9%a2%91%e7%b9%81-gc-%e7%9a%84%e5%8e%9f%e5%9b%a0 class=header-mark></a>25. 频繁 GC 的原因。</h2><ul><li><p>人为因素，在代码中调用了 System.gc()方法。</p></li><li><p>内存原因，设置的堆大小比较小，可以提高堆的空间，比如说提高最小堆空间-Xms 和最大堆空间-Xmx的大小，当然，最好是针对内存的 DUMP 文件进行分析。</p></li><li><p>框架问题，有些框架内部会调用 gc 方法。</p></li><li><p>其他原因，构建的对象实例化十分频繁并且释放对象较为频繁时，也会引起频繁 gc。</p></li></ul><p>如果线上系统突然产生的运行缓慢问题，如果该问题导致线上系统不可用，那么首先需要做的就是，导出 jstack 和内存信息，然后重启系统，尽快保证系统的可用性。这种情况可能的原因主要有两种：</p><ul><li>代码中某个位置读取数据量较大，导致系统内存耗尽，从而导致 Full GC 次数过多，系统缓慢；</li><li>代码中有比较耗 CPU 的操作，导致 CPU 过高，系统运行缓慢。</li></ul><h2 id=26-高并发时jvm-调优 class=headerLink><a href=#26-%e9%ab%98%e5%b9%b6%e5%8f%91%e6%97%b6jvm-%e8%b0%83%e4%bc%98 class=header-mark></a>26. 高并发时，JVM 调优。</h2><p>优化虚拟机堆的空间大小，根据实际物理内存的大小进行比例分配，并根据程序调整好新生代和老年代的比例。并且，堆不进行自动扩展。然后使用ParNew（并发）+CMS 进行垃圾回收，在多线程高并发的情况下，表现很好。</p><p>调优的目标是：</p><ul><li><p>将转移到老年代的对象数量降低到最小 。</p></li><li><p>减少 Full GC 的执行时间。</p></li></ul><h2 id=27-systemgc和-runtimegc的区别 class=headerLink><a href=#27-systemgc%e5%92%8c-runtimegc%e7%9a%84%e5%8c%ba%e5%88%ab class=header-mark></a>27. System.gc()和 Runtime.gc()的区别。</h2><ul><li><p>java.lang.System.gc()只是 java.lang.Runtime.getRuntime().gc()的简写，两者的行为没有任何不同。</p></li><li><p>System.gc()和 runtime.gc()用于建议 jvm 进行垃圾回收，但是否立即回收还是延迟回收由 Java 虚拟机决定。</p></li></ul><p>另外，当我们调用 System.gc()的时候，其实并不会马上进行垃圾回收，甚至不一定会执行垃圾回收。</p><blockquote><p>以上主要参考来源为：《深入理解 Java 虚拟机：JVM 高级特征与最佳实践》</p></blockquote></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-01-13</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-source href=https://github.com/hzleii/hzleii.github.io/blog/content/posts/JVM面试问题总结.md target=_blank rel="noopener noreferrer">查看源代码</a>
</span><span>|&nbsp;<a class=link-to-edit href=https://github.com/hzleii/hzleii.github.io/edit/blog/content/posts/JVM面试问题总结.md target=_blank rel="noopener noreferrer">编辑此页</a></span></div><div class=post-info-share></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/hzleii.github.io1/tags/java/>Java</a>,&nbsp;<a href=/hzleii.github.io1/tags/jvm/>JVM</a>,&nbsp;<a href=/hzleii.github.io1/tags/%E9%9D%A2%E8%AF%95/>面试</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/hzleii.github.io1/>主页</a></span></section></div><div class=post-nav><a href=/hzleii.github.io1/java-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/ class=prev rel=prev title=Java-选择排序><i class="fas fa-angle-left fa-fw"></i>Java-选择排序</a>
<a href=/hzleii.github.io1/viim/ class=next rel=next title="vi/vim 的基本用法">vi/vim 的基本用法<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments><div id=giscus></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/>giscus</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.115.4">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href=https://github.com/HEIGE-PCloud/DoIt target=_blank rel="noopener noreferrer" title="DoIt 0.4.0"><i class="far fa-edit fa-fw"></i> DoIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2019 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/hzleii.github.io1/ target=_blank rel="noopener noreferrer">磊子</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class=footer-line></div><div class=footer-line></div></div><script>"serviceWorker"in navigator&&(navigator.serviceWorker.register("/sw.min.js",{scope:"/"}).then(function(){}),navigator.serviceWorker.ready.then(function(){}))</script></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><div id=cookieconsent-container></div><div class=assets><link rel=stylesheet href=/hzleii.github.io1/lib/lightgallery/lightgallery.min.css><link rel=stylesheet href=/hzleii.github.io1/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:15},comment:{giscus:{darkTheme:"dark",dataCategory:"评论",dataCategoryId:"DIC_kwDOJUTMkM4CVoj8",dataEmitMetadata:"0",dataInputPosition:"bottom",dataLang:"en",dataMapping:"pathname",dataReactionsEnabled:"1",dataRepo:"hzleii/giscus",dataRepoId:"R_kgDOJUTMkA",dataStrict:"0",lightTheme:"light"}},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验."},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightGallery:{actualSize:!1,exThumbImage:"data-thumbnail",hideBarsDelay:2e3,selector:".lightgallery",speed:400,thumbContHeight:80,thumbWidth:80,thumbnail:!0},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/hzleii.github.io1/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!0,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:50,threshold:.1,type:"fuse",useExtendedSearch:!1},table:{sort:!0}}</script><script type=text/javascript src=/hzleii.github.io1/lib/tablesort/tablesort.min.js></script><script type=text/javascript src=/hzleii.github.io1/lib/lightgallery/lightgallery.min.js></script><script type=text/javascript src=/hzleii.github.io1/lib/lightgallery/lg-thumbnail.min.js></script><script type=text/javascript src=/hzleii.github.io1/lib/lightgallery/lg-zoom.min.js></script><script type=text/javascript src=/hzleii.github.io1/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/hzleii.github.io1/lib/cookieconsent/cookieconsent.min.js defer></script><script type=text/javascript src=/hzleii.github.io1/js/cookieconsent.min.js defer></script><script type=text/javascript src=https://website-card-embed.humblex.top/website-card-embed-loveit.js></script><script type=text/javascript src=/hzleii.github.io1/js/theme.min.js defer></script><script type=text/javascript src=/hzleii.github.io1/js/giscus.min.js defer></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XXBC12BWSH",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-XXBC12BWSH" async></script></div></body></html>