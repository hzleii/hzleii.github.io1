[{"categories":["Java"],"content":"Java8 Stream 流操作","date":"2022-06-07","objectID":"/stream/","series":null,"tags":["Stream"],"title":"Java8 Stream 流操作","uri":"/stream/"},{"categories":["Java"],"content":" 什么是 StreamStream翻译称为 “流”，是 Java8 的新特性之一。 Stream将要处理的元素看作是流，这时可以借助Stream API对流中的元素进行中间操作，比如：筛选、排序、排序等。 ","date":"2022-06-07","objectID":"/stream/:1:0","series":null,"tags":["Stream"],"title":"Java8 Stream 流操作","uri":"/stream/#什么是-stream"},{"categories":["Java"],"content":" 特点 不是数据结构，不会保存数据，只会操作数据。 不会改变数据源，它会将操作后的数据保存到另外一个对象中。 延迟执行，流在中间处理过程中，只是对操作进行了记录，并不会立即执行，需要等到执行终止操作的时候才会进行实际的计算。 ","date":"2022-06-07","objectID":"/stream/:1:1","series":null,"tags":["Stream"],"title":"Java8 Stream 流操作","uri":"/stream/#特点"},{"categories":["Java"],"content":" 三个步骤 创建Stream: 从数据源中获取一个流，这个数据源可以是集合、数组。 中间操作：操作链，可以对流进行数据处理。 终止操作：执行终止操作，才会执行中间操作的操作链，终端操作结束后流无法再次使用，会产生一个新的结果。 ","date":"2022-06-07","objectID":"/stream/:1:2","series":null,"tags":["Stream"],"title":"Java8 Stream 流操作","uri":"/stream/#三个步骤"},{"categories":["Java"],"content":" 流的常用创建方法 使用Collection系列集合提供的stream()和parallelStream()方法 // 使用Collection系列集合提供的 stream() 和 parallelStream() 方法 ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); // 返回一个顺序流 Stream\u003cString\u003e stream = list.stream(); // 把顺序流转换成并行流 Stream\u003cString\u003e parallel = list.stream().parallel(); // 返回一个并行流 Stream\u003cString\u003e stringStream = list.parallelStream(); 使用Arrays的静态方法stream()可以获取数组流 String[] strs = new String[10]; Stream\u003cString\u003e stream = Arrays.stream(strs); 调用Stream类静态方法of() Stream\u003cString\u003e stream = Stream.of(\"aa\", \"bbb\", \"c\"); 使用静态方法Stream.iterate()和Stream.generate()创建无限流 // 迭代 Stream\u003cInteger\u003e iterate = Stream.iterate(0, (x) -\u003e x + 2); // 0 2 4 6 8 iterate.limit(5).forEach(System.out::println); // 生成 Stream\u003cDouble\u003e generate = Stream.generate(() -\u003e Math.random()); // 84 28 71 generate.limit(3).forEach(System.out::println); 可以看到创建Stream流的方式有很多。但不论是哪种创建方式，Stream不会保存数据，它只会对数据进行计算。 ","date":"2022-06-07","objectID":"/stream/:2:0","series":null,"tags":["Stream"],"title":"Java8 Stream 流操作","uri":"/stream/#流的常用创建方法"},{"categories":["Java"],"content":" 流的中间操作中间操作可以分为两大类： 有状态操作：需要等上一步操作完之后，拿到全部元素后才可操作，如 sorted 无状态操作：该操作的数据不受上一步操作的影响，如 filter map 多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，不然中间操作不会执行任何处理！ ","date":"2022-06-07","objectID":"/stream/:3:0","series":null,"tags":["Stream"],"title":"Java8 Stream 流操作","uri":"/stream/#流的中间操作"},{"categories":["Java"],"content":" 筛选与切片 方法 描述 filter(Predicate p) 接收 Lambda，从流中排除某些元素 distinct() 筛选，通过流所产生的 hashCode() 和 equals() 去除重复元素 limit(long maxSize) 截断流，使其元素不超过给定数量 skip(long n) 跳过元素，返回一个扔掉了前 n 个元素的流，若流中元素不足 n 个，则返回一个空流，与 limit(n) 互补 // 流的中间操作 List\u003cInteger\u003e integers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 2, 5, 7, 9, 17); /** * 1.筛选与切片 * filter：过滤流中的某些元素 * limit(n)：获取 n 个元素 * skip(n)：跳过 n 元素，若流中元素不足 n 个，则返回一个空流，配合 limit(n) 可实现分页 * distinct：通过流中元素的 hashCode() 和 equals() 去除重复元素 */ // 创建流 Stream\u003cInteger\u003e stream = integers.stream(); // 中间操作 Stream\u003cInteger\u003e integersStream = stream .filter((t) -\u003e t \u003e 5) // 6 7 8 9 10 7 9 17 .distinct() // 6 7 8 9 10 17 .skip(2) // 8 9 10 17 .limit(3); //8 9 10 integersStream.forEach(System.out::println); ","date":"2022-06-07","objectID":"/stream/:3:1","series":null,"tags":["Stream"],"title":"Java8 Stream 流操作","uri":"/stream/#筛选与切片"},{"categories":["Java"],"content":" 映射 方法 描述 map(Function f) 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连成一个流 map // 将每个元素转换为大写 List\u003cString\u003e list = Arrays.asList(\"a,a=\", \"b,b=\", \"cc=\", \"d,d=\"); List\u003cString\u003e collect = list.stream().map(String::toUpperCase).collect(Collectors.toList()); // str -\u003e str.toUpperCase() 可以简写为 String::toUpperCase System.out.println(collect); // 结果：[A,A=, B,B=, CC=, D,D=] List\u003cEmployee\u003e employees = Arrays.asList( new Employee(\"张三\", 23, 9999.99), new Employee(\"李四\", 24, 5555.55), new Employee(\"王五\", 25, 6666.66), new Employee(\"赵六\", 26, 3333.33), new Employee(\"周七\", 27, 7777.77) ); // 提取员工名称 List\u003cString\u003e collect1 = employees.stream() // 类::实例方法名 .map(Employee::getName) .collect(Collectors.toList()); System.out.println(collect1); // 输出：[张三, 李四, 王五, 赵六, 周七] mapToInt List\u003cString\u003e list = Arrays.asList(\"a,a\", \"b,b\", \"cc\", \"d,d\"); IntStream intStream = list.stream() .mapToInt(String::length); intStream.forEach(System.out::println); // 输出： // 3 // 3 // 2 // 3 flatMap List\u003cString\u003e list = Arrays.asList(\"a,a=\",\"b,b=\",\"cc=\",\"d,d=\"); Stream\u003cString\u003e stringStream = list.stream() .flatMap(str -\u003e { String[] split = str.split(\",\"); Stream\u003cString\u003e stream = Arrays.stream(split); return stream; }); List\u003cString\u003e collect = stringStream.collect(Collectors.toList()); System.out.println(collect); // 输出： // [a, a=, b, b=, cc=, d, d=] ","date":"2022-06-07","objectID":"/stream/:3:2","series":null,"tags":["Stream"],"title":"Java8 Stream 流操作","uri":"/stream/#映射"},{"categories":["Java"],"content":" 排序 方法 描述 sorted() 产生一个新的流，其中按自然顺序排序 sorted(Comparator com) 产生一个新的流，其中按比较器顺序排序 sorted List\u003cString\u003e list = Arrays.asList(\"bb\", \"cc\", \"ee\", \"aa\"); list.stream().sorted().forEach(System.out::println); // 输出： // aa // bb // cc // dd sorted(Comparator com) List\u003cEmployee\u003e employees = Arrays.asList( new Employee(\"张三\", 18, 9999.99), new Employee(\"李四\", 38, 5555.55), new Employee(\"王五\", 50, 6666.66), new Employee(\"赵六\", 15, 3333.33), new Employee(\"周七\", 18, 7777.77) ); // 如果年龄一致，就按照姓名排序，如果不一致，就按照年龄升序排序 employees.stream().sorted((e1, e2) -\u003e { if (e1.getAge().equals(e2.getAge())) { return e1.getName().compareTo(e2.getName()); } else { return e1.getAge().compareTo(e2.getAge()); } }).forEach(System.out::println); // 输出： // name='赵六', age=15, salary=3333.33 // name='张三', age=18, salary=9999.99 // name='周七', age=18, salary=7777.77 // name='李四', age=38, salary=5555.55 // name='王五', age=50, salary=6666.66 ","date":"2022-06-07","objectID":"/stream/:3:3","series":null,"tags":["Stream"],"title":"Java8 Stream 流操作","uri":"/stream/#排序"},{"categories":["Java"],"content":" 流的终止操作 终端操作会从流水线中产生结果。其结果可以是任何不是流的值，例如：List、Integer、String 流进行了终止操作后，不能再次使用。 ","date":"2022-06-07","objectID":"/stream/:4:0","series":null,"tags":["Stream"],"title":"Java8 Stream 流操作","uri":"/stream/#流的终止操作"},{"categories":["Java"],"content":" 匹配和查找 方法 描述 allMatch(Predicate p) 检查是否匹配所有元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意元素 count() 返回流中元素总数 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 forEach(Consumer c) 内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代)。 allMatch // 判断数据流中所有元素是否与 aa 相等，全部相等则返回true List\u003cString\u003e list = Arrays.asList(\"aa\", \"bb\", \"cc\", \"dd\"); boolean aa = list.stream().allMatch(s -\u003e s.equals(\"aa\")); System.out.println(aa); // 输出： // false List\u003cString\u003e list = Arrays.asList(\"aa\", \"aa\", \"aa\", \"aa\"); boolean aa = list.stream().allMatch(s -\u003e s.equals(\"aa\")); System.out.println(aa); // 输出： // true anyMatch // 判断数据流中所有元素是否有一个与 aa 相等，相等则返回 true List\u003cString\u003e list = Arrays.asList(\"aa\", \"bb\", \"cc\", \"dd\"); boolean aa = list.stream().anyMatch(obj -\u003e obj.equals(\"aa\")); System.out.println(aa); // 输出： // true noneMatch // 判断数据流中所有元素是否全部与 aa1 相等，一个都没有匹配成功则返回 true。 List\u003cString\u003e list = Arrays.asList(\"aa\", \"bb\", \"cc\", \"dd\"); boolean aa = list.stream().noneMatch(obj -\u003e obj.equals(\"aa1\")); System.out.println(aa); // 输出： // true findFirst // 返回第一个元素 List\u003cString\u003e list = Arrays.asList(\"aa\", \"bb\", \"cc\", \"dd\"); Optional\u003cString\u003e first = list.stream().findFirst(); System.out.println(first.get()); // 输出： // aa findAny // 返回当前流中的任意元素 List\u003cString\u003e list = Arrays.asList(\"aa\", \"bb\", \"cc\", \"dd\"); Optional\u003cString\u003e first = list.stream().findAny(); System.out.println(first.get()); // 输出： // aa // 由于是顺序流所以每次返回的都是第一个元素。使用并行流： List\u003cString\u003e list = Arrays.asList(\"aa\", \"bb\", \"cc\", \"dd\"); Optional\u003cString\u003e first = list.parallelStream().findAny(); System.out.println(first.get()); count List\u003cInteger\u003e list = Arrays.asList(1, 2, 3, 4, 5); long count = list.stream().count(); System.out.println(count); // 输出： // 5 max(Comparator c) List\u003cInteger\u003e list = Arrays.asList(1, 2, 3, 4, 5); Optional\u003cInteger\u003e max = list.stream().max(Integer::compareTo); System.out.println(max.get()); // 输出： // 5 min(Comparator c) List\u003cInteger\u003e list = Arrays.asList(1, 2, 3, 4, 5); Optional\u003cInteger\u003e max = list.stream().min(Integer::compareTo); System.out.println(max.get()); // 输出： // 1 forEach(Consumer c) List\u003cInteger\u003e list = Arrays.asList(1, 2, 3, 4, 5); list.forEach(System.out::println); // 输出： // 1 // 2 // 3 // 4 // 5 ","date":"2022-06-07","objectID":"/stream/:4:1","series":null,"tags":["Stream"],"title":"Java8 Stream 流操作","uri":"/stream/#匹配和查找"},{"categories":["Java"],"content":" 规范 方法 描述 T reduce(T i, BinaryOperator\u003cT\u003e a) 可以将流中元素反复结合起来，得到一个值。返回 T Optional\u003cT\u003e reduce(BinaryOperator\u003cT\u003e a) 可以将流中元素反复结合起来，得到一个值，返回Optional\u003cT\u003e T reduce(T i, BinaryOperator\u003cT\u003e a) List\u003cInteger\u003e list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); Integer reduce = list.stream().reduce(0, (x1, x2) -\u003e x1 + x2); System.out.println(reduce); // 输出： // 55 // 第一个参数是起始值，如果起始值为10呢？ List\u003cInteger\u003e list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); Integer reduce = list.stream().reduce(10, (x1, x2) -\u003e x1 + x2); System.out.println(reduce); // 输出： // 65 第一次执行时，会将 i(也就是 10 ) 的值作为 a 函数的第一个参数，第二个参数为流中元素的第一个元素；第二次执行时，第一个参数为第一次函数执行的结果，第二个参数为流中的第二个元素；依次类推。 Optional\u003cT\u003e reduce(BinaryOperator\u003cT\u003e a) List\u003cInteger\u003e list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); Optional\u003cInteger\u003e reduce = list.stream().reduce(Integer::sum); System.out.println(reduce.get()); // 输出： // 55 流程与第一个方法是一致的，只是第一次执行时，第一个参数为流中的第一个元素，第二个参数为流中元素的第二个元素。 ","date":"2022-06-07","objectID":"/stream/:5:0","series":null,"tags":["Stream"],"title":"Java8 Stream 流操作","uri":"/stream/#规范"},{"categories":["Java"],"content":" 收集 方法 描述 collect(Collector c) 将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法 Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map中)。 另外， Collectors 类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表： 方法 返回类型 作用 toList List\u003cT\u003e 把流中元素收集到List toSet Set\u003cT\u003e 把流中元素收集到Set toCollection Collection\u003cT\u003e 把流中元素收集到创建的集合 counting Long 计算流中元素的个数 summingInt Integer 对流中元素的整数属性求和 averagingInt Double 计算流中元素Integer属性的平均值 summarizingInt IntSummaryStatistics 收集流中Integer属性的统计值，如：平均值 joining String 连接流中每个字符串 maxBy Optional\u003cT\u003e 根据比较器选择最大值 minBy Optional\u003cT\u003e 根据比较器选择最小值 reducing 归约产生的类型 从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值 collectingAndThen 转换函数返回的类型 包裹另一个收集器，对其结果转换函数 groupingBy Map\u003cK, List\u003cT» 根据某属性对流进行分组，属性为K，结果为V partitioningBy Map\u003cBoolean, List\u003cT» 根据true或false进行分区 toList // 获取到员工的姓名并放入 List 集合中 List\u003cEmployee\u003e employees = Arrays.asList( new Employee(\"张三\", 18, 9999.99), new Employee(\"李四\", 38, 5555.55), new Employee(\"王五\", 50, 6666.66), new Employee(\"赵六\", 15, 3333.33), new Employee(\"周七\", 18, 7777.77) ); List\u003cString\u003e collect = employees.stream() .map(Employee::getName) .collect(Collectors.toList()); collect.forEach(System.out::println); // 输出： // 张三 // 李四 // 王五 // 赵六 // 周七 toCollection // 获取到员工的姓名并放入 HashSet 集合中 List\u003cEmployee\u003e employees = Arrays.asList( new Employee(\"张三\", 18, 9999.99), new Employee(\"李四\", 38, 5555.55), new Employee(\"王五\", 50, 6666.66), new Employee(\"赵六\", 15, 3333.33), new Employee(\"周七\", 18, 7777.77) ); HashSet\u003cString\u003e hs = employees.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new)); hs.forEach(System.out::println); counting、summingDouble、averagingDouble、maxBy // 分别为：计数、求和、平均值、最值 List\u003cEmployee\u003e employees = Arrays.asList( new Employee(\"张三\", 18, 9999.99), new Employee(\"李四\", 38, 5555.55), new Employee(\"王五\", 50, 6666.66), new Employee(\"赵六\", 15, 3333.33), new Employee(\"周七\", 18, 7777.77) ); // 元素的个数 Long l = employees.stream() .map(Employee::getName) .collect(Collectors.counting()); System.out.println(\"个数：\" + l); // 求和 Double sum = employees.stream() .collect(Collectors.summingDouble(Employee::getAge)); System.out.println(\"求和：\" + sum); // 平均值 Double avg = employees.stream() .collect(Collectors.averagingDouble(Employee::getAge)); System.out.println(\"平均值：\" + avg); // 获得年龄最大的员工信息 Optional\u003cEmployee\u003e collect = employees.stream() .collect(Collectors.maxBy((e1, e2) -\u003e Integer.compare(e1.getAge(), e2.getAge()))); System.out.println(\"获得年龄最大的员工信息：\" + collect.get()); // 输出： // 个数：5 // 求和：139.0 // 平均值：27.8 // 获得年龄最大的员工信息：name='王五', age=50, salary=6666.66 summarizingInt // 收集流中 Integer 属性的统计值。 List\u003cEmployee\u003e employees = Arrays.asList( new Employee(\"张三\", 18, 9999.99), new Employee(\"李四\", 38, 5555.55), new Employee(\"王五\", 50, 6666.66), new Employee(\"赵六\", 15, 3333.33), new Employee(\"周七\", 18, 7777.77) ); IntSummaryStatistics collect = employees.stream().collect(Collectors.summarizingInt(Employee::getAge)); System.out.println(\"个数：\" + collect.getCount()); System.out.println(\"求和：\" + collect.getSum()); System.out.println(\"最大值：\" + collect.getMax()); System.out.println(\"平均值：\" + collect.getAverage()); System.out.println(\"最小值：\" + collect.getMin()); // 输出： // 个数：5 // 求和：139 // 最大值：50 // 平均值：27.8 // 最小值：15 groupingBy // 根据年龄进行分组 List\u003cEmployee\u003e employees = Arrays.asList( new Employee(\"张三\", 18, 9999.99), new Employee(\"李四\", 38, 5555.55), new Employee(\"王五\", 50, 6666.66), new Employee(\"赵六\", 15, 3333.33), new Employee(\"周七\", 18, 7777.77) ); Map\u003cInteger, List\u003cEmployee\u003e\u003e collect = employees.stream().collect(Collectors.groupingBy(Employee::getAge)); for(Integer key : collect.keySet()){ System.out.println(\"key: \" + key + \", value: \" + collect.get(key)); } // 输出： // key: 50, value: [Employee(name=王五, age=50, salary=6666.66)] // key: 18, value: [Employee(name=张三, age=18, salary=9999.99), Employee(name=周七, age=18, salary=7777.77)] // key: 38, value: [Employee(name=李四, age=38, salary=5555.55)] // key: 15, value: [Employee(name=赵六, age=15, salary=3333.33)] partitioningBy：将 stream 按条件分为两个 Map，true或false // 薪资是否大于7000 List\u003cEmployee\u003e employees = Arrays.asList( new Employ","date":"2022-06-07","objectID":"/stream/:6:0","series":null,"tags":["Stream"],"title":"Java8 Stream 流操作","uri":"/stream/#收集"},{"categories":["Development"],"content":" 简介 Oracle Database，又名 Oracle RDBMS，简称 Oracle。是甲骨文公司推出的一款关系数据库管理系统。 Oracle 数据库系统是目前世界上流行的关系数据库管理系统，拥有可移植性好、使用方便、功能强等优点，在各类大、中、小、微机环境中都适用。 Oracle 是一种高效率、可靠性好的、适应高吞吐量的数据库解决方案。 ","date":"2021-10-09","objectID":"/oracle/:1:0","series":null,"tags":["Support"],"title":"Oracle 的使用","uri":"/oracle/#简介"},{"categories":["Development"],"content":" 入门 ","date":"2021-10-09","objectID":"/oracle/:2:0","series":null,"tags":["Support"],"title":"Oracle 的使用","uri":"/oracle/#入门"},{"categories":["Development"],"content":" 安装","date":"2021-10-09","objectID":"/oracle/:3:0","series":null,"tags":["Support"],"title":"Oracle 的使用","uri":"/oracle/#安装"},{"categories":["Development"],"content":" Docker 安装开发环境 Oracle 11g ","date":"2021-10-09","objectID":"/oracle/:3:1","series":null,"tags":["Support"],"title":"Oracle 的使用","uri":"/oracle/#docker-安装开发环境-oracle-11g"},{"categories":["Development"],"content":" 扩展","date":"2021-10-09","objectID":"/oracle/:4:0","series":null,"tags":["Support"],"title":"Oracle 的使用","uri":"/oracle/#扩展"},{"categories":["Development"],"content":" Oracle number 对应 Java 数据类型 Oracle-number-对应-Java-数据类型 ","date":"2021-10-09","objectID":"/oracle/:4:1","series":null,"tags":["Support"],"title":"Oracle 的使用","uri":"/oracle/#oracle-number-对应-java-数据类型"},{"categories":["Development"],"content":" 应用场景","date":"2021-10-09","objectID":"/oracle/:5:0","series":null,"tags":["Support"],"title":"Oracle 的使用","uri":"/oracle/#应用场景"},{"categories":["Development"],"content":" 查看表字段数据结构 SELECT UTC.COLUMN_NAME, DATA_TYPE, DATA_LENGTH, COMMENTS FROM USER_TAB_COLUMNS UTC LEFT JOIN USER_COL_COMMENTS UCC ON UTC.TABLE_NAME = UCC.TABLE_NAME AND UTC.COLUMN_NAME = UCC.COLUMN_NAME WHERE UTC.TABLE_NAME = 'TABLE_NAME' ORDER BY COLUMN_ID; ","date":"2021-10-09","objectID":"/oracle/:5:1","series":null,"tags":["Support"],"title":"Oracle 的使用","uri":"/oracle/#查看表字段数据结构"},{"categories":["Development"],"content":" Oracle 创建用户，表空间并授权 -- 查询表空间物理路径 select * from sys.DBA_DATA_FILES; -- 创建表空间 create tablespace FOO datafile '/home/oracle/app/oracle/oradata/helowin/FOO01.dbf' size 50M autoextend on next 50M; -- 创建用户绑定表空间 create user FOO identified by FOO default tablespace FOO; -- 授权 grant connect,resource to FOO; grant create any sequence to FOO; grant create any table to FOO; grant delete any table to FOO; grant insert any table to FOO; grant select any table to FOO; grant unlimited tablespace to FOO; grant execute any procedure to FOO; grant update any table to FOO; grant create any view to FOO; grant imp_full_database to FOO; ","date":"2021-10-09","objectID":"/oracle/:5:2","series":null,"tags":["Support"],"title":"Oracle 的使用","uri":"/oracle/#oracle-创建用户表空间并授权"},{"categories":["Development"],"content":" Oracle 删除用户、关联数据及其表空间 DROP USER USERNAME CASCADE; DROP TABLESPACE USERNAME INCLUDING CONTENTS AND DATAFILES; ","date":"2021-10-09","objectID":"/oracle/:5:3","series":null,"tags":["Support"],"title":"Oracle 的使用","uri":"/oracle/#oracle-删除用户关联数据及其表空间"},{"categories":["Development"],"content":" Oracle 导出导入数据 # exp 和 imp 的简单使用 exp user/pwd@sid owner=user file=file.dmp log=exp.log feedback=1000 imp user/pwd@sid fromuser=user touser=user file=file.dmp log=imp.log feedback=1000 exp 参数说明 参数名 说明 默认值 USERID 用户名/口令 FULL 导出整个文件 N BUFFER 数据缓冲区的大小 OWNER 导出指定的所有者用户名列表 FILE 输出文件 (EXPDAT.DMP) TABLES 导出指定的表名列表 COMPRESS 是否压缩导出的文件 Y RECORDLENGTH IO 记录的长度 GRANTS 导出权限 Y INCTYPE 增量导出类型 INDEXES 导出索引 Y RECORD 跟踪增量导出 Y ROWS 导出数据行 Y PARFILE 参数文件名 CONSTRAINTS 导出限制 Y CONSISTENT 交叉表一致性 LOG 屏幕输出的日志文件 STATISTICS 分析对象(ESTIMATE) DIRECT 直接路径 N TRIGGERS 导出触发器 Y FEEDBACK 显示每 x 行 (0) 的进度 FILESIZE 各转储文件的最大尺寸 QUERY 选定导出表子集的子句 TRANSPORT_TABLESPACE 导出可传输的表空间元数据 N TABLESPACES 导出指定的表空间列表 imp 参数说明 参数名 说明 默认值 USERID 用户名/口令 FULL 导入整个文件 N BUFFER 数据缓冲区大小 FROMUSER 所有人用户名列表 FILE 输入文件 (EXPDAT.DMP) TOUSER 用户名列表 SHOW 只列出文件内容 N TABLES 表名列表 IGNORE 忽略创建错误 N RECORDLENGTH IO 记录的长度 GRANTS 导入权限 Y INCTYPE 增量导入类型 INDEXES 导入索引 Y COMMIT 提交数组插入 N ROWS 导入数据行 Y PARFILE 参数文件名 LOG 屏幕输出的日志文件 CONSTRAINTS 导入限制 Y DESTROY 覆盖表空间数据文件 N INDEXFILE 将表/索引信息写入指定的文件 SKIP_UNUSABLE_INDEXES 跳过不可用索引的维护 N FEEDBACK 每 x 行显示进度 TOID_NOVALIDATE 跳过指定类型 ID 的验证 FILESIZE 每个转储文件的最大大小 STATISTICS 始终导入预计算的统计信息 RESUMABLE 在遇到有关空间的错误时挂起 RESUMABLE_NAME 用来标识可恢复语句的文本字符串 RESUMABLE_TIMEOUT RESUMABLE 的等待时间 COMPILE 编译过程, 程序包和函数 Y STREAMS_CONFIGURATION 导入 Streams 的一般元数据 Y STREAMS_INSTANITATION 导入 Streams 的实例化元数据 N TRANSPORT_TABLESPACE 导入可传输的表空间元数据 TABLESPACES 将要传输到数据库的表空间 DATAFILES 将要传输到数据库的数据文件 TTS_OWNERS 拥有可传输表空间集中数据的用户 ","date":"2021-10-09","objectID":"/oracle/:5:4","series":null,"tags":["Support"],"title":"Oracle 的使用","uri":"/oracle/#oracle-导出导入数据"},{"categories":["Development"],"content":" Oracle 导出导入数据 # exp 和 imp 的简单使用 exp user/pwd@sid owner=user file=file.dmp log=exp.log feedback=1000 imp user/pwd@sid fromuser=user touser=user file=file.dmp log=imp.log feedback=1000 exp 参数说明 参数名 说明 默认值 USERID 用户名/口令 FULL 导出整个文件 N BUFFER 数据缓冲区的大小 OWNER 导出指定的所有者用户名列表 FILE 输出文件 (EXPDAT.DMP) TABLES 导出指定的表名列表 COMPRESS 是否压缩导出的文件 Y RECORDLENGTH IO 记录的长度 GRANTS 导出权限 Y INCTYPE 增量导出类型 INDEXES 导出索引 Y RECORD 跟踪增量导出 Y ROWS 导出数据行 Y PARFILE 参数文件名 CONSTRAINTS 导出限制 Y CONSISTENT 交叉表一致性 LOG 屏幕输出的日志文件 STATISTICS 分析对象(ESTIMATE) DIRECT 直接路径 N TRIGGERS 导出触发器 Y FEEDBACK 显示每 x 行 (0) 的进度 FILESIZE 各转储文件的最大尺寸 QUERY 选定导出表子集的子句 TRANSPORT_TABLESPACE 导出可传输的表空间元数据 N TABLESPACES 导出指定的表空间列表 imp 参数说明 参数名 说明 默认值 USERID 用户名/口令 FULL 导入整个文件 N BUFFER 数据缓冲区大小 FROMUSER 所有人用户名列表 FILE 输入文件 (EXPDAT.DMP) TOUSER 用户名列表 SHOW 只列出文件内容 N TABLES 表名列表 IGNORE 忽略创建错误 N RECORDLENGTH IO 记录的长度 GRANTS 导入权限 Y INCTYPE 增量导入类型 INDEXES 导入索引 Y COMMIT 提交数组插入 N ROWS 导入数据行 Y PARFILE 参数文件名 LOG 屏幕输出的日志文件 CONSTRAINTS 导入限制 Y DESTROY 覆盖表空间数据文件 N INDEXFILE 将表/索引信息写入指定的文件 SKIP_UNUSABLE_INDEXES 跳过不可用索引的维护 N FEEDBACK 每 x 行显示进度 TOID_NOVALIDATE 跳过指定类型 ID 的验证 FILESIZE 每个转储文件的最大大小 STATISTICS 始终导入预计算的统计信息 RESUMABLE 在遇到有关空间的错误时挂起 RESUMABLE_NAME 用来标识可恢复语句的文本字符串 RESUMABLE_TIMEOUT RESUMABLE 的等待时间 COMPILE 编译过程, 程序包和函数 Y STREAMS_CONFIGURATION 导入 Streams 的一般元数据 Y STREAMS_INSTANITATION 导入 Streams 的实例化元数据 N TRANSPORT_TABLESPACE 导入可传输的表空间元数据 TABLESPACES 将要传输到数据库的表空间 DATAFILES 将要传输到数据库的数据文件 TTS_OWNERS 拥有可传输表空间集中数据的用户 ","date":"2021-10-09","objectID":"/oracle/:5:4","series":null,"tags":["Support"],"title":"Oracle 的使用","uri":"/oracle/#exp-参数说明"},{"categories":["Development"],"content":" Oracle 导出导入数据 # exp 和 imp 的简单使用 exp user/pwd@sid owner=user file=file.dmp log=exp.log feedback=1000 imp user/pwd@sid fromuser=user touser=user file=file.dmp log=imp.log feedback=1000 exp 参数说明 参数名 说明 默认值 USERID 用户名/口令 FULL 导出整个文件 N BUFFER 数据缓冲区的大小 OWNER 导出指定的所有者用户名列表 FILE 输出文件 (EXPDAT.DMP) TABLES 导出指定的表名列表 COMPRESS 是否压缩导出的文件 Y RECORDLENGTH IO 记录的长度 GRANTS 导出权限 Y INCTYPE 增量导出类型 INDEXES 导出索引 Y RECORD 跟踪增量导出 Y ROWS 导出数据行 Y PARFILE 参数文件名 CONSTRAINTS 导出限制 Y CONSISTENT 交叉表一致性 LOG 屏幕输出的日志文件 STATISTICS 分析对象(ESTIMATE) DIRECT 直接路径 N TRIGGERS 导出触发器 Y FEEDBACK 显示每 x 行 (0) 的进度 FILESIZE 各转储文件的最大尺寸 QUERY 选定导出表子集的子句 TRANSPORT_TABLESPACE 导出可传输的表空间元数据 N TABLESPACES 导出指定的表空间列表 imp 参数说明 参数名 说明 默认值 USERID 用户名/口令 FULL 导入整个文件 N BUFFER 数据缓冲区大小 FROMUSER 所有人用户名列表 FILE 输入文件 (EXPDAT.DMP) TOUSER 用户名列表 SHOW 只列出文件内容 N TABLES 表名列表 IGNORE 忽略创建错误 N RECORDLENGTH IO 记录的长度 GRANTS 导入权限 Y INCTYPE 增量导入类型 INDEXES 导入索引 Y COMMIT 提交数组插入 N ROWS 导入数据行 Y PARFILE 参数文件名 LOG 屏幕输出的日志文件 CONSTRAINTS 导入限制 Y DESTROY 覆盖表空间数据文件 N INDEXFILE 将表/索引信息写入指定的文件 SKIP_UNUSABLE_INDEXES 跳过不可用索引的维护 N FEEDBACK 每 x 行显示进度 TOID_NOVALIDATE 跳过指定类型 ID 的验证 FILESIZE 每个转储文件的最大大小 STATISTICS 始终导入预计算的统计信息 RESUMABLE 在遇到有关空间的错误时挂起 RESUMABLE_NAME 用来标识可恢复语句的文本字符串 RESUMABLE_TIMEOUT RESUMABLE 的等待时间 COMPILE 编译过程, 程序包和函数 Y STREAMS_CONFIGURATION 导入 Streams 的一般元数据 Y STREAMS_INSTANITATION 导入 Streams 的实例化元数据 N TRANSPORT_TABLESPACE 导入可传输的表空间元数据 TABLESPACES 将要传输到数据库的表空间 DATAFILES 将要传输到数据库的数据文件 TTS_OWNERS 拥有可传输表空间集中数据的用户 ","date":"2021-10-09","objectID":"/oracle/:5:4","series":null,"tags":["Support"],"title":"Oracle 的使用","uri":"/oracle/#imp-参数说明"},{"categories":["Development"],"content":" DBLink 的创建和使用 -- 查询现有 DBLink SELECT * FROM DBA_DB_LINKS; -- 创建公共 DBLink CREATE PUBLIC DATABASE LINK \u003cDBLink 名称\u003e CONNECT TO \u003c用户名\u003e IDENTIFIED BY \u003c密码\u003e USING '(description=(address=(protocol=TCP)(host=127.0.0.1)(port=1521))(connect_data=(SERVICE_NAME=orcl)))'; -- 删除公共 DBLink DROP PUBLIC DATABASE LINK \u003cDBLink 名称\u003e; -- 使用DBLink 查询 SELECT * FROM \u003c表名\u003e@\u003cDBLink 名称\u003e; ","date":"2021-10-09","objectID":"/oracle/:5:5","series":null,"tags":["Support"],"title":"Oracle 的使用","uri":"/oracle/#dblink-的创建和使用"},{"categories":["Development"],"content":" 锁表问题处理 -- 查询锁表信息 SELECT SESS.SID,SESS.SERIAL#, LO.ORACLE_USERNAME,LO.OS_USER_NAME, AO.OBJECT_NAME,LO.LOCKED_MODE FROM V$LOCKED_OBJECT LO,DBA_OBJECTS AO,V$SESSION SESS WHERE AO.OBJECT_ID=LO.OBJECT_ID AND LO.SESSION_ID=SESS.SID; -- 杀死锁表的 SESSION ALTER SYSTEM KILL SESSION 'SID,SERIAL'; ","date":"2021-10-09","objectID":"/oracle/:5:6","series":null,"tags":["Support"],"title":"Oracle 的使用","uri":"/oracle/#锁表问题处理"},{"categories":["Development"],"content":" 如何将逗号分隔的值字符串拆分为 Oracle 数据库中的行 ","date":"2021-10-09","objectID":"/oracle/:5:7","series":null,"tags":["Support"],"title":"Oracle 的使用","uri":"/oracle/#如何将逗号分隔的值字符串拆分为-oracle-数据库中的行"},{"categories":["MySQL"],"content":"MySQL 行转列，列转行","date":"2021-06-08","objectID":"/row2column/","series":null,"tags":["MySQL"],"title":"MySQL 行转列，列转行","uri":"/row2column/"},{"categories":["MySQL"],"content":" 行转列即将原本同一列下多行的不同内容作为多个字段，输出对应内容 ","date":"2021-06-08","objectID":"/row2column/:1:0","series":null,"tags":["MySQL"],"title":"MySQL 行转列，列转行","uri":"/row2column/#行转列"},{"categories":["MySQL"],"content":" 测试数据建表： DROP TABLE IF EXISTS TB_SCORE; CREATE TABLE TB_SCORE ( ID INT ( 11 ) NOT NULL auto_increment, USER_ID VARCHAR ( 20 ) NOT NULL COMMENT '用户id', SUBJECT VARCHAR ( 20 ) COMMENT '科目', SCORE DOUBLE COMMENT '成绩', PRIMARY KEY ( ID ) ) ENGINE = INNODB DEFAULT CHARSET = utf8; 插入数据： INSERT INTO TB_SCORE(USER_ID, SUBJECT, SCORE) VALUES ('1001', '语文', 90); INSERT INTO TB_SCORE(USER_ID, SUBJECT, SCORE) VALUES ('1001', '数学', 92); INSERT INTO TB_SCORE(USER_ID, SUBJECT, SCORE) VALUES ('1001', '英语', 80); INSERT INTO TB_SCORE(USER_ID, SUBJECT, SCORE) VALUES ('1002', '语文', 88); INSERT INTO TB_SCORE(USER_ID, SUBJECT, SCORE) VALUES ('1002', '数学', 90); INSERT INTO TB_SCORE(USER_ID, SUBJECT, SCORE) VALUES ('1002', '英语', 75); INSERT INTO TB_SCORE(USER_ID, SUBJECT, SCORE) VALUES ('1003', '语文', 70); INSERT INTO TB_SCORE(USER_ID, SUBJECT, SCORE) VALUES ('1003', '数学', 85); INSERT INTO TB_SCORE(USER_ID, SUBJECT, SCORE) VALUES ('1003', '英语', 90); INSERT INTO TB_SCORE(USER_ID, SUBJECT, SCORE) VALUES ('1003', '政治', 82); 查询表中数据： SELECT * FROM TB_SCORE ID USER_ID SUBJECT SCORE 1 1001 语文 90 2 1001 数学 92 3 1001 英语 80 4 1002 语文 88 5 1002 数学 90 6 1002 英语 75 7 1003 语文 70 8 1003 数学 85 9 1003 英语 90 10 1003 政治 82 ","date":"2021-06-08","objectID":"/row2column/:1:1","series":null,"tags":["MySQL"],"title":"MySQL 行转列，列转行","uri":"/row2column/#测试数据"},{"categories":["MySQL"],"content":" 1. 使用case...when...then SELECT USER_ID, SUM(CASE `SUBJECT` WHEN '语文' THEN SCORE ELSE 0 END) as '语文', SUM(CASE `SUBJECT` WHEN '数学' THEN SCORE ELSE 0 END) as '数学', SUM(CASE `SUBJECT` WHEN '英语' THEN SCORE ELSE 0 END) as '英语', SUM(CASE `SUBJECT` WHEN '政治' THEN SCORE ELSE 0 END) as '政治' FROM TB_SCORE GROUP BY USER_ID ","date":"2021-06-08","objectID":"/row2column/:1:2","series":null,"tags":["MySQL"],"title":"MySQL 行转列，列转行","uri":"/row2column/#1-使用casewhenthen"},{"categories":["MySQL"],"content":" 2. 使用IF() SELECT USER_ID, SUM(IF(`SUBJECT` = '语文', SCORE, 0)) as '语文', SUM(IF(`SUBJECT` = '数学', SCORE, 0)) as '数学', SUM(IF(`SUBJECT` = '英语', SCORE, 0)) as '英语', SUM(IF(`SUBJECT` = '政治', SCORE, 0)) as '政治' FROM TB_SCORE GROUP BY USER_ID 两者运行结果都为： USER_ID 语文 数学 英语 政治 1001 90 92 80 0 1002 88 90 75 0 1003 70 85 90 82 可以看出，这里行转列是将原来的SUBJECT字段的多行内容选出来，作为结果集中的不同列，并根据USER_ID进行分组显示对应的SCORE。 注意 SUM()是为了能够使用GROUP BY根据USER_ID进行分组，因为每一个USER_ID对应的SUBJECT=语文的记录只有一条，所以SUM()的值就等于对应那一条记录的score的值。 假如USER_ID = '1001' AND SUBJECT = '语文'的记录有两条，则此时SUM()的值将会是这两条记录的和，同理，使用MAX()的值将会是这两条记录里面最大的一个。但是正常情况下，一个USER对应一个SUBJECT只有一个分数，因此使用 SUM()、MAX()、MIN()、AVG()等聚合函数都可以达到行转列的效果 IF('SUBJECT' = '语文', score, 0)作为条件，即对所有SUBJECT='语文'的记录的SCORE字段进行SUM(), MAX(), MIN(), AVG()操作，如果SCORE没有值则默认为0。 ","date":"2021-06-08","objectID":"/row2column/:1:3","series":null,"tags":["MySQL"],"title":"MySQL 行转列，列转行","uri":"/row2column/#2-使用if"},{"categories":["MySQL"],"content":" 3. 利用SUM(IF())生成列 + WITH ROLLUP 生成汇总行，并利用IFNULL将汇总行标题显示为Total SELECT IFNULL(USER_ID, 'total') AS USER_ID, SUM(IF(`SUBJECT` = '语文', SCORE, 0)) AS 语文, SUM(IF(`SUBJECT` = '数学', SCORE, 0)) AS 数学, SUM(IF(`SUBJECT` = '英语', SCORE, 0)) AS 英语, SUM(IF(`SUBJECT` = '政治', SCORE, 0)) AS 政治, SUM(IF(`SUBJECT` = 'total', SCORE, 0)) AS total FROM( SELECT USER_ID, IFNULL(`SUBJECT`, 'total') AS `SUBJECT`, SUM(SCORE) AS SCORE FROM TB_SCORE GROUP BY USER_ID, `SUBJECT` WITH ROLLUP HAVING USER_ID IS NOT NULL )AS A GROUP BY USER_ID WITH ROLLUP; 运行结果： USER_ID 语文 数学 英语 政治 total 1001 90 92 80 0 262 1002 88 90 75 0 253 1003 70 85 90 82 327 total 248 267 245 82 842 ","date":"2021-06-08","objectID":"/row2column/:1:4","series":null,"tags":["MySQL"],"title":"MySQL 行转列，列转行","uri":"/row2column/#3-利用sumif生成列--with-rollup-生成汇总行并利用ifnull将汇总行标题显示为total"},{"categories":["MySQL"],"content":" 4. 利用SUM(IF())生成列 + UNION生成汇总行，并利用IFNULL将汇总行标题显示为TOTAL SELECT IFNULL(USER_ID, 'TOTAL') AS USER_ID, SUM(IF(`SUBJECT` = '语文', SCORE, 0)) AS 语文, SUM(IF(`SUBJECT` = '数学', SCORE, 0)) AS 数学, SUM(IF(`SUBJECT` = '英语', SCORE, 0)) AS 英语, SUM(IF(`SUBJECT` = '政治', SCORE, 0)) AS 政治, SUM(IF(`SUBJECT` = 'total', SCORE, 0)) AS TOTAL FROM( SELECT USER_ID, IFNULL(`SUBJECT`, 'total') AS `SUBJECT`, SUM(SCORE) AS SCORE FROM TB_SCORE GROUP BY USER_ID, `SUBJECT` WITH ROLLUP HAVING USER_ID IS NOT NULL )AS A GROUP BY USER_ID WITH ROLLUP; 运行结果： USER_ID 语文 数学 英语 政治 TOTAL 1001 90 92 80 0 262 1002 88 90 75 0 253 1003 70 85 90 82 327 TOTAL 248 267 245 82 842 ","date":"2021-06-08","objectID":"/row2column/:1:5","series":null,"tags":["MySQL"],"title":"MySQL 行转列，列转行","uri":"/row2column/#4-利用sumif生成列--union生成汇总行并利用ifnull将汇总行标题显示为total"},{"categories":["MySQL"],"content":" 5. 利用SUM(IF())生成列，直接生成结果，不再利用子查询 SELECT IFNULL(USER_ID, 'TOTAL') AS USER_ID, SUM(IF(`SUBJECT` = '语文', SCORE, 0)) AS 语文, SUM(IF(`SUBJECT` = '数学', SCORE, 0)) AS 数学, SUM(IF(`SUBJECT` = '英语', SCORE, 0)) AS 英语, SUM(IF(`SUBJECT` = '政治', SCORE, 0)) AS 政治, SUM(SCORE) AS TOTAL FROM TB_SCORE GROUP BY USER_ID WITH ROLLUP; 运行结果： USER_ID 语文 数学 英语 政治 TOTAL 1001 90 92 80 0 262 1002 88 90 75 0 253 1003 70 85 90 82 327 TOTAL 248 267 245 82 842 ","date":"2021-06-08","objectID":"/row2column/:1:6","series":null,"tags":["MySQL"],"title":"MySQL 行转列，列转行","uri":"/row2column/#5-利用sumif生成列直接生成结果不再利用子查询"},{"categories":["MySQL"],"content":" 6. 合并字段显示：利用GROUP_CONCAT() SELECT USER_ID, GROUP_CONCAT( `SUBJECT`, \":\", SCORE ) AS 成绩 FROM TB_SCORE GROUP BY USER_ID 运行结果： USER_ID 成绩 1001 语文:90,数学:92,英语:80 1002 语文:88,数学:90,英语:75 1003 语文:70,数学:85,英语:90,政治:82 GROUP_CONCAT()，手册上说明：该函数返回带有来自一个组的连接的非NULL值的字符串结果。 比较抽象，难以理解。通俗点理解，其实是这样的：GROUP_CONCAT()会计算哪些行属于同一组，将属于同一组的列显示出来。要返回哪些列，由函数参数(就是字段名)决定。分组必须有个标准，就是根据GROUP BY指定的列进行分组。 ","date":"2021-06-08","objectID":"/row2column/:1:7","series":null,"tags":["MySQL"],"title":"MySQL 行转列，列转行","uri":"/row2column/#6-合并字段显示利用group_concat"},{"categories":["MySQL"],"content":" 列转行","date":"2021-06-08","objectID":"/row2column/:2:0","series":null,"tags":["MySQL"],"title":"MySQL 行转列，列转行","uri":"/row2column/#列转行"},{"categories":["MySQL"],"content":" 测试数据建表： DROP TABLE IF EXISTS TB_SCORE; CREATE TABLE TB_SCORE ( ID INT ( 11 ) NOT NULL auto_increment, USER_ID VARCHAR ( 20 ) NOT NULL COMMENT '用户id', CN_SCORE DOUBLE COMMENT '语文成绩', MATH_SCORE DOUBLE COMMENT '数学成绩', EN_SCORE DOUBLE COMMENT '英语成绩', PO_SCORE DOUBLE COMMENT '政治成绩', PRIMARY KEY ( ID ) ) ENGINE = INNODB DEFAULT CHARSET = utf8; 插入数据： INSERT INTO TB_SCORE ( USER_ID, CN_SCORE, MATH_SCORE, EN_SCORE, PO_SCORE ) VALUES ( '1001', 90, 92, 80, 0 ); INSERT INTO TB_SCORE ( USER_ID, CN_SCORE, MATH_SCORE, EN_SCORE, PO_SCORE ) VALUES ( '1002', 88, 90, 75.5, 0 ); INSERT INTO TB_SCORE ( USER_ID, CN_SCORE, MATH_SCORE, EN_SCORE, PO_SCORE ) VALUES ( '1003', 70, 85, 90, 82 ); 查询表中数据： SELECT * FROM TB_SCORE; ID USER_ID CN_SCORE MATH_SCORE EN_SCORE PO_SCORE 1 1001 90 92 80 0 2 1002 88 90 75.5 0 3 1003 70 85 90 82 ","date":"2021-06-08","objectID":"/row2column/:2:1","series":null,"tags":["MySQL"],"title":"MySQL 行转列，列转行","uri":"/row2column/#测试数据-1"},{"categories":["MySQL"],"content":" UNION ALL本质是将 USER_ID 的每个科目分数分散成一条记录显示出来。 SELECT USER_ID, '语文' AS COURSE, CN_SCORE AS SCORE FROM TB_SCORE UNION ALL SELECT USER_ID, '数学' AS COURSE, MATH_SCORE AS SCORE FROM TB_SCORE UNION ALL SELECT USER_ID, '英语' AS COURSE, EN_SCORE AS SCORE FROM TB_SCORE UNION ALL SELECT USER_ID, '政治' AS COURSE, PO_SCORE AS SCORE FROM TB_SCORE ORDER BY USER_ID 运行结果： USER_ID COURSE SCORE 1001 语文 90 1001 数学 92 1001 英语 80 1001 政治 0 1002 语文 88 1002 数学 90 1002 英语 75.5 1002 政治 0 1003 语文 70 1003 数学 85 1003 英语 90 1003 政治 82 注意 附：UNION 与 UNION ALL 的区别： 对重复结果的处理：UNION 会去掉重复记录，UNION ALL 不会； 对排序的处理：UNION 会排序，UNION ALL 只是简单的将两个结果集合合并； 效率方面的区别：因为 UNION 会做去重和排序，因此效率比 UNION ALL 慢很多。 ","date":"2021-06-08","objectID":"/row2column/:2:2","series":null,"tags":["MySQL"],"title":"MySQL 行转列，列转行","uri":"/row2column/#union-all"},{"categories":["Linux"],"content":"Linux 常用命令","date":"2021-03-13","objectID":"/linuxinstruction/","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/"},{"categories":["Linux"],"content":" cd cd （change directory：英文释义是改变目录）切换目录 cd ../ ;跳到上级目录 cd /opt ;不管现在到那直接跳到指定的opt文件夹中 cd ~ ;切换当前用户的家目录。root用户的家目录就是root目录。 ","date":"2021-03-13","objectID":"/linuxinstruction/:1:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#cd"},{"categories":["Linux"],"content":" pwd pwd （print working directory：显示当前工作目录的绝对路径） pwd 显示当前的绝对路劲 ","date":"2021-03-13","objectID":"/linuxinstruction/:2:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#pwd"},{"categories":["Linux"],"content":" ls ls （ls：list的缩写，查看列表）查看当前目录下的所有文件夹（ls 只列出文件名或目录名） ls -a ;显示所有文件夹,隐藏文件也显示出来 ls -R ;连同子目录一起列出来 ","date":"2021-03-13","objectID":"/linuxinstruction/:3:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#ls"},{"categories":["Linux"],"content":" ll ll （ll：list的缩写，查看列表详情）查看当前目录下的所有详细信息和文件夹（ll 结果是详细,有时间,是否可读写等信息） ll -a ;显示所有文件,隐藏文件也显示出来 ll -R ;连同子目录内容一起列出来 ll -h ;友好展示详情信息,可以看大小 ll -al ;即能显示隐藏文件又能显示详细列表。 ","date":"2021-03-13","objectID":"/linuxinstruction/:4:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#ll"},{"categories":["Linux"],"content":" touch touch （touch：创建文件）创建文件 touch test.txt ;创建test.txt文件 touch /opt/java/test.java ;在指定目录创建test.java文件 ","date":"2021-03-13","objectID":"/linuxinstruction/:5:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#touch"},{"categories":["Linux"],"content":" mkdir mkdir （mkdir：创建目录） 创建目录 mkdir 文件夹名称 ;在此目录创建文件夹 mkdir /opt/java/jdk ;在指定目录创建文件夹 ","date":"2021-03-13","objectID":"/linuxinstruction/:6:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#mkdir"},{"categories":["Linux"],"content":" cat cat （concatenate：显示或把多个文本文件连接起来）查看文件命令（可以快捷查看当前文件的内容）（不能快速定位到最后一页） cat lj.log ;快捷查看文件命令 Ctrl + c ;暂停显示文件 Ctrl + d ;退出查看文件命令 ","date":"2021-03-13","objectID":"/linuxinstruction/:7:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#cat"},{"categories":["Linux"],"content":" more more （more：更多的意思）分页查看文件命令（不能快速定位到最后一页） 回车：向下n行，需要定义，默认为1行。 空格键：向下滚动一屏或Ctrl+F B：返回上一层或Ctrl+B q：退出more ","date":"2021-03-13","objectID":"/linuxinstruction/:8:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#more"},{"categories":["Linux"],"content":" less less （lese：较少的意思）分页查看文件命令（可以快速定位到最后一页） less -m 显示类似于more命令的百分比。 less -N 显示每行的行号。(大写的N) 两参数一起使用如：less -mN 文件名，如此可分页并显示行号。 空格键：前下一页或page down。 回车：向下一行。 b：后退一页 或 page up。 q：退出。 d：前进半页。 u：后退半页 ","date":"2021-03-13","objectID":"/linuxinstruction/:9:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#less"},{"categories":["Linux"],"content":" tail tail（尾巴） 查看文件命令（看最后多少行） tail -10 ;文件名 看最后10行 ","date":"2021-03-13","objectID":"/linuxinstruction/:10:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#tail"},{"categories":["Linux"],"content":" cp cp（copy单词缩写，复制功能） cp /opt/java/java.log /opt/logs/ ;把java.log 复制到/opt/logs/下 cp /opt/java/java.log /opt/logs/aaa.log ;把java.log 复制到/opt/logs/下并且改名为aaa.log cp -r /opt/java /opt/logs ;把文件夹及内容复制到logs文件中 ","date":"2021-03-13","objectID":"/linuxinstruction/:11:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#cp"},{"categories":["Linux"],"content":" mv mv（move单词缩写，移动功能，该文件名称功能） mv /opt/java/java.log /opt/mysql/ ;移动文件到mysql目录下 mv java.log mysql.log ;把java.log改名为mysql.log ","date":"2021-03-13","objectID":"/linuxinstruction/:12:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#mv"},{"categories":["Linux"],"content":" rm rm（remove：移除的意思）删除文件，或文件夹 -f或--force 强制删除文件或目录。删除文件不包括文件夹的文件 -r或-R或--recursive 递归处理，将指定目录下的所有文件及子目录一并删除。 -rf 强制删除文件夹及内容 rm 文件名 ;安全删除命令 （yes删除 no取消） rm -rf 强制删除文件夹及内容 rm -rf * 删除当前目录下的所有内容。 rm -rf /* 删除Linux系统根目录下所有的内容。系统将完蛋。 ","date":"2021-03-13","objectID":"/linuxinstruction/:13:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#rm"},{"categories":["Linux"],"content":" find find （find：找到的意思）查找指定文件或目录 * 表示0~多个任意字符。 find -name 文件名;按照指定名称查找在当前目录下查找文件 find / -name 文件名按照指定名称全局查找文件 find -name '*文件名' ;任意前缀加上文件名在当前目录下查找文件 find / -name '*文件名*' ;全局进行模糊查询带文件名的文件 ","date":"2021-03-13","objectID":"/linuxinstruction/:14:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#find"},{"categories":["Linux"],"content":" vi vi （VIsual：视觉）文本编辑器 类似win的记事本 （操作类似于地下的vim命令，看底下vim 的操作） ","date":"2021-03-13","objectID":"/linuxinstruction/:15:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#vi"},{"categories":["Linux"],"content":" vim vim （VI IMproved：改进版视觉）改进版文本编辑器 （不管是文件查看还是文件编辑 按 Shift + 上或者下可以上下移动查看视角） 输入”vim 文件名” 打开文件，刚刚时是”一般模式”。 一般模式：可以浏览文件内容，可以进行文本快捷操作。如单行复制，多行复制，单行删除，多行删除，（退出）等。 插入模式：可以编辑文件内容。 底行模式：可以进行强制退出操作,不保存 :q! 可以进行保存并退出操作 :wq 按下”i”或”a”或”o”键，从”一般模式”，进入”插入模式（编辑模式）”。 在编辑模式下按”Esc” 即可到一般模式 在一般模式下按”:”，冒号进入底行模式。 在一般模式下的快捷键 dd ;删除一整行 X ;向前删除 等同于windowns系统中的删除键 x ;向后删除和大写x相反方向 Ctrl + f ;向后看一页 Ctrl + b ;向前看一页 u ;撤销上一步操作 /word ;向下查找word关键字 输入:n查找下一个,N查找上一个（不管是哪个查找都是全局查找 只不过n的方向相反） ?log ;向上查找log关键字 输入:n查找上一个,N查找下一个 :1,90s/redis/Redis/g ;把1-90行的redis替换为Redis。语法n1,n2s/原关键字/新关键字/g，n1代表其实行,n2代表结尾行,g是必须要的 :0 ;光标移动到第一行 :$ ;光标移动到最后一行 :300 ;光标移动到300行,输入多少数字移动到多少行 :w ;保存 :w! ;强制保存 :q ;退出 :q! ;强制退出 5dd ;删除后面5行,打一个参数为自己填写 5x ;删除此光标后面5个字符 d1G ;删除此光标之前的所有 d0 ;从光标当前位置删除到此行的第一个位置 yy ;复制 p ;在光标的下面进行粘贴 P ;在光标的上门进行粘贴 ","date":"2021-03-13","objectID":"/linuxinstruction/:16:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#vim"},{"categories":["Linux"],"content":" | | 管道命令（把多个命令组合起来使用） 管道命令的语法：命令1 | 命令2 | 命令3。 ","date":"2021-03-13","objectID":"/linuxinstruction/:17:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#heading"},{"categories":["Linux"],"content":" grep grep （grep ：正则表达式）正则表达式，用于字符串的搜索工作(模糊查询)。不懂可以先过 单独使用： grep String test.java ；在test.java文件中查找String的位置，返回整行 一般此命令不会单独使用下面列几个常用的命令（地下通过管道命令组合起来使用） ps aux|grep java ；查找带java关键字的进程 ll |grep java ；查找带java关键字的文件夹及文件 ","date":"2021-03-13","objectID":"/linuxinstruction/:18:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#grep"},{"categories":["Linux"],"content":" yum install -y lrzsz yum install -y lrzsz 命令（实现win到Linux文件互相简单上传文件） #（实际上就是在Linux系统中下载了一个插件）下了了此安装包后就可以实现win系统到linux之间拉文件拉文件 #等待下载完了就可以输入： rz 从win系统中选择文件上传到Linux系统中 sz 文件名 选择Linux系统的文件复制到win系统中 ","date":"2021-03-13","objectID":"/linuxinstruction/:19:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#yum-install--y-lrzsz"},{"categories":["Linux"],"content":" tar tar （解压 压缩 命令） 常用的组合命令： -z 是否需要用gzip压缩。 -c 建立一个压缩文件的参数指令(create) –压缩 -x 解开一个压缩文件的参数指令(extract) –解压 -v 压缩的过程中显示文件(verbose) -f 使用档名，在f之后要立即接档中(file) 常用解压参数组合：zxvf 常用压缩参数组合：zcvf 解压命令： tar -zxvf redis-3.2.8.tar.gz ；解压到当前文件夹 tar -zxvf redis-3.2.8.tar.gz -C /opt/java/ ；解压到指定目录 压缩命令：（注意 语法有点反了，我反正每次都搞反） tar -zcvf redis-3.2.8.tar.gz redis-3.2.8/ ;语法 tar -zcvf 压缩后的名称 要压缩的文件 tar -zcvf 压缩后的文件（可指定目录） 要压缩的文件（可指定目录） ","date":"2021-03-13","objectID":"/linuxinstruction/:20:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#tar"},{"categories":["Linux"],"content":" ps ps （process status：进程状态，类似于windows的任务管理器） 常用组合：ps -ef 标准的格式查看系统进程 ps -aux BSD格式查看系统进程 ps -aux|grep redis BSD格式查看进程名称带有redis的系统进程（常用技巧） //显示进程的一些属性,需要了解（ps aux） USER //用户名 PID //进程ID号,用来杀死进程的 %CPU //进程占用的CPU的百分比 %MEM //占用内存的的百分比 VSZ //该进程使用的虚拟內存量（KB） RSS //该进程占用的固定內存量（KB） STAT //进程的状态 START //该进程被触发启动时间 TIME //该进程实际使用CPU运行的时间 ","date":"2021-03-13","objectID":"/linuxinstruction/:21:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#ps"},{"categories":["Linux"],"content":" clear clear 清屏命令。（强迫症患者使用） kill 命令用来中止一个进程。（要配合ps命令使用，配合pid关闭进程） （ps类似于打开任务管理器，kill类似于关闭进程） kill -5 进程的PID ;推荐,和平关闭进程 kill -9 PID ;不推荐,强制杀死进程 ","date":"2021-03-13","objectID":"/linuxinstruction/:22:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#clear"},{"categories":["Linux"],"content":" ifconfig ifconfig命令 用于查看和更改网络接口的地址和参数，包括IP地址、网络掩码、广播地址，使用权限是超级用户。（一般是用来查看的，很少更改） 如果此命令输入无效，先输入yum -y install net-tools ifconfig ","date":"2021-03-13","objectID":"/linuxinstruction/:23:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#ifconfig"},{"categories":["Linux"],"content":" ping ping （用于检测与目标的连通性）语法：ping ip地址 测试： 1、在Windows操作系统中cmdipconfig，查看本机IP地址： 2、再到LInux系统中输入 ping ip地址 （公司电脑，我就不暴露Ip了,没图片 自己去试） 按Ctrl + C 可以停止测试。 ","date":"2021-03-13","objectID":"/linuxinstruction/:24:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#ping"},{"categories":["Linux"],"content":" free free 命令 （显示系统内存） #显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。 -b 以Byte显示内存使用情况 -k 以kb为单位显示内存使用情况 -m 以mb为单位显示内存使用情况 -g 以gb为单位显示内存使用情况 -s\u003c间隔秒数\u003e 持续显示内存 -t 显示内存使用总合 ","date":"2021-03-13","objectID":"/linuxinstruction/:25:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#free"},{"categories":["Linux"],"content":" top top 命令 #显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等 -c 显示完整的进程命令 -s 保密模式 -p \u003c进程号\u003e 指定进程显示 -n \u003c次数\u003e循环显示次数 ","date":"2021-03-13","objectID":"/linuxinstruction/:26:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#top"},{"categories":["Linux"],"content":" netstat netstat 命令 #Linux netstat命令用于显示网络状态。 #利用netstat指令可让你得知整个Linux系统的网络情况。 #语法： netstat [-acCeFghilMnNoprstuvVwx][-A\u003c网络类型\u003e][--ip] ","date":"2021-03-13","objectID":"/linuxinstruction/:27:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#netstat"},{"categories":["Linux"],"content":" file file （可查看文件类型） file 文件名 ","date":"2021-03-13","objectID":"/linuxinstruction/:28:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#file"},{"categories":["Linux"],"content":" 重启linux Linux centos 重启命令：reboot ","date":"2021-03-13","objectID":"/linuxinstruction/:29:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#重启linux"},{"categories":["Linux"],"content":" 关机linux Linux centos 关机命令：halt ","date":"2021-03-13","objectID":"/linuxinstruction/:30:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#关机linux"},{"categories":["Linux"],"content":" 同步时间命令 ntpdate ntp1.aliyun.com ","date":"2021-03-13","objectID":"/linuxinstruction/:31:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#同步时间命令"},{"categories":["Linux"],"content":" 更改为北京时间命令 rm -rf /etc/localtime ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime ","date":"2021-03-13","objectID":"/linuxinstruction/:32:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#更改为北京时间命令"},{"categories":["Linux"],"content":" 查看时间命令： date ","date":"2021-03-13","objectID":"/linuxinstruction/:33:0","series":null,"tags":["Linux"],"title":"Linux 常用命令","uri":"/linuxinstruction/#查看时间命令"},{"categories":["Linux"],"content":"vi/vim 的基本用法","date":"2021-02-03","objectID":"/viim/","series":null,"tags":["Linux"],"title":"vi/vim 的基本用法","uri":"/viim/"},{"categories":["Linux"],"content":" vi/vim 的基本用法","date":"2021-02-03","objectID":"/viim/:0:0","series":null,"tags":["Linux"],"title":"vi/vim 的基本用法","uri":"/viim/#vivim-的基本用法"},{"categories":["Linux"],"content":" 简介所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。 但是目前我们使用比较多的是 vim 编辑器。 vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。 vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。 ","date":"2021-02-03","objectID":"/viim/:1:0","series":null,"tags":["Linux"],"title":"vi/vim 的基本用法","uri":"/viim/#简介"},{"categories":["Linux"],"content":" 第一部分一般模式可用的光标移动、复制粘贴、搜索替换等 移动光标的方法 说明 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！ [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用) [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用) [Ctrl] + [d] 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 n 那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 (常用) $ 或功能键[End] 移动到这一行的最后面字符处(常用) H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 G 移动到这个档案的最后一行(常用) nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) gg 移动到这个档案的第一行，相当于 1G 啊！ (常用) n n 为数字。光标向下移动 n 行(常用) 搜索替换 说明 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！ :n1,n2s/word1/word2/g n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用) :1,$s/word1/word2/g 或 :%s/word1/word2/g 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用) :1,$s/word1/word2/gc 或 :%s/word1/word2/gc 从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用) 删除、复制与贴上 说明 x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用) nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 dd 删除游标所在的那一整行(常用) ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用) d1G 删除光标所在到第一行的所有数据 dG 删除光标所在到最后一行的所有数据 d$ 删除游标所在处，到该行的最后一个字符 d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 yy 复制游标所在的那一行(常用) nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用) y1G 复制游标所在行到第一行的所有数据 yG 复制游标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p, P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用) J 将光标所在行与下一行的数据结合成同一行 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。(常用) [Ctrl]+r 重做上一个动作。(常用) 这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！ . 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用) ","date":"2021-02-03","objectID":"/viim/:2:0","series":null,"tags":["Linux"],"title":"vi/vim 的基本用法","uri":"/viim/#第一部分"},{"categories":["Linux"],"content":" 第二部分：一般模式切换到编辑模式的可用的按钮说明 指令行的储存、离开等指令 说明 :w 将编辑的数据写入硬盘档案中(常用) :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi (常用) :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ :wq 储存后离开，若为 :wq! 则为强制储存后离开 (常用) ZZ 这是大写的 Z 喔！如果修改过，保存当前文件，然后退出！效果等同于(保存并退出) ZQ 不保存，强制退出。效果等同于 :q!。 :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！ vim 环境的变更 说明 :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！ 特别注意，在 vi/vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。 举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。 ","date":"2021-02-03","objectID":"/viim/:3:0","series":null,"tags":["Linux"],"title":"vi/vim 的基本用法","uri":"/viim/#第二部分一般模式切换到编辑模式的可用的按钮说明"},{"categories":["Linux"],"content":" 批量添加注释方法一 ：块选择模式 批量注释： Ctrl + v 进入块选择模式，然后移动光标选中你要注释的行，再按大写的 I 进入行首插入模式输入注释符号如 // 或 #，输入完毕之后，按两下 ESC，Vim 会自动将你选中的所有行首都加上注释，保存退出完成注释。 取消注释： Ctrl + v 进入块选择模式，选中你要删除的行首的注释符号，注意 // 要选中两个，选好之后按 d 即可删除注释，ESC 保存退出。 方法二：替换命令 批量注释。 使用下面命令在指定的行首添加注释。 使用名命令格式： :起始行号,结束行号s/^/注释符/g（注意冒号）。 取消注释： 使用名命令格式： :起始行号,结束行号s/^注释符//g（注意冒号）。 例子： 在 10 - 20 行添加 // 注释 :10,20s#^#//#g 在 10 - 20 行删除 // 注释 :10,20s#^//##g 10 - 20 行添加 # 注释 :10,20s/^/#/g 在 10 - 20 行删除 # 注释 :10,20s/#//g ","date":"2021-02-03","objectID":"/viim/:4:0","series":null,"tags":["Linux"],"title":"vi/vim 的基本用法","uri":"/viim/#批量添加注释"},{"categories":["面试"],"content":" JVM 篇","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:0:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#jvm-篇"},{"categories":["面试"],"content":" 1. 什么情况下会发生栈内存溢出在 HotSpot 虚拟机中是不区分虚拟机栈和本地方法栈，栈是线程私有的，它的生命周期与线程相同，每个方法在执行的时候都会创建一个栈帧，用来存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈桢在虚拟机栈中入栈到出栈的过程。本地方法栈与虚拟机栈相似，区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 栈内存溢出是指线程请求的栈深度大于虚拟机所允许的最大深度，则将抛出 StackOverflowError 异常（StackOverflowError 不属于 OOM 异常）。最有可能的原因就是方法递归产生的这种结果。 另一个可能是引用了大的变量，在拓展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常（这个属于内存溢出）。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:1:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#1-什么情况下会发生栈内存溢出"},{"categories":["面试"],"content":" 2. JVM 的内存结构，Eden 和 Survivor 比例Java 虚拟机在执行 Java 程序的过程中把它所管理的内存划分为若干个不同的数 据区域，这些区域都有各自的用途。 程序计数器。当前线程执行的字节码的行号指示器，是线程私有的。也是唯一一个不会发生内存溢出的区域。 Java 虚拟机栈。也是线程私有的，描述的是 Java 方法执行的内存模型，线程请求的栈深度大于虚拟机所允许的最大深度，则将抛出StackOverflowError 异常。 本地方法栈。与虚拟机栈相似，区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 Java 堆。是 Java 虚拟机中管理的内存中最大的一块，所有线程共享区域，唯一目的就是存放对象实例。所有的对象实例以及数组都要在堆上分配内存。Java 堆也是垃圾回收器管理的主要区域，也被称为 gc 堆，收集器基本都采用分代收集算法，Java 堆中还可以细分为：新生代和老年代。 方法区。所有线程共享区域，用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。很多人也愿意称之为“永久代”。 运行时常量池。是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。 直接内存。并不是虚拟机运行时数据区的一部分。例如 NIO，它可以使用 Native 函数直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样避免了在 Java 堆和 Native 堆中来回复制数据，提高了性能。 JVM 中要对堆进行分代，分代的理由是优化 GC 性能，很多对象都是朝生夕死的，如果分代的话，我们把新创建的对象放到某一地方，当 GC 的时候先把这块存“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。 HotSpot JVM 把新生代分为了三部分：1个 Eden 区和 2 个Survivor 区（分别叫 from 和 to）。默认比例为 8 ：1。一般情况下，新创建的对象都会被分配到Eden 区(一些大对象特殊处理),这些对象经过第一次 Minor GC后，如果仍然存活，将会被移到 Survivor 区。对象在 Survivor 区中每熬过一次Minor GC，年龄就会增加 1 岁，当它的年龄增加到一定程度时，就会被移动到年老代中。 因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制]算法不会产生内存碎片。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:2:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#2-jvm-的内存结构eden-和-survivor-比例"},{"categories":["面试"],"content":" 3. JVM 内存为什么要分成新生代、老年代和持久代。新生代中为什么要分 Eden 和 Survivor。堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中。给堆内存分代是为了提高对象内存分配和垃圾回收的效率。试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾收集，而每次回收都要遍历所有的对象，遍历这些对象所花费的时间代价是巨大的，会严重影响我们的 GC 效率，这简直太可怕了。 有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放在老年代中，静态属性、类信息等存放在永久代中，新生代中的对象存活时间短，只需要在新生代区域中频繁进行 GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收，永久代中回收效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾收集算法。分代收集大大提升了收集效率，这些都是内存分代带来的好处。 HotSpot 将新生代划分为三块，一块较大的 Eden 空间和两块较小的 Survivor 空间，默认比例为 8：1：1。划分的目的是因为 HotSpot 采用复制算法来回收新生代，设置这个比例是为了充分利用内存空间，减少浪费。新生成的对象在Eden 区分配（大对象除外，大对象直接进入老年代），当 Eden 区没有足够的空间进行分配时，虚拟机将发起一次 Minor GC。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:3:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#3-jvm-内存为什么要分成新生代老年代和持久代新生代中为什么要分-eden-和-survivor"},{"categories":["面试"],"content":" 4. JVM 中一次完整的 GC 流程是什么样子的，对象如何晋升到老年代，说说你知道的几种主要的 JVM 参数。GC 开始时，对象只会存在于 Eden 区和 From Survivor 区，To Survivor 区是空的（作为保留区域）。GC 进行时，Eden 区中所有存活的对象都会被复制到 To Survivor 区，而在 From Survivor 区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阀值（默认为 15，新生代中的对象每熬过一轮垃圾回收，年龄值就加 1，GC 分代年龄存储在对象的 header 中）的对象会被移到老年代中，没有达到阀值的对象会被复制到 To Survivor 区。接着清空 Eden 区和 From Survivor 区，新生代中存活的对象都在 To Survivor 区。接着， From Survivor 区和 To Survivor 区会交换它们的角色，也就是新的 To Survivor 区就是上次 GC 清空的 From Survivor 区，新的 From Survivor 区就是上次 GC 的 To Survivor 区，总之，不管怎样都会保证 To Survivor 区在一轮 GC 后是空的。GC时当 To Survivor 区没有足够的空间存放上一次新生代收集下来的存活对象时，需要依赖老年代进行分配担保，将这些对象存放在老年代中。 对象晋升老年代有三种可能： 当对象达到成年，经历过 15 次 GC（默认是 15，可配置），对象就晋升到老年代了。 大的对象会直接在老年代创建。 新生代的 Survivor 空间内存不足时，对象可能直接晋升到老年代。 JVM参数： -Xms：初始堆大小 -Xmx：堆最大内存 -Xss：栈内存 -XX:PermSize 初始永久代内存 -XX:MaxPermSize 最大永久带内存 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:4:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#4-jvm-中一次完整的-gc-流程是什么样子的对象如何晋升到老年代说说你知道的几种主要的-jvm-参数"},{"categories":["面试"],"content":" 5. 你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms 和 G1，包括原理，流程，优缺点。常见的垃圾收集器主要有以下四种： 串行收集器（Serial、ParNew 收集器）：简单高效，但它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束，中间停顿时间长。 并行收集器（Parallel Scavenge 收集器）：吞吐量优先，主要关注点在于精确控制吞吐量，即减少 GC 停顿时间，但收集次数变多。 CMS：以获取最短回收停顿时间为目标的收集器，并发标记-清除，主要步骤有，初始标记，并发标记，重新标记和并发清除。其中，整个过程耗时最长的并发标记和并发清除过程收集器线程都可以和用户线程一起工作，CMS 收集器的内存回收过程始于用户线程一起并发执行的。重新标记是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。但缺点有，CMS 收集器对 CPU 资源非常敏感，并且无法处理浮动垃圾。 G1：可预测停顿的收集器，并发标记-整理，主要步骤分为，初始标记，并发标记，最终标记和筛选回收。G1 把内存“化整为零”，并且可以分代收集。注意：CMS 是清除，所以会存在很多的内存碎片。G1 是整理，所以碎片空间较小。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:5:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#5-你知道哪几种垃圾收集器各自的优缺点重点讲下-cms-和-g1包括原理流程优缺点"},{"categories":["面试"],"content":" 6. 垃圾回收算法的实现原理。垃圾收集算法主要分为以下三种： 标记-清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 复制算法：将可用内存按容量分为两块（Eden 和 Survivor 空间），每次只使用一块，当这一块内存用完后，就将还活着的对象复制到另外一块上面，然后再把已使用过内存空间一次清理掉。 标记-整理算法：标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界外的内存。 需要注意的是，“标记-清除”算法存在两个不足： 一个是效率问题，标记和清除两个过程的效率都不高； 另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一个垃圾收集动作。作为对比，复制算法每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:6:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#6-垃圾回收算法的实现原理"},{"categories":["面试"],"content":" 7. 当出现了内存溢出，怎么排错。 首先控制台查看错误日志。 然后使用 jdk 自带的 VisualVM 来查看系统的堆栈日志（也可以用 jmap 查看堆转储快照）。 定位出内存溢出的空间：堆，栈还是永久代（jdk8 后没有永久代的溢出了）。 如果是堆内存溢出，看是否创建了超大的对象。 如果是栈内存溢出，看是否创建了超大的对象，或者产生了死循环，或者递归调用。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:7:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#7-当出现了内存溢出怎么排错"},{"categories":["面试"],"content":" 8. JVM 内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。 内存屏障是一种 CPU 指令，用于控制特定条件下的重排序和内存可见性问题。Java 编译器也会根据内存屏障的规则禁止重排序。 happen-before 用来阐述操作之间的内存可见性。在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在 happens-before 关系。具体原则如下： 程序次序法则：线程中的每个动作 A 都 happens-before 于该线程中的每一个动作 B，其中，在程序中，所有的动作 B 都能出现在 A 之后。 监视器锁法则：对一个监视器锁的解锁 happens-before 于每一个后续对同一监视器锁的加锁。 volatile 变量法则：对 volatile 域的写入操作 happens-before 于每一个后续对同一个域的读写操作。 线程启动法则：在一个线程里，对 Thread.start 的调用会 happens-before 于每个启动线程的动作。 线程终结法则：线程中的任何动作都 happens-before 于其他线程检测到这个线程已经终结、或者从 Thread.join 调用中成功返回，或Thread.isAlive 返回 false。 中断法则：一个线程调用另一个线程的 interrupt happens-before 于被中断的线程发现中断。 终结法则：一个对象的构造函数的结束 happens-before 于这个对象 finalizer 的开始。 传递性：如果 A happens-before 于 B，且 B happens-before 于 C，则 A happens-before 于 C。 主内存是指所有线程共享的内存空间。 工作内存是指每个线程特有的内存空间。工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写在主内存中的变量。 参考链接：JVM 内存模型、指令重排、内存屏障概念解析 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:8:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#8-jvm-内存模型的相关知识了解多少比如重排序内存屏障happen-before主内存工作内存等"},{"categories":["面试"],"content":" 9. 讲讲 JAVA 的反射机制Java 反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用。我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:9:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#9-讲讲-java-的反射机制"},{"categories":["面试"],"content":" 10. 你们线上应用的 JVM 参数有哪些。 -Xms512m //初始堆大小 -Xmx1024m //最大堆大小 -XX:PermSize=640m //设置持久代初始值 -XX:MaxPermSize=1280m //设置持久代最大值 -XX:NewSize=64m //设置年轻代初始值 -XX:MaxNewSize=256m //设置年轻代最大值 -verbose:gc //表示输出虚拟机中 GC 的详细情况 -XX:+PrintGCDetails //日志输出形式 -XX:+PrintGCTimeStamps //日志输出形式 在默认情况下，JVM 初始分配的堆内存大小是物理内存的 1/64，最大分配的堆内存大小是物理内存的 1/4。 默认空余堆内存小于 40%时，JVM 就会增大堆直到-Xmx 的最大限制；空余堆内存大于 70%时，JVM 会减少堆直到-Xms 的最小限制。 因此服务器一般设置-Xms、-Xmx 相等，来避免每次 GC 后调整堆的大小。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:10:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#10-你们线上应用的-jvm-参数有哪些"},{"categories":["面试"],"content":" 11. g1 和 cms 区别，吞吐量优先和响应优先的垃圾收集器选择。CMS 是基于“标记-清除”实现的，主要步骤是初始标记，并发标记，重新标记和并发清除。 G1 是基于“标记-整理”实现的，主要步骤是初始标记，并发标记，最终标记和筛选回收。 CMS 的缺点是对 CPU 的要求比较高。 G1 的缺点是将内存划分了多块，所以对内存段的大小有很大的要求。 CMS 是清除，所有会有很多的内存碎片。 G1 是整理，所有碎片空间较小。 G1 和 CMS 都是响应优先，他们的目的都是尽量控制 stop the world 的时间。 G1 和 CMS 的 Full GC 都是单线程 mark sweep compact 算法，直到 JDK10 才优化成并行的。 CMS 目前只用于老年代，而 G1 是将整个 Java 堆划分为多个大小不等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔的了，他们都是一部分 Region（不需要连续）的集合。 吞吐量优先的话可以选择并行垃圾收集器，Parallel Scavenge 收集器。吞吐量是指 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:11:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#11-g1-和-cms-区别吞吐量优先和响应优先的垃圾收集器选择"},{"categories":["面试"],"content":" 12. 怎么打印线程栈信息。 StackTraceElement[] elements = (new Throwable()).getStackTrace(); StringBuffer buf = new StringBuffer(); for(int i=0; i\u003celements.length; i++) { buf.append(\"\\n\" + elements[i].getClassName()// 打印线程当前执行的详细类名 + \".\" + elements[i].getMethodName()// 打印线程当前方法名 + \"(\" + elements[i].getFileName()// 打印线程当前执行类的文件名 + \":\" + elements[i].getLineNumber()// 打印线程当前执行的行数 + \")\"); } ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:12:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#12-怎么打印线程栈信息"},{"categories":["面试"],"content":" 13. 请解释如下 jvm 参数的含义。 -server：服务器模式 -Xms512m：初始堆空间 -Xmx512m：最大堆空间 -Xss1024K：栈空间 -XX:PermSize=256m：初始永久代空间 -XX:MaxPermSize=512m ：最大永久代空间 -XX:MaxTenuringThreshold=20：在新生代对象存活次数（经历 Minor GC 的次数）后依旧存活，就会晋升到老年代。 -XX:CMSInitiatingOccupancyFraction=80 ：设定 CMS 在对老年代内存占用率达到 80%的时候开始 GC(因为 CMS 会有浮动垃圾,所以一般都较早启动 GC)。 -XX:+UseCMSInitiatingOccupancyOnly：只是用设定的回收阈值(上面指定的 80%),如果不指定,JVM 仅在第一次使用设定值,后续则自动调整. ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:13:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#13-请解释如下-jvm-参数的含义"},{"categories":["面试"],"content":" 14. Java 中对象创建的几种方式。创建对象的方式有四种： 用 new 关键字创建。 User user = new User(); 调用对象的 clone 方法。 利用反射，调用 Class 类的或者是 Constructor 类的 newInstance() 方法。 User user = User.class.newInstance(); // 或者是 Constructor\u003cUser\u003e constructor = User.class.getContructor(); User user = constructor.newInstance(); 用反序列化，调用 ObjectInputStream 类的 readObject() 方法。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:14:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#14-java-中对象创建的几种方式"},{"categories":["面试"],"content":" 15. Java中的对象一定在堆上分配内存吗？前面我们说过，Java 堆中主要保存了对象实例，但是，随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。 其实，在编译期间，JIT 会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。 如果 JIT 经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。 参考文章：深入理解 Java 中的逃逸分析 和 对象并不一定都是在堆上分配内存的 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:15:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#15-java中的对象一定在堆上分配内存吗"},{"categories":["面试"],"content":" 16. 运行时数据中哪些区域是线程共享的，那些是独享的？在 JVM 运行时内存区域中，程序计数器、虚拟机栈和本地方法栈是线程独享的。而 Java 堆、方法区是线程共享的。但是值得注意的是，Java 堆其实还为每一个 线程单独分配了一块 TLAB 空间（本地线程分配缓冲），这部分空间在分配时是线程独享的，在使用时是线程共享的。（TLAB 介绍） 创建对象时，内存分配过程如何保证线程安全性？有两种解决方案： 对分配内存空间的动作做同步处理，采用 CAS 机制，配合失败重试的方式保证更新操作的线程安全性。 每个线程在 Java 堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块\"私有\"内存中分配，当这部分区域用完之后，再分配新的\"私有\"内存。这个本地线程分配缓冲就叫做 TLAB。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:16:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#16-运行时数据中哪些区域是线程共享的那些是独享的"},{"categories":["面试"],"content":" 17. Java 中数组是存储在堆上还是栈上。在 Java 中，数组同样是一个对象，所以对象在内存中如何存放同样适用于数组； 所以，数组的实例是保存在堆中，而数组的引用是保存在栈上的。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:17:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#17-java-中数组是存储在堆上还是栈上"},{"categories":["面试"],"content":" 18. Java 对象创建的过程是怎么样的？对于一个普通的 Java 对象的创建，大致过程如下： 虚拟机遇到 new 指令，到常量池定位到这个类的符号引用。 检查符号引用代表的类是否被加载、解析、初始化过 ，如果没有的话，则执行相应的类加载过程。 虚拟机为对象分配内存。 根据 Java 内存是否规整，分别通过“指针碰撞”或“空闲列表”来分配。 虚拟机将分配到的内存空间都初始化为零值。 虚拟机对对象进行必要的设置。 执行方法，成员变量进行初始化。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:18:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#18-java-对象创建的过程是怎么样的"},{"categories":["面试"],"content":" 19. 怎么获取堆和栈的 dump 文件。Java Dump，Java 虚拟机的运行时快照。将 Java 虚拟机运行时的状态和信息保存到文件。 可以使用在服务器上使用 jmap 命令来获取堆 dump，使用 jstack 命令来获取线程的调用栈 dump。 参考文章：Java 命令学习系列（二）——Jstack 和 Java 命令学习系列（三）——Jmap ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:19:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#19-怎么获取堆和栈的-dump-文件"},{"categories":["面试"],"content":" 20. Minor GC 和 Full GC 的触发条件。Minor GC 触发条件：当 Eden 区满时，触发 Minor GC。 Full GC 触发条件： 调用 System.gc 时，系统建议执行 Full GC，但是不必然执行。 老年代空间不足。 方法区空间不足。 concurrent mode failure，当执行 CMS GC 过程时（“标记-清除”，存在内存碎片），同时有对象要放入老年代，而此时老年代空间不足造成的（有时候“空间不足”是 CMS GC 时当前的浮动垃圾过多导致暂时性的空间不足触发 Full GC）。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:20:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#20-minor-gc-和-full-gc-的触发条件"},{"categories":["面试"],"content":" 21. 在 Java 语言中，可以作为 GC Roots 的对象有什么。可作为 GC Roots 的对象包括以下几种： 虚拟机栈（栈桢中的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。 获取 GC Roots 最主要的部分在解决如果快速找到 JVM 栈的栈桢的局部变量表中的局部变量所引用的对象。大致思路是 JVM 采用了 OopMap 这个数据结构记录了 GC Roots，GC 的标记开始的时候，直接用 OopMap 就可以获得 GC Roots。OopMap 记录了特定时刻栈上（内存）和寄存器（CPU）的哪些位置是引用，通过这些引用就可以找到堆中的对象，这些对象就是 GC Roots，而不需要一个一个的去判断某个内存位置的值是不是引用。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:21:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#21-在-java-语言中可以作为-gc-roots-的对象有什么"},{"categories":["面试"],"content":" 22. 类加载过程。Java 虚拟机中类加载的全过程包括：加载、验证、准备、解析和初始化这 5 个阶段。 加载 在加载阶段，虚拟机主要完成以下 3 个事情。 通过一个类的全限定名来获取定义此类的二进制字节流。（这一步骤就是通过类加载器来实现的） 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各类数据的访问入口。 验证 验证时连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 文件格式验证：验证字节流是否符合 Class 文件格式的规范，包括文件头部的魔数因子、class 文件主次版本号、class 文件的 MD5 指纹等。 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范。简单来说就是验证 Java 语法的正确性。 字节码验证：主要验证程序的控制流程，如循环、分支等。 准备 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中分配。需要注意的是，这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。 解析 解析阶段是虚拟机在常量池内寻找类、接口、字段和方法的符号引用，并且将这些符号引用替换为直接引用的过程。符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。 初始化 初始化阶段是类的加载过程的最后一个阶段，该阶段主要做一件事情就是执行()，该方法会为所有的静态变量赋予正确的值。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:22:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#22-类加载过程"},{"categories":["面试"],"content":" 23. Java 内存泄漏的场景。内存泄漏是指，一个不再被程序使用的对象或变量还在内存中占有存储空间。虽然 Java 拥有 GC，但还是会出现内存泄漏。举个例子。 // 首先，要明白，GC 它回收的是不可到达的对象，但是，在 static 的集合类中，引用可以到达，但是却有可能对象已经不用了 // 首先定义一个静态变量 public static ArrayList\u003cObject\u003e list = new ArrayList\u003cObject\u003e(); public void stackOverExam(Object object){ // 当非静态变量被 static 变量持有引用的时候，容易发生内存泄露，因为 object 是一直被 list 引用着的 list.add(object); //这里设置为 null 并没有达到释放 object 引用对应对象的效果，毕竟 list 还是持有引用 object = null; } 通过上面的代码可以看到，由于 static 指向的对象是不能被垃圾回收器回收的，所以，间接的 object 也是无法被回收的，当业务对象很大而且很多的时候，便有了内存泄漏的风险。所以，可以总结如下规则： 当全局的静态变量持有局部变量（或者说，大范围的变量持有小范围变量而且小范围变量消耗内存表达、数目变多时），程序便有内存泄漏的风险。一般来说，类似的例子还有，单例模式中的对象，模块之间的调用（后面这个例子提到）等。 先举一个单例对象的例子。由于单例的静态特征使得其生命周期和应用的生命周期一样长，如果一个对象已经不再被使用，而单例对象还会持有该对象的引用，就会使得该对象不能被正常回收，从而导致了内存泄漏。 public class Singleton { private static Singleton singleton; private List\u003cInteger\u003e list; private Singleton(List\u003cInteger\u003e list) { this.list = list; } public Singleton getInstance(List\u003cInteger\u003e list) { if (singleton == null) { singleton = new Singleton(list); } return singleton; } } 另外再举一个模块调用的例子，现在有两个类 A 和 B，其中 B 的默认构造函数上是需要一个 A 的实例作为参数的，这就让 A 和 B 产生了依赖。 a = new A(); b = new B(a); a = null; a 是对象 A 的引用，b 是对象 B 的引用，对象 B 同时还依赖对象 A，那么这个时候就可以认为对象 B 是可以到达对象 A 的。当 A 对象的引用 a 置为 null 后， a 不再指向对象 A 的引用了，按理说对象 A 可以 GC 了。但是因为 B 依赖着 A，所以这个时候，A 对象是不可能被回收了，造成了内存泄漏。这个时候可以用弱引用 WeakReference 来代替对象 B，就可以解决了这个问题。如下所示。 A a = new A(); WeakReference wr = new WeakReference(a); a = null; ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:23:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#23-java-内存泄漏的场景"},{"categories":["面试"],"content":" 24. jdk1.8 的虚拟机中内存模型变化。在 jdk1.8 中变化最大的是取消了永久区 Perm，而是用元数据空间 Metaspace 来进行替换。需要注意的是，元空间占用的内存不是虚拟机内部的，而是本地内存空间，当然也不是堆内存。这个变化的理由如下： 在 jdk1.8 之前的 HotSpot 实现中，类的元数据如方法数据、方法信息（字节码、栈和变量的大小）、运行时常量池等保存在永久代。32 位默认永久代为 64M，64 位默认 85M，可以通过参数-XX：MaxPermSize 进行设置，一旦类的元数据超过了永久代的大小，就会抛出 OOM 异常了。 对永久代的调优过程很困难，因为永久代的大小很难确定，其中涉及到很多因素，如类的总数、常量池大小和方法数量等，而且永久代的护具可能会随着每一次 Full GC 而发生移动。 在 jdk1.8 中，类的元数据保存在本地内存中，元空间的最大可分配空间就是系统可用内存空间。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:24:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#24-jdk18-的虚拟机中内存模型变化"},{"categories":["面试"],"content":" 25. 频繁 GC 的原因。 人为因素，在代码中调用了 System.gc()方法。 内存原因，设置的堆大小比较小，可以提高堆的空间，比如说提高最小堆空间-Xms 和最大堆空间-Xmx的大小，当然，最好是针对内存的 DUMP 文件进行分析。 框架问题，有些框架内部会调用 gc 方法。 其他原因，构建的对象实例化十分频繁并且释放对象较为频繁时，也会引起频繁 gc。 如果线上系统突然产生的运行缓慢问题，如果该问题导致线上系统不可用，那么首先需要做的就是，导出 jstack 和内存信息，然后重启系统，尽快保证系统的可用性。这种情况可能的原因主要有两种： 代码中某个位置读取数据量较大，导致系统内存耗尽，从而导致 Full GC 次数过多，系统缓慢； 代码中有比较耗 CPU 的操作，导致 CPU 过高，系统运行缓慢。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:25:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#25-频繁-gc-的原因"},{"categories":["面试"],"content":" 26. 高并发时，JVM 调优。优化虚拟机堆的空间大小，根据实际物理内存的大小进行比例分配，并根据程序调整好新生代和老年代的比例。并且，堆不进行自动扩展。然后使用ParNew（并发）+CMS 进行垃圾回收，在多线程高并发的情况下，表现很好。 调优的目标是： 将转移到老年代的对象数量降低到最小 。 减少 Full GC 的执行时间。 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:26:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#26-高并发时jvm-调优"},{"categories":["面试"],"content":" 27. System.gc()和 Runtime.gc()的区别。 java.lang.System.gc()只是 java.lang.Runtime.getRuntime().gc()的简写，两者的行为没有任何不同。 System.gc()和 runtime.gc()用于建议 jvm 进行垃圾回收，但是否立即回收还是延迟回收由 Java 虚拟机决定。 另外，当我们调用 System.gc()的时候，其实并不会马上进行垃圾回收，甚至不一定会执行垃圾回收。 以上主要参考来源为：《深入理解 Java 虚拟机：JVM 高级特征与最佳实践》 ","date":"2021-01-13","objectID":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:27:0","series":null,"tags":["Java","JVM","面试"],"title":"JVM面试问题总结","uri":"/jvm%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/#27-systemgc和-runtimegc的区别"},{"categories":["算法"],"content":"Java-选择排序","date":"2020-07-25","objectID":"/java-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","series":null,"tags":["Java"],"title":"Java-选择排序","uri":"/java-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"categories":["算法"],"content":" Java-选择排序（时间复杂度为O(n²) ）","date":"2020-07-25","objectID":"/java-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/:0:0","series":null,"tags":["Java"],"title":"Java-选择排序","uri":"/java-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/#java-选择排序时间复杂度为on-"},{"categories":["算法"],"content":" 简要说明首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 ","date":"2020-07-25","objectID":"/java-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/:1:0","series":null,"tags":["Java"],"title":"Java-选择排序","uri":"/java-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/#简要说明"},{"categories":["算法"],"content":" 动图展示 ","date":"2020-07-25","objectID":"/java-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/:2:0","series":null,"tags":["Java"],"title":"Java-选择排序","uri":"/java-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/#动图展示"},{"categories":["算法"],"content":" 代码展示 public class SelectionSort { public static void main(String[] args) { int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48}; selectionSort(arr); System.out.println(Arrays.toString(arr)); } /** * 选择排序：前一个与后面逐个进行比较，将最小的放到前面 * @param arr 待排序的数组 */ public static void selectionSort(int[] arr) { for (int i = 0; i \u003c arr.length - 1; i++) { // 最小值的索引，默认是前面元素 int minIndex = i; // 最小值，默认是前面元素 int minValue = arr[i]; // 与后面的元素进行比较 for (int j = i + 1; j \u003c arr.length; j++) { // 比较大小，得到最小的值、下标 if (minValue \u003e arr[j]){ minIndex = j; minValue = arr[j]; } } // 如果最小值不是默认的元素则交换 if (minIndex != i){ arr[minIndex] = arr[i]; arr[i] = minValue; } } } } ","date":"2020-07-25","objectID":"/java-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/:3:0","series":null,"tags":["Java"],"title":"Java-选择排序","uri":"/java-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/#代码展示"},{"categories":["算法"],"content":"Java版快速排序(待优化)","date":"2020-07-23","objectID":"/java-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","series":null,"tags":["Java"],"title":"Java-快速排序","uri":"/java-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"categories":["算法"],"content":" Java-快速排序（时间复杂度：O(N*logN) ）","date":"2020-07-23","objectID":"/java-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:0:0","series":null,"tags":["Java"],"title":"Java-快速排序","uri":"/java-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#java-快速排序时间复杂度onlogn-"},{"categories":["算法"],"content":" 简要说明快速排序由C. A. R. Hoare在1960年提出。 它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序。 它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。 最坏运行情况是 O(n²) ","date":"2020-07-23","objectID":"/java-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:1:0","series":null,"tags":["Java"],"title":"Java-快速排序","uri":"/java-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#简要说明"},{"categories":["算法"],"content":" 动图展示 ","date":"2020-07-23","objectID":"/java-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:2:0","series":null,"tags":["Java"],"title":"Java-快速排序","uri":"/java-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#动图展示"},{"categories":["算法"],"content":" 代码展示 public class QuickSort { public static void main(String[] args) { int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48}; quickSort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); } /* * 传入 3 个参数 * 1, 数组 arr * 2, 排序开始的位置, 左边 left * 3, 排序结束的位置, 右边 right */ public static void quickSort(int[] arr, int left, int right) { // 进行判断, 如果左边索引比右边索引大, 不合法, 直接用 return 结束这个方法 if (left \u003e right) { return; } // 定义变量保存基准数 int base = arr[left]; // 定义变量 i, 指向最左边 int i = left; // 定义变量 j, 指向最右边 int j = right; // 当 i 和 j 不相遇的时候, 在循环中进行检索 while (i != j) { // 先由 j 从右往左检索比基准数小的, 如果检索到比基准数小的, 就停下 // 如果检索到比基准数大的或者相等的, 就继续检索 while (arr[j] \u003e= base \u0026\u0026 i \u003c j) { j--; // j从右往左移动 } // i 从左往右检索 while (arr[i] \u003c= base \u0026\u0026 i \u003c j) { i++; // i 从左往右移动 } // 代码走到这里, i 和 j 都停下了, 然后交换 i 和 j 的位置的元素 int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } /* * 如果上面 while 循环的条件不成立, 会跳出循环, 往下执行 * 如果这个条件不成立, 说明 i 和 j 相遇了 * 如果 i 和 j 相遇了, 就交换基准数这个元素和相遇位置的元素 * 把相遇位置的元素赋值给基准数这个位置的元素 */ arr[left] = arr[i]; // 把基准数赋值给相遇位置的元素 arr[i] = base; // 基准数在这里就归位了, 左边的数字比他小, 右边的数字比他大 // 然后排基准数的左边 quickSort(arr, left, i - 1); // 然后排基准数的右边 quickSort(arr, j + 1, right); } } ","date":"2020-07-23","objectID":"/java-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/:3:0","series":null,"tags":["Java"],"title":"Java-快速排序","uri":"/java-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/#代码展示"},{"categories":["算法"],"content":"Java-插入排序","date":"2020-07-22","objectID":"/java-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","series":null,"tags":["Java"],"title":"Java-插入排序","uri":"/java-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"categories":["算法"],"content":" Java-插入排序（复杂度为O(n2) ）","date":"2020-07-22","objectID":"/java-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/:0:0","series":null,"tags":["Java"],"title":"Java-插入排序","uri":"/java-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#java-插入排序复杂度为on2-"},{"categories":["算法"],"content":" 简要说明插入排序是一种最简单的排序方法，它的基本思想是从数组中逐个元素作为插入元素，和前面的进行比较，小的即插入前面。 ","date":"2020-07-22","objectID":"/java-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/:1:0","series":null,"tags":["Java"],"title":"Java-插入排序","uri":"/java-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#简要说明"},{"categories":["算法"],"content":" 动图展示 ","date":"2020-07-22","objectID":"/java-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/:2:0","series":null,"tags":["Java"],"title":"Java-插入排序","uri":"/java-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#动图展示"},{"categories":["算法"],"content":" 代码展示 public class InsertSort { public static void main(String[] args) { int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48}; insertSort(arr); System.out.println(Arrays.toString(arr)); } /** * 插入排序：从数组中逐个元素作为插入元素，和前面的进行比较，小的即插入前面。 * 前面的已经是排完序的了。 * * @param arr 待排序的数组 */ public static void insertSort(int[] arr) { for (int i = 1; i \u003c arr.length; i++) { // 插入的下标，默认是前一位 int insertIndex = i - 1; // 插入的值 int insertValue = arr[i]; // 插入的值和前面的进行比较，小则插入。排序：从小到大，改大于号则排序为从大到小 while (insertIndex \u003e= 0 \u0026\u0026 insertValue \u003c arr[insertIndex]){ // 交换，将小的放前面，保证前面是已经排序后的 arr[insertIndex + 1] = arr[insertIndex]; insertIndex --; } if(insertIndex != i - 1) { arr[insertIndex + 1] = insertValue; } System.out.println(\"第\" + i + \"轮：\" + Arrays.toString(arr)); } } } ","date":"2020-07-22","objectID":"/java-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/:3:0","series":null,"tags":["Java"],"title":"Java-插入排序","uri":"/java-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/#代码展示"},{"categories":["算法"],"content":"Java版冒泡排序(待优化)","date":"2020-07-21","objectID":"/java-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","series":null,"tags":["Java"],"title":"Java-冒泡排序","uri":"/java-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"categories":["算法"],"content":" Java-冒泡排序","date":"2020-07-21","objectID":"/java-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/:0:0","series":null,"tags":["Java"],"title":"Java-冒泡排序","uri":"/java-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/#java-冒泡排序"},{"categories":["算法"],"content":" 简要说明依次比较两个相邻的元素 ","date":"2020-07-21","objectID":"/java-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/:1:0","series":null,"tags":["Java"],"title":"Java-冒泡排序","uri":"/java-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/#简要说明"},{"categories":["算法"],"content":" 动图展示 ","date":"2020-07-21","objectID":"/java-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/:2:0","series":null,"tags":["Java"],"title":"Java-冒泡排序","uri":"/java-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/#动图展示"},{"categories":["算法"],"content":" 代码展示 public class BubbleSort { public static void main(String[] args) { // TODO Auto-generated method stub int[] arr = {3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48}; for (int i = 0; i \u003c arr.length - 1; i++) { for (int j = 0; j \u003c arr.length - i - 1; j++) { if (arr[j] \u003e arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } System.out.println(Arrays.toString(arr)); } } ","date":"2020-07-21","objectID":"/java-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/:3:0","series":null,"tags":["Java"],"title":"Java-冒泡排序","uri":"/java-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/#代码展示"},{"categories":["LeetCode"],"content":"1486.数组异或操作","date":"2020-04-19","objectID":"/1486_xoroperation/","series":null,"tags":["LeetCode"],"title":"1486.数组异或操作","uri":"/1486_xoroperation/"},{"categories":["LeetCode"],"content":" 题目描述给定两个整数，$ \\tt{n} $和$ \\tt{start} $。 数组$ \\tt{nums} $定义为：$ \\tt{nums[i] = start + 2 * i} $（下标从$ \\tt{0} $开始）且$ \\tt{n == nums.length} $。 请返回$ \\tt{nums} $中所有元素按位异或（XOR）后得到的结果。 示例 1： 输入：n = 5, start = 0 输出：8 解释：数组 nums 为 [0, 2, 4, 6, 8], 其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8。 \"^\" 为按位或 XOR 运算符 示例 2： 输入：n = 4, start = 3 输出：8 解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8 示例 3： 输入：n = 1, start = 7 输出：7 示例 4： 输入：n = 10, start = 5 输出：2 提示： $ \\tt{1 \u003c= n \u003c= 1000} $ $ \\tt{0 \u003c= start \u003c= 1000} $ $ \\tt{n == nums.length} $ ","date":"2020-04-19","objectID":"/1486_xoroperation/:1:0","series":null,"tags":["LeetCode"],"title":"1486.数组异或操作","uri":"/1486_xoroperation/#题目描述"},{"categories":["LeetCode"],"content":" 题解","date":"2020-04-19","objectID":"/1486_xoroperation/:2:0","series":null,"tags":["LeetCode"],"title":"1486.数组异或操作","uri":"/1486_xoroperation/#题解"},{"categories":["LeetCode"],"content":" 前言统计$ \\tt{[2, n]} $中质数的数量是一个很常见的题目，也有很多巧妙高效的做法，接下来的部分只会讲述一些常见的做法，更多的拓展内容读者可以自行搜索补充，也欢迎在评论区与大家分享交流。 ","date":"2020-04-19","objectID":"/1486_xoroperation/:3:0","series":null,"tags":["LeetCode"],"title":"1486.数组异或操作","uri":"/1486_xoroperation/#前言"},{"categories":["LeetCode"],"content":" 方法一：模拟思路： 按照题意模拟即可： 初始化$ \\tt{ans = 0} $ 遍历区间$ \\tt{[0, n - 1]} $中的每一个整数$ \\tt{i} $，令$ \\tt{ans} $与每一个$ \\tt{start + 2 \\times i} $做异或运算 最终返回$ \\tt{ans} $，即我们需要的答案 代码展示： Java： class Solution { public int xorOperation(int n, int start) { int ans = 0; for (int i = 0; i \u003c n; ++i) { ans ^= (start + i * 2); } return ans; } } Python： class Solution: def xorOperation(self, n: int, start: int) -\u003e int: ans = 0 for i in range(n): ans ^= (start + i * 2) return ans C： bool isPrime(int x) { for (int i = 2; i * i \u003c= x; ++i) { if (x % i == 0) { return false; } } return true; } int countPrimes(int n) { int ans = 0; for (int i = 2; i \u003c n; ++i) { ans += isPrime(i); } return ans; } JavaScript： var xorOperation = function(n, start) { let ans = 0; for (let i = 0; i \u003c n; ++i) { ans ^= (start + i * 2); } return ans; }; 复杂度分析： 时间复杂度：$ \\rm{O(n)} $ 。这里用一重循环对$ \\tt{n} $个数字进行异或。 空间复杂度：$ \\rm{O(1)} $。这里只是用了常量级别的辅助空间。 ","date":"2020-04-19","objectID":"/1486_xoroperation/:4:0","series":null,"tags":["LeetCode"],"title":"1486.数组异或操作","uri":"/1486_xoroperation/#方法一模拟"},{"categories":["LeetCode"],"content":" 方法二：数学记$ \\tt{\\oplus} $为异或操作，异或操作满足以下性质： $ \\tt{x \\oplus x = 0} $ $ \\tt{x \\oplus y = y \\oplus x} $（交换律） $ \\tt{(x \\oplus y) \\oplus z = x \\oplus (y \\oplus z)} $（结合律） $ \\tt{x \\oplus y \\oplus y = x} $（自反性） $ \\tt{\\forall i \\in Z } $，有$ \\tt{4i \\oplus (4i + 1) \\oplus (4i + 2) \\oplus (4i + 3) = 0} $ 在本题中，我们要计算 $$ \\tt{start \\oplus (start + 2i) \\oplus (start + 4i) \\oplus \\cdots \\oplus (start + 2(n - 1)) } $$ 观察公式可以知道，这些数的奇偶性相同，因此它们的二进制表示中的最低位均为$ \\tt{1} $，或者均为$ \\tt{0} $。于是我们可以把参与运算的数的二进制位的最低位提取出来单独处理，当且仅当$ \\tt{start} $为奇数，且$ \\tt{n} $也为奇数时，结果的二进制位的最低位才为$ \\tt{1} $。 此时我们可以将公式转化为： $$ \\tt{(s \\oplus (s + 1) \\oplus (s + 2) \\oplus \\cdots \\oplus (s + n - 1)) \\times + \\ e} $$ 其中$ \\tt{s = \\lfloor \\frac{start}{2} \\rfloor} $，$ \\tt{e} $表示运算结果的最低位。即我们单独处理最低位，而舍去最低位后的数列恰成为一串连续的整数。 这样我们可以描述一个函数$ \\tt{sumXor(x)} $，表示$ \\tt{0 \\oplus 1 \\oplus 2 \\oplus \\cdots \\oplus x} $。利用异或运算的{% span red, 性质5 %}，我们可以将计算该函数的复杂度降低到$ \\rm{O(1)} $，因为以$ \\tt{4i} $为开头的连续四个整数异或的结果为$ \\tt{0} $，所以$ \\tt{sumXor(x)} $可以被表示为： $$ \\tt{sumXor(x) = \\begin{cases} \\tt x, \u0026\u0026 \\tt x=4k, k \\in Z \\\\ \\tt (x-1) \\oplus x, \u0026\u0026 \\tt x =4k+1, k \\in Z \\\\ \\tt (x-2) \\oplus (x-1) \\oplus x, \u0026\u0026 \\tt x=4k+2,k \\in Z \\\\ \\tt (x-3) \\oplus (x-2) \\oplus (x-1) \\oplus x, \u0026\u0026 \\tt x=4k+3,k \\in Z \\end{cases} } $$ 我么可以进一步化简改式： $$ \\tt{sumXor(x) = \\begin{cases} \\tt x, \u0026\u0026 \\tt x=4k, k \\in Z \\\\ \\tt 1, \u0026\u0026 \\tt x =4k+1, k \\in Z \\\\ \\tt x+1, \u0026\u0026 \\tt x=4k+2,k \\in Z \\\\ \\tt 0, \u0026\u0026 \\tt x=4k+3,k \\in Z \\end{cases} } $$ 这样最后的结果即可表示为$ \\tt{(sumXor(s-1) \\oplus sumXor(s+n-1)) \\times2 + e} $ Java： class Solution { public int xorOperation(int n, int start) { int s = start \u003e\u003e 1, e = n \u0026 start \u0026 1; int ret = sumXor(s - 1) ^ sumXor(s + n - 1); return ret \u003c\u003c 1 | e; } public int sumXor(int x) { if (x % 4 == 0) { return x; } if (x % 4 == 1) { return 1; } if (x % 4 == 2) { return x + 1; } return 0; } } C： int sumXor(int x) { if (x % 4 == 0) { return x; } if (x % 4 == 1) { return 1; } if (x % 4 == 2) { return x + 1; } return 0; } int xorOperation(int n, int start) { int s = start \u003e\u003e 1, e = n \u0026 start \u0026 1; int ret = sumXor(s - 1) ^ sumXor(s + n - 1); return ret \u003c\u003c 1 | e; } JavaScript： var xorOperation = function(n, start) { let s = start \u003e\u003e 1, e = n \u0026 start \u0026 1; let ret = sumXor(s - 1) ^ sumXor(s + n - 1); return ret \u003c\u003c 1 | e; }; const sumXor = (x) =\u003e { if (x % 4 === 0) { return x; } if (x % 4 === 1) { return 1; } if (x % 4 === 2) { return x + 1; } return 0; } 复杂度分析： 时间复杂度：$ \\rm{O(1)} $。我们只需要常数的时间计算出结果。 空间复杂度：$ \\rm{O(1)} $。我们只需要常数的空间保存若干变量。 ","date":"2020-04-19","objectID":"/1486_xoroperation/:5:0","series":null,"tags":["LeetCode"],"title":"1486.数组异或操作","uri":"/1486_xoroperation/#方法二数学"},{"categories":["LeetCode"],"content":"1480.一堆数组的动态和","date":"2020-04-18","objectID":"/1480_runningsumof1darray/","series":null,"tags":["LeetCode"],"title":"1480.一堆数组的动态和","uri":"/1480_runningsumof1darray/"},{"categories":["LeetCode"],"content":" 题目描述给你一个数组 nums 。数组「动态和」的计算公式为： $$ \\tt {runningSum[i] = sum(nums[0]…nums[i])} $$ 请返回$ \\tt {nums} $的动态和。 示例 1： 输入：nums = [1,2,3,4] 输出：[1,3,6,10] 解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。 示例 2： 输入：nums = [1,1,1,1,1] 输出：[1,2,3,4,5] 解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。 示例 3： 输入：nums = [3,1,2,10,1] 输出：[3,4,6,16,17] 提示： $ \\tt {1 \u003c= nums.length \u003c= 1000} $ $ \\tt {-10^6 \u003c= nums[i] \u003c= 10^6} $ ","date":"2020-04-18","objectID":"/1480_runningsumof1darray/:1:0","series":null,"tags":["LeetCode"],"title":"1480.一堆数组的动态和","uri":"/1480_runningsumof1darray/#题目描述"},{"categories":["LeetCode"],"content":" 题解通过观察和思考可得到： 最终答案中，第$ \\tt{1} $个值不用变，第$ \\tt{n} $个值是参数中数组第$ \\tt{1} $到第$ \\tt{n} $个值的和 不用新开一个数组，直接在原数组中操作即可 只用一次遍历，要得到第$ \\tt{n} $个值，只需要用第$ \\tt {n-1} $个值加上第$ \\tt{n} $个值即可 代码展示： Java： class Solution { public int[] runningSum(int[] nums) { for (int i = 1; i \u003c nums.length; i++) { nums[i] += nums[i - 1]; } return nums; } } ","date":"2020-04-18","objectID":"/1480_runningsumof1darray/:2:0","series":null,"tags":["LeetCode"],"title":"1480.一堆数组的动态和","uri":"/1480_runningsumof1darray/#题解"},{"categories":["LeetCode"],"content":"804.唯一的摩尔斯密码词","date":"2020-04-17","objectID":"/804_uniquemorsecodewords/","series":null,"tags":["LeetCode"],"title":"804.唯一的摩尔斯密码词","uri":"/804_uniquemorsecodewords/"},{"categories":["LeetCode"],"content":" 题目描述国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串，比如：“a” 对应 “.-\"，“b” 对应 “-…\"，“c” 对应 “-.-.” 等等。 为了方便，将所有26个字母对应的摩尔斯密码表如下： [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] 给定一个单词列表，每个单词可以写成每个字母对应的摩尔斯密码的组合。例如，“cba” 可以写成 “-.-..–…\"，（即 “-.-.” + “.-” + “-…” 字符串的结合）。我们将这样一个连接过程称作单词翻译。 返回我们可以获得所有不同单词翻译的数量。 示例 ： 输入：words = [\"gin\", \"zen\", \"gig\", \"msg\"] 输出：2 解释：各单词翻译如下: \"gin\" -\u003e \"--...-.\" \"zen\" -\u003e \"--...-.\" \"gig\" -\u003e \"--...--.\" \"msg\" -\u003e \"--...--.\" 共有 2 种不同翻译, \"--...-.\" 和 \"--...--.\". 注意： 每个单词表$ \\tt{words} $的长度不会超过$ \\tt{100} $； 每个单词$ \\tt{words[i]} $的长度范围为$ \\tt{[1, 12]} $； 每个单词$ \\tt{words[i]} $只包含小写字母。 ","date":"2020-04-17","objectID":"/804_uniquemorsecodewords/:1:0","series":null,"tags":["LeetCode"],"title":"804.唯一的摩尔斯密码词","uri":"/804_uniquemorsecodewords/#题目描述"},{"categories":["LeetCode"],"content":" 题解","date":"2020-04-17","objectID":"/804_uniquemorsecodewords/:2:0","series":null,"tags":["LeetCode"],"title":"804.唯一的摩尔斯密码词","uri":"/804_uniquemorsecodewords/#题解"},{"categories":["LeetCode"],"content":" 方法一：哈希集合思路及解法 我们将数组$ \\tt{words} $中的每个单词转换为摩尔斯码，并加入哈希集合（HashSet）中，最终的答案即为哈希集合中元素的个数。 代码 Java： class Solution { public int uniqueMorseRepresentations(String[] words) { String[] MORSE = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\", \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\", \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\", \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}; Set\u003cString\u003e seen = new HashSet(); for (String word: words) { StringBuilder code = new StringBuilder(); for (char c: word.toCharArray()) code.append(MORSE[c - 'a']); seen.add(code.toString()); } return seen.size(); } } Python： class Solution(object): def uniqueMorseRepresentations(self, words): MORSE = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\", \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\", \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\", \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] seen = {\"\".join(MORSE[ord(c) - ord('a')] for c in word) for word in words} return len(seen) 复杂度分析： 时间复杂度：$ \\rm{O(S)} $，其中$ \\tt{S} $是数组$ \\tt{words} $中所有单词的长度之和。 空间复杂度：$ \\rm{O(S)} $。 ","date":"2020-04-17","objectID":"/804_uniquemorsecodewords/:3:0","series":null,"tags":["LeetCode"],"title":"804.唯一的摩尔斯密码词","uri":"/804_uniquemorsecodewords/#方法一哈希集合"},{"categories":["LeetCode"],"content":"709.转换成小写字母","date":"2020-04-16","objectID":"/709_tolowercase/","series":null,"tags":["LeetCode"],"title":"709.转换成小写字母","uri":"/709_tolowercase/"},{"categories":["LeetCode"],"content":" 题目描述实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。 示例 1： 输入：\"Hello\" 输出：\"hello\" 示例 2： 输入：\"here\" 输出：\"here\" 示例 3： 输入：\"LOVELY\" 输出：\"lovely\" ","date":"2020-04-16","objectID":"/709_tolowercase/:1:0","series":null,"tags":["LeetCode"],"title":"709.转换成小写字母","uri":"/709_tolowercase/#题目描述"},{"categories":["LeetCode"],"content":" 题解","date":"2020-04-16","objectID":"/709_tolowercase/:2:0","series":null,"tags":["LeetCode"],"title":"709.转换成小写字母","uri":"/709_tolowercase/#题解"},{"categories":["LeetCode"],"content":" 方法一：ASCCII 码思路及解法 通过 $ \\tt{ASCCII} $ 码表操作字符串即可。 Java： class Solution { public String toLowerCase(String str) { if (str == null || str.length() == 0) { return str; } StringBuilder sb = new StringBuilder(); for (char ch : str.toCharArray()) { // a-z：97-122 A-Z：65-90 0-9：48-57 if (ch \u003e= 'A' \u0026\u0026 ch \u003c= 'Z') { sb.append((char)(ch + 32)); } else { sb.append(ch); } } return sb.toString(); } } Java： class Solution { public String toLowerCase(String str) { if (str == null || str.length() == 0) { return str; } char[] ch = str.toCharArray(); for (int i = 0; i \u003c str.length(); i++) { if (ch[i] \u003e= 'A' \u0026\u0026 ch[i] \u003c= 'Z') { ch[i] += 32; } } return String.valueOf(ch); } } ","date":"2020-04-16","objectID":"/709_tolowercase/:3:0","series":null,"tags":["LeetCode"],"title":"709.转换成小写字母","uri":"/709_tolowercase/#方法一asccii-码"},{"categories":["LeetCode"],"content":" 方法二：位运算思路及解法 用位运算的技巧： 大写变小写、小写变大写：字符 ^= 32； 大写变小写、小写变小写：字符 |= 32； 大写变大写、小写变大写：字符 \u0026= 33。 $ \\tt{ASCCII} $码表中大写的$ \\tt{A} $是$ \\tt{65} $，小写的$ \\tt{a} $是$ \\tt{97} $，他们的差是$ \\tt{32} $； $ \\tt{65 | 32} $转为二进制（按 8 位来算）可以得到： $$ \\tt{0100 0001 \\mid 0010 0000 = 0110 0001 = 97 = a} $$ 代码 Java： class Solution { public String toLowerCase(String str) { if (str == null || str.length() == 0) { return str; } char[] ch = str.toCharArray(); for (int i = 0; i \u003c str.length(); i++) { ch[i] |= 32; } return String.valueOf(ch); } } ","date":"2020-04-16","objectID":"/709_tolowercase/:4:0","series":null,"tags":["LeetCode"],"title":"709.转换成小写字母","uri":"/709_tolowercase/#方法二位运算"},{"categories":["LeetCode"],"content":"596.超过5名学生的课","date":"2020-04-15","objectID":"/596_classesmorethanfivestudents/","series":null,"tags":["LeetCode"],"title":"596.超过5名学生的课","uri":"/596_classesmorethanfivestudents/"},{"categories":["LeetCode"],"content":" 题目描述有一个 course 表，有：student (学生) 和 class (课程)。 请列出所有超过或等于5名学生的课。 示例： +---------+------------+ | student | class | +---------+------------+ | A | Math | | B | English | | C | Math | | D | Biology | | E | Math | | F | Computer | | G | Math | | H | Math | | I | Math | +---------+------------+ 应该输出： +---------+ | class | +---------+ | Math | +---------+ 说明： 学生在每个课中不应该被重复计算。 ","date":"2020-04-15","objectID":"/596_classesmorethanfivestudents/:1:0","series":null,"tags":["LeetCode"],"title":"596.超过5名学生的课","uri":"/596_classesmorethanfivestudents/#题目描述"},{"categories":["LeetCode"],"content":" 题解","date":"2020-04-15","objectID":"/596_classesmorethanfivestudents/:2:0","series":null,"tags":["LeetCode"],"title":"596.超过5名学生的课","uri":"/596_classesmorethanfivestudents/#题解"},{"categories":["LeetCode"],"content":" 方法一：使用 GROUP BY 子句和子查询思路： 先统计每门课程的学生数量，再从中选择超过 5 名学生的课程。 使用 GROUP BY 和 COUNT 获得每门课程的学生数量。 SELECT class, COUNT(DISTINCT student) FROM courses GROUP BY class ; 注：使用 DISTINCT 防止在同一门课中学生被重复计算。 输出结果： +----------+----------------+ | class | COUNT(student) | |----------|----------------| | Biology | 1 | | Computer | 1 | | English | 1 | | Math | 6 | +----------+----------------+ 使用上面查询结果的临时表进行子查询，筛选学生数量超过 5 的课程。 SELECT class FROM (SELECT class, COUNT(DISTINCT student) AS num FROM courses GROUP BY class) AS temp_table WHERE num \u003e= 5 ; ","date":"2020-04-15","objectID":"/596_classesmorethanfivestudents/:3:0","series":null,"tags":["LeetCode"],"title":"596.超过5名学生的课","uri":"/596_classesmorethanfivestudents/#方法一使用-group-by-子句和子查询"},{"categories":["LeetCode"],"content":" 方法二：使用 GROUP BY 和 HAVING 条件思路： 在 GROUP BY 子句后使用 HAVING 条件是实现子查询的一种更加简单直接的方法。 所以我们可以将上面的解决方案重写为： SELECT class FROM courses GROUP BY class HAVING COUNT(DISTINCT student) \u003e= 5 ; ","date":"2020-04-15","objectID":"/596_classesmorethanfivestudents/:4:0","series":null,"tags":["LeetCode"],"title":"596.超过5名学生的课","uri":"/596_classesmorethanfivestudents/#方法二使用-group-by-和-having-条件"},{"categories":["LeetCode"],"content":"509.斐波那契数","date":"2020-04-14","objectID":"/509_fibonacci/","series":null,"tags":["LeetCode"],"title":"509.斐波那契数","uri":"/509_fibonacci/"},{"categories":["LeetCode"],"content":" 描述斐波那契数，通常用$ \\tt{F(n)} $表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n \u003e 1 给你$ \\tt{n} $，请计算$ \\tt{F(n)} $。 示例 1： 输入：2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1 示例 2： 输入：3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2 示例 3： 输入：4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示： $ \\tt{0 \\leq n \\leq 30} $ ","date":"2020-04-14","objectID":"/509_fibonacci/:1:0","series":null,"tags":["LeetCode"],"title":"509.斐波那契数","uri":"/509_fibonacci/#描述"},{"categories":["LeetCode"],"content":" 方法一：动态规划斐波那契数的边界条件是$ \\tt{F(0)=0} $ 和$ \\tt{F(1)=1} $。当$ \\tt{n \u003e 1} $时，每一项的和都等于前两项的和，因此有如下递推关系： $$ \\tt{F(n) = F(n-1) + F(n-2)} $$ 由于斐波那契数存在递推关系，因此可以使用动态规划求解。动态规划的状态转移方程即为上述递推关系，边界条件为$ \\tt{F(0)} $和$ \\tt{F(1)} $。 根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是$ \\rm{O(n)} $的实现。由于$ \\tt{F(n)} $只和$ \\tt{F(n-1)} $与$ \\tt{F(n-2)} $有关，因此可以使用「滚动数组思想」把空间复杂度优化成$ \\rm{O(1)} $。如下的代码中给出的就是这种实现。 Java： class Solution { public int fib(int n) { if (n \u003c 2) { return n; } // 递归方式 // return fib(n - 1) + fib(n - 2); // 动态规划（滚动数组） // 斐波那契数列每一项是前两项的和 // 设置三个变量，r 表示当前项，q 和 p 表示前两项 // 注意当前项从斐波那契数列的第三项开始，前两项值分别是 0 和 1，第三项的值则也是 1 int p = 0, q = 0, r = 1; for (int i = 2; i \u003c= n; ++i) { // 数组向前滚动 // 第二项变成第一项 // 第三项变成第二项 // 新的目标项也是第三项，即为前两项之和 p = q; q = r; r = p + q; } return r; } } Python： class Solution: def fib(self, n: int) -\u003e int: if n \u003c 2: return n p, q, r = 0, 0, 1 for i in range(2, n + 1): p, q = q, r r = p + q return r C： int fib(int n) { if (n \u003c 2) { return n; } int p = 0, q = 0, r = 1; for (int i = 2; i \u003c= n; ++i) { p = q; q = r; r = p + q; } return r; } JavaScript： var fib = function(n) { if (n \u003c 2) { return n; } let p = 0, q = 0, r = 1; for (let i = 2; i \u003c= n; i++) { p = q; q = r; r = p + q; } return r; }; ","date":"2020-04-14","objectID":"/509_fibonacci/:2:0","series":null,"tags":["LeetCode"],"title":"509.斐波那契数","uri":"/509_fibonacci/#方法一动态规划"},{"categories":["LeetCode"],"content":" 方法二：矩阵快速幂方法一的时间复杂度是$ \\rm{O(n)} $。使用矩阵快速幂的方法可以降低时间复杂度。 首先我们可以构建这样一个递推关系： $$ \\left [ \\begin{matrix} 1 \u0026 1 \\\\ 1 \u0026 0 \\end{matrix} \\right] \\left [ \\begin{matrix} \\tt{F(n)} \\\\ \\tt{F(n-1)} \\end{matrix} \\right] = \\left [ \\begin{matrix} \\tt{F(n) + F(n-1)} \\\\ \\tt{F(n)} \\end{matrix} \\right] = \\left [ \\begin{matrix} \\tt{F(n+1)} \\\\ \\tt{F(n)} \\end{matrix} \\right] $$ 因此： $$ \\left [ \\begin{matrix} \\tt{F(n+1)} \\\\ \\tt{F(n)} \\end{matrix} \\right] = \\left [ \\begin{matrix} 1 \u0026 1 \\\\ 1 \u0026 0 \\end{matrix} \\right] ^ \\tt{n} \\left [ \\begin{matrix} \\tt{F(1)} \\\\ \\tt{F(0)} \\end{matrix} \\right] $$ 令： $$ M = \\left [ \\begin{matrix} 1 \u0026 1 \\\\ 1 \u0026 0 \\end{matrix} \\right] $$ 因此只要我们能快速计算矩阵$ M $的 $ \\tt{n} $次幂，就可以得到$ \\tt{F(n)} $的值。如果直接求取$ M^\\tt{n} $，时间复杂度是$ \\rm{O(n)} $，可以定义矩阵乘法，然后用快速幂算法来加速这里$ M^\\tt{n} $的求取。 Java： class Solution { public int fib(int n) { if (n \u003c 2) { return n; } int[][] q = {{1, 1}, {1, 0}}; int[][] res = pow(q, n - 1); return res[0][0]; } public int[][] pow(int[][] a, int n) { int[][] ret = {{1, 0}, {0, 1}}; while (n \u003e 0) { if ((n \u0026 1) == 1) { ret = multiply(ret, a); } n \u003e\u003e= 1; a = multiply(a, a); } return ret; } public int[][] multiply(int[][] a, int[][] b) { int[][] c = new int[2][2]; for (int i = 0; i \u003c 2; i++) { for (int j = 0; j \u003c 2; j++) { c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]; } } return c; } } Python： class Solution: def fib(self, n: int) -\u003e int: if n \u003c 2: return n q = [[1, 1], [1, 0]] res = self.matrix_pow(q, n - 1) return res[0][0] def matrix_pow(self, a: List[List[int]], n: int) -\u003e List[List[int]]: ret = [[1, 0], [0, 1]] while n \u003e 0: if n \u0026 1: ret = self.matrix_multiply(ret, a) n \u003e\u003e= 1 a = self.matrix_multiply(a, a) return ret def matrix_multiply(self, a: List[List[int]], b: List[List[int]]) -\u003e List[List[int]]: c = [[0, 0], [0, 0]] for i in range(2): for j in range(2): c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] return c C： struct Matrix { int mat[2][2]; }; struct Matrix matrixMultiply(struct Matrix* a, struct Matrix* b) { struct Matrix c; for (int i = 0; i \u003c 2; i++) { for (int j = 0; j \u003c 2; j++) { c.mat[i][j] = (*a).mat[i][0] * (*b).mat[0][j] + (*a).mat[i][1] * (*b).mat[1][j]; } } return c; } struct Matrix matrixPow(struct Matrix a, int n) { struct Matrix ret; ret.mat[0][0] = ret.mat[1][1] = 1; ret.mat[0][1] = ret.mat[1][0] = 0; while (n \u003e 0) { if (n \u0026 1) { ret = matrixMultiply(\u0026ret, \u0026a); } n \u003e\u003e= 1; a = matrixMultiply(\u0026a, \u0026a); } return ret; } int fib(int n) { if (n \u003c 2) { return n; } struct Matrix q; q.mat[0][0] = q.mat[0][1] = q.mat[1][0] = 1; q.mat[1][1] = 0; struct Matrix res = matrixPow(q, n - 1); return res.mat[0][0]; } JavaScript： var fib = function(n) { if (n \u003c 2) { return n; } const q = [[1, 1], [1, 0]]; const res = pow(q, n - 1); return res[0][0]; }; const pow = (a, n) =\u003e { let ret = [[1, 0], [0, 1]]; while (n \u003e 0) { if ((n \u0026 1) === 1) { ret = multiply(ret, a); } n \u003e\u003e= 1; a = multiply(a, a); } return ret; } const multiply = (a, b) =\u003e { const c = new Array(2).fill(0).map(() =\u003e new Array(2).fill(0)); for (let i = 0; i \u003c 2; i++) { for (let j = 0; j \u003c 2; j++) { c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]; } } return c; } ","date":"2020-04-14","objectID":"/509_fibonacci/:3:0","series":null,"tags":["LeetCode"],"title":"509.斐波那契数","uri":"/509_fibonacci/#方法二矩阵快速幂"},{"categories":["LeetCode"],"content":" 方法三：通项公式斐波那契数$ \\tt{F(n)} $是齐次线性递推，根据递推方程$ \\tt{F(n) = F(n-1) + F(n-2)} $ 可以写出这样的特征方程：$ \\tt{x^2 = x + 1} $ 求得$ \\tt{x_1 = \\frac{ 1 + \\sqrt{5} }{2}} $，$ \\tt{x_2 = \\frac{ 1 - \\sqrt{5} }{2}} $。 设通解为$ \\tt{F(n) = c_1x_1^n} + c_2x_2^n $ 代入初始条件$ \\tt{F(0) = 0} $，$ \\tt{F(1) = 1} $ 得$ \\tt{c_1 = \\frac{1}{\\sqrt{5}}} $， $ \\tt{c_1 = - \\frac{1}{\\sqrt{5}}} $ 因此斐波那契数的通项公式如下： $$ \\tt{F(n)} = \\frac{1}{\\sqrt{5}} \\Bigg[ \\Bigg( \\frac{ 1 + \\sqrt{5} }{2} \\Bigg)^n - \\Bigg( \\frac{ 1 - \\sqrt{5} }{2} \\Bigg)^n \\Bigg] $$ 得到通项公式之后，就可以通过公式直接求解第$ \\tt{n} $项。 Java： class Solution { public int fib(int n) { double sqrt5 = Math.sqrt(5); double fibN = Math.pow((1 + sqrt5) / 2, n) - Math.pow((1 - sqrt5) / 2, n); return (int) Math.round(fibN / sqrt5); } } Python： class Solution: def fib(self, n: int) -\u003e int: sqrt5 = 5**0.5 fibN = ((1 + sqrt5) / 2) ** n - ((1 - sqrt5) / 2) ** n return round(fibN / sqrt5) C： int fib(int n) { double sqrt5 = sqrt(5); double fibN = pow((1 + sqrt5) / 2, n) - pow((1 - sqrt5) / 2, n); return round(fibN / sqrt5); } JavaScript： var fib = function(n) { const sqrt5 = Math.sqrt(5); const fibN = Math.pow((1 + sqrt5) / 2, n) - Math.pow((1 - sqrt5) / 2, n); return Math.round(fibN / sqrt5); }; ","date":"2020-04-14","objectID":"/509_fibonacci/:4:0","series":null,"tags":["LeetCode"],"title":"509.斐波那契数","uri":"/509_fibonacci/#方法三通项公式"},{"categories":["LeetCode"],"content":"342.4的幂","date":"2020-04-13","objectID":"/342_poweroffour/","series":null,"tags":["LeetCode"],"title":"342.4的幂","uri":"/342_poweroffour/"},{"categories":["LeetCode"],"content":" 描述给定一个整数，写一个函数来判断它是否是4的幂次方。如果是，返回true，否则，返回false。 整数n是4的幂次方需满足：存在整数x使得$ \\tt{n == 4^x} $ 示例 1： 输入：n = 16 输出：true 示例 2： 输入：n = 5 输出：false 示例 3： 输入：n = 1 输出：true 说明： ","date":"2020-04-13","objectID":"/342_poweroffour/:1:0","series":null,"tags":["LeetCode"],"title":"342.4的幂","uri":"/342_poweroffour/#描述"},{"categories":["LeetCode"],"content":"283.移动零","date":"2020-04-12","objectID":"/283_movezeroes/","series":null,"tags":["LeetCode"],"title":"283.移动零","uri":"/283_movezeroes/"},{"categories":["LeetCode"],"content":" 题目描述给定一个数组 nums，编写一个函数将所有的 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例 1： 输入：[0, 1, 0, 3, 12] 输出：[1, 3, 12, 0, 0] 说明： 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 ","date":"2020-04-12","objectID":"/283_movezeroes/:1:0","series":null,"tags":["LeetCode"],"title":"283.移动零","uri":"/283_movezeroes/#题目描述"},{"categories":["LeetCode"],"content":" 题解","date":"2020-04-12","objectID":"/283_movezeroes/:2:0","series":null,"tags":["LeetCode"],"title":"283.移动零","uri":"/283_movezeroes/#题解"},{"categories":["LeetCode"],"content":" 方法一：双指针思路及解法 使用双指针，左指针指向当前已经处理好的序列的尾部，右指针只想待处理序列的头部。 右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。 注意到以下性质： 左指针左边均为非零数； 右指针左边到左指针处均为零。 代码 Java： class Solution { public void moveZeroes(int[] nums) { int n = nums.length, left = 0, right = 0; while (right \u003c n) { if (nums[right] != 0) { swap(nums, left, right); left++; } right++; } } public void swap(int[] nums, int left, int right) { int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } } Python： class Solution: def moveZeroes(self, nums: List[int]) -\u003e None: n = len(nums) left = right = 0 while right \u003c n: if nums[right] != 0: nums[left], nums[right] = nums[right], nums[left] left += 1 right += 1 C： void swap(int *a, int *b) { int t = *a; *a = *b, *b = t; } void moveZeroes(int *nums, int numsSize) { int left = 0, right = 0; while (right \u003c numsSize) { if (nums[right]) { swap(nums + left, nums + right); left++; } right++; } } 复杂度分析： 时间复杂度：$ \\rm{O(n)} $，其中$ \\tt{n} $是序列长度。每个位置至多被遍历两次。 空间复杂度：$ \\rm{O(1)} $。只需要常数的空间存放若干变量。 ","date":"2020-04-12","objectID":"/283_movezeroes/:3:0","series":null,"tags":["LeetCode"],"title":"283.移动零","uri":"/283_movezeroes/#方法一双指针"},{"categories":["LeetCode"],"content":"231.2的幂","date":"2020-04-11","objectID":"/231_poweroftwo/","series":null,"tags":["LeetCode"],"title":"231.2的幂","uri":"/231_poweroftwo/"},{"categories":["LeetCode"],"content":" 231.2的幂","date":"2020-04-11","objectID":"/231_poweroftwo/:0:0","series":null,"tags":["LeetCode"],"title":"231.2的幂","uri":"/231_poweroftwo/#2312的幂"},{"categories":["LeetCode"],"content":"204.计算质数","date":"2020-04-10","objectID":"/204_countprimes/","series":null,"tags":["LeetCode"],"title":"204.计算质数","uri":"/204_countprimes/"},{"categories":["LeetCode"],"content":" 题目描述统计所有小于非负整数$ \\tt{n} $的质数的数量 示例 1： 输入：n = 10 输出：4 解释：小于 10 的质数一共有4个，它们是 2，3，5，7 示例 2： 输入：n = 0 输出：0 示例 3： 输入：n = 1 输出：0 提示： $ \\tt{0 \\leq n \\leq 5 \\times 10^6} $ ","date":"2020-04-10","objectID":"/204_countprimes/:1:0","series":null,"tags":["LeetCode"],"title":"204.计算质数","uri":"/204_countprimes/#题目描述"},{"categories":["LeetCode"],"content":" 题解统计$ \\tt{[2, n]} $中质数的数量是一个很常见的题目，也有很多巧妙高效的做法，接下来的部分只会讲述一些常见的做法，更多的拓展内容读者可以自行搜索补充，也欢迎在评论区与大家分享交流。 ","date":"2020-04-10","objectID":"/204_countprimes/:2:0","series":null,"tags":["LeetCode"],"title":"204.计算质数","uri":"/204_countprimes/#题解"},{"categories":["LeetCode"],"content":" 方法一：枚举很直观的思路是我们枚举每个数判断其是不是质数。 考虑质数的定义：在大于$ \\tt{1} $的自然数中，除了$ \\tt{1} $和它本身以外不再有其他因数的自然数。因此对于每个数$ \\tt{x} $，我们可以从小到大枚举$ \\tt{[2, x -1]} $中的每个数 ，判断$ \\tt{y} $是否为$ \\tt{x} $的因数。但这样判断一个数是否为质数的时间复杂度最差情况下会到$ \\rm{O(n)} $，无法通过所有的测试数据。 考虑到如果$ \\tt{y} $是$ \\tt{x} $的因数，那么$ \\tt{\\frac{x}{y}} $也必然是$ \\tt{x} $的因数，因此我们只要校验$ \\tt{y} $或者$ \\tt{\\frac{x}{y}} $即可。而如果我们每次选择校验两者中的较小数，则不难发现较小数一定落在$ \\tt{[2, \\sqrt{x}]} $的区间中，因此我们只要枚举$ \\tt{[2, \\sqrt{x}]} $中的所有数即可，这样单次检查的时间复杂度从$ \\rm{O(n)} $降低至了$ \\rm{O(\\sqrt{x})} $。 代码展示： Java： class Solution { public int countPrimes(int n) { int ans = 0; for (int i = 2; i \u003c n; ++i) { ans += isPrime(i) ? 1 : 0; } return ans; } public boolean isPrime(int x) { for (int i = 2; i * i \u003c= x; ++i) { if (x % i == 0) { return false; } } return true; } } C： bool isPrime(int x) { for (int i = 2; i * i \u003c= x; ++i) { if (x % i == 0) { return false; } } return true; } int countPrimes(int n) { int ans = 0; for (int i = 2; i \u003c n; ++i) { ans += isPrime(i); } return ans; } JavaScript： const isPrime = (x) =\u003e { for (let i = 2; i * i \u003c= x; ++i) { if (x % i == 0) { return false; } } return true; } var countPrimes = function(n) { let ans = 0; for (let i = 2; i \u003c n; ++i) { ans += isPrime(i); } return ans; }; 复杂度分析： 时间复杂度$ \\rm{O(n\\sqrt{n})} $。单个数检查的时间复杂度为$ \\rm{O(\\sqrt{n})} $，一共要检查$ \\rm{O(\\sqrt{n})} $个数，因此总时间复杂为$ \\rm{O(n\\sqrt{n})} $。 空间复杂度$ \\rm{O(1)} $。 ","date":"2020-04-10","objectID":"/204_countprimes/:3:0","series":null,"tags":["LeetCode"],"title":"204.计算质数","uri":"/204_countprimes/#方法一枚举"},{"categories":["LeetCode"],"content":" 方法二：埃氏筛枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。接下来我们介绍一个常见的算法，该算法由希腊数学家厄拉多塞$ (\\tt EratosthenesEratosthenes) $提出，称为厄拉多塞筛法，简称埃氏筛。 我们考虑这样一个事实：如果$ \\tt{x} $是质数，那么大于$ \\tt{x} $的$ \\tt{x} $的倍数 $ \\tt{2x, 3x,\\ldots} $ 一定不是质数，因此我们可以从这里入手。 我们设$ \\tt{isPrime[i]} $表示数$ \\tt{i} $是不是质数，如果是质数则为$ \\tt{x} $，否则为$ \\tt{0} $。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即$ \\tt{0} $，这样在运行结束的时候我们即能知道质数的个数。 这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数$ \\tt{x} $时，倘若它是合数，则它一定是某个小于$ \\tt{x} $的质数$ \\tt{y} $的整数倍，故根据此方法的步骤，我们在遍历到$ \\tt{y} $时，就一定会在此时将$ \\tt{x} $标记为$ \\tt{isPrime[x]=0} $。因此，这种方法也不会将合数标记为质数。 当然这里还可以继续优化，对于一个质数$ \\tt{x} $，如果按上文说的我们从$ \\tt{2x} $开始标记其实是冗余的，应该直接从$ \\tt{x \\cdot x} $开始标记，因为$ \\tt{2x,3x,\\ldots} $这些数一定在$ \\tt{x} $之前就被其他数的倍数标记过了，例如$ \\tt{2} $的所有倍数，$ \\tt{3} $的所有倍数等。 代码展示： Java： class Solution { public int countPrimes(int n) { int[] isPrime = new int[n]; Arrays.fill(isPrime, 1); int ans = 0; for (int i = 2; i \u003c n; ++i) { if (isPrime[i] == 1) { ans += 1; if ((long) i * i \u003c n) { for (int j = i * i; j \u003c n; j += i) { isPrime[j] = 0; } } } } return ans; } } C： int countPrimes(int n) { if (n \u003c 2) { return 0; } int isPrime[n]; memset(isPrime, 0, sizeof(isPrime)); int ans = 0; for (int i = 2; i \u003c n; ++i) { if (!isPrime[i]) { ans += 1; if ((long long)i * i \u003c n) { for (int j = i * i; j \u003c n; j += i) { isPrime[j] = 1; } } } } return ans; } JavaScript： var countPrimes = function(n) { const isPrime = new Array(n).fill(1); let ans = 0; for (let i = 2; i \u003c n; ++i) { if (isPrime[i]) { ans += 1; for (let j = i * i; j \u003c n; j += i) { isPrime[j] = 0; } } } return ans; }; 复杂度 分析： 时间复杂度：$ \\rm{O(n \\log \\log n)} $。 空间复杂度：$ \\rm{O(n)} $。我们需要$ \\rm{O(n)} $的空间记录每个数是否为质数。 ","date":"2020-04-10","objectID":"/204_countprimes/:4:0","series":null,"tags":["LeetCode"],"title":"204.计算质数","uri":"/204_countprimes/#方法二埃氏筛"},{"categories":["LeetCode"],"content":"202.快乐数","date":"2020-04-09","objectID":"/202_happynumber/","series":null,"tags":["LeetCode"],"title":"202.快乐数","uri":"/202_happynumber/"},{"categories":["LeetCode"],"content":" 202.快乐数","date":"2020-04-09","objectID":"/202_happynumber/:0:0","series":null,"tags":["LeetCode"],"title":"202.快乐数","uri":"/202_happynumber/#202快乐数"},{"categories":["LeetCode"],"content":"196.删除重复的电子邮箱","date":"2020-04-08","objectID":"/196_deleteduplicateemails/","series":null,"tags":["LeetCode"],"title":"196.删除重复的电子邮箱","uri":"/196_deleteduplicateemails/"},{"categories":["LeetCode"],"content":" 题目描述编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。 示例： +----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | | 3 | john@example.com | +----+------------------+ Id 是这个表的主键。 在运行你的SQL语句之后，上面的 Person 表应返回以下几行： +----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | +----+------------------+ 说明： 执行 SQL 之后，输出是整个 Person 表。 使用 delete 语句。 ","date":"2020-04-08","objectID":"/196_deleteduplicateemails/:1:0","series":null,"tags":["LeetCode"],"title":"196.删除重复的电子邮箱","uri":"/196_deleteduplicateemails/#题目描述"},{"categories":["LeetCode"],"content":" 题解","date":"2020-04-08","objectID":"/196_deleteduplicateemails/:2:0","series":null,"tags":["LeetCode"],"title":"196.删除重复的电子邮箱","uri":"/196_deleteduplicateemails/#题解"},{"categories":["LeetCode"],"content":" 方法：使用 DELETE 和 WHERE 子句思路： 我们可以使用以下代码，将此表与它自身在电子邮箱列中连接起来。 SELECT p1.* FROM Person p1, Person p2 WHERE p1.Email = p2.Email ; 然后我们需要找到其他记录中具有相同电子邮件地址的更大 ID。所以我们可以像这样给 WHERE 子句添加一个新的条件。 SELECT p1.* FROM Person p1, Person p2 WHERE p1.Email = p2.Email AND p1.Id \u003e p2.Id ; 因为我们已经得到了要删除的记录，所以我们最终可以将该语句更改为 DELETE。 DELETE p1 FROM Person p1, Person p2 WHERE p1.Email = p2.Email AND p1.Id \u003e p2.Id ","date":"2020-04-08","objectID":"/196_deleteduplicateemails/:3:0","series":null,"tags":["LeetCode"],"title":"196.删除重复的电子邮箱","uri":"/196_deleteduplicateemails/#方法使用-delete-和-where-子句"},{"categories":["LeetCode"],"content":"195.第十行","date":"2020-04-07","objectID":"/195_tenthline/","series":null,"tags":["LeetCode"],"title":"195.第十行","uri":"/195_tenthline/"},{"categories":["LeetCode"],"content":" 题目描述给定一个文本文件 file.txt，请只打印这个文件中的第十行。 示例： 假设 file.txt 有如下内容： Line 1 Line 2 Line 3 Line 4 Line 5 Line 6 Line 7 Line 8 Line 9 Line 10 你的脚本应当显示第十行： Line 10 说明： 如果文件少于十行，你应当输出什么？ 至少有三种不同的解法，请尝试尽可能多的方法来解题。 ","date":"2020-04-07","objectID":"/195_tenthline/:1:0","series":null,"tags":["LeetCode"],"title":"195.第十行","uri":"/195_tenthline/#题目描述"},{"categories":["LeetCode"],"content":" 题解 # 打印第十行 # -n: 取消默认的 sed 软件的输出, 通常和 p 一起合用 # p: 打印匹配行(通常和 -n 一起合用) # 没有第十行, 什么也不输出 sed -n '10p' file.txt # 打印一到十行 sed -n '1,10p' file.txt # 打印第十行 # 变量 NR: 已经读出的记录数, 从 1 开始 # 没有第十行, 什么也不输出 # 更多变量自行百度 awk 'NR==10' file.txt # 打印第十行 # 没有第十行, 什么也不输出 tail -n +10 file.txt | head -1 ","date":"2020-04-07","objectID":"/195_tenthline/:2:0","series":null,"tags":["LeetCode"],"title":"195.第十行","uri":"/195_tenthline/#题解"},{"categories":["LeetCode"],"content":"191.位1的个数","date":"2020-04-06","objectID":"/191_hammingweight/","series":null,"tags":["LeetCode"],"title":"191.位1的个数","uri":"/191_hammingweight/"},{"categories":["LeetCode"],"content":" 题目描述编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的{% span red, 示例3 %}中，输入表示有符号整数$ \\tt {-3} $。 进阶： 如果多次调用这个函数，你将如何优化你的算法？ 示例 1： 输入：00000000000000000000000000001011 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2： 输入：00000000000000000000000010000000 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3： 输入：11111111111111111111111111111101 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 提示： 输入必须是长度为$ \\tt {32} $的二进制串 ","date":"2020-04-06","objectID":"/191_hammingweight/:1:0","series":null,"tags":["LeetCode"],"title":"191.位1的个数","uri":"/191_hammingweight/#题目描述"},{"categories":["LeetCode"],"content":" 题解","date":"2020-04-06","objectID":"/191_hammingweight/:2:0","series":null,"tags":["LeetCode"],"title":"191.位1的个数","uri":"/191_hammingweight/#题解"},{"categories":["LeetCode"],"content":" 方法一：循环检查二进制位思路及解法 我们可以直接循环检查给定整数$ \\tt{n} $的二进制位的每一位是否为$ \\tt{1} $。 具体代码中，当检查第$ \\tt{i} $位时，我们可以让$ \\tt{n} $与$ \\tt{2^i} $进行与运算，当且仅当$ \\tt{n} $的第$ \\tt{i} $位为$ \\tt{1} $时，运算结果不为$ \\tt{0} $。 代码展示： Java： public class Solution { public int hammingWeight(int n) { int ret = 0; for (int i = 0; i \u003c 32; i++) { if ((n \u0026 (1 \u003c\u003c i)) != 0) { ret++; } } return ret; } } Python： class Solution: def hammingWeight(self, n: int) -\u003e int: ret = sum(1 for i in range(32) if n \u0026 (1 \u003c\u003c i)) return ret C： int hammingWeight(uint32_t n) { int ret = 0; for (int i = 0; i \u003c 32; i++) { if (n \u0026 (1u \u003c\u003c i)) { ret++; } } return ret; } JavaScript： var hammingWeight = function(n) { let ret = 0; for (let i = 0; i \u003c 32; i++) { if ((n \u0026 (1 \u003c\u003c i)) !== 0) { ret++; } } return ret; }; 复杂度分析： 时间复杂度：$ \\rm{O(n)} $ 。其中$ \\tt{n} $是$ \\tt{int} $型的二进制位数，$ \\tt{k = 32} $。我们需要检查$ \\tt{n} $的二进制位的每一位，一共需要检查$ \\tt{32} $位。 空间复杂度：$ \\rm{O(1)} $ 。我们只需要常数的空间保存若干变量。 ","date":"2020-04-06","objectID":"/191_hammingweight/:3:0","series":null,"tags":["LeetCode"],"title":"191.位1的个数","uri":"/191_hammingweight/#方法一循环检查二进制位"},{"categories":["LeetCode"],"content":" 方法二：位运算优化思路及解法 我们可以把前面的算法进行优化。我们不再检查数字的每一个位，而是不断把数字最后一个$ \\tt{1} $反转，并把答案$ \\tt {+1} $。当数字变成$ \\tt{0} $的时候，我们就知道它没有$ \\tt{1} $的位了，此时返回答案。 这里关键的想法是对于任意数字$ \\tt{n} $，将$ \\tt{n} $和$ \\tt{n-1} $做与运算，会把最后一个$ \\tt{1} $的位变成$ \\tt{0} $。为什么？考虑 $ \\tt{n} $和$ \\tt{n-1} $的二进制表示。 在二进制表示中，数字$ \\tt{n} $中最低位的$ \\tt{1} $总是对应$ \\tt{n-1} $中的$ \\tt{0} $。因此将$ \\tt{n} $和$ \\tt{n-1} $做与运算总是能把$ \\tt{n} $中最低位的$ \\tt{1} $变成$ \\tt{0} $，并保持其他位置不变。 使用这个小技巧，代码就变得非常简单。 代码展示： Java： public class Solution { public int hammingWeight(int n) { int ret = 0; while (n != 0) { n \u0026= n - 1; ret++; } return ret; } } Python： class Solution: def hammingWeight(self, n: int) -\u003e int: ret = 0 while n: n \u0026= n - 1 ret += 1 return ret C： int hammingWeight(uint32_t n) { int ret = 0; while (n) { n \u0026= n - 1; ret++; } return ret; } JavaScript： var hammingWeight = function(n) { let ret = 0; while (n) { n \u0026= n - 1; ret++; } return ret; }; 复杂度分析： 时间复杂度：$ \\rm{O(\\log n)} $ 。循环次数等于$ \\tt{n} $的二进制位中$ \\tt{1} $的个数，最坏情况下$ \\tt{n} $的二进制位全部为$ \\tt{1} $。我们需要循环 $ \\tt{\\log n} $ 次。 空间复杂度：$ \\rm{O(1)} $ 。我们只需要常数的空间保存若干变量。 ","date":"2020-04-06","objectID":"/191_hammingweight/:4:0","series":null,"tags":["LeetCode"],"title":"191.位1的个数","uri":"/191_hammingweight/#方法二位运算优化"},{"categories":["LeetCode"],"content":"182.查找重复的电子邮箱","date":"2020-04-05","objectID":"/182_duplicateemails/","series":null,"tags":["LeetCode"],"title":"182.查找重复的电子邮箱","uri":"/182_duplicateemails/"},{"categories":["LeetCode"],"content":" 题目描述编写一个 SQL 查询，查找 Person 表中重复的电子邮箱。 示例： +----+---------+ | Id | Email | +----+---------+ | 1 | a@b.com | | 2 | c@d.com | | 3 | a@b.com | +----+---------+ 根据以上输入，你的查询应返回以下结果： +---------+ | Email | +---------+ | a@b.com | +---------+ 说明： 所有的电子邮箱都是小写字母。 ","date":"2020-04-05","objectID":"/182_duplicateemails/:1:0","series":null,"tags":["LeetCode"],"title":"182.查找重复的电子邮箱","uri":"/182_duplicateemails/#题目描述"},{"categories":["LeetCode"],"content":" 题解","date":"2020-04-05","objectID":"/182_duplicateemails/:2:0","series":null,"tags":["LeetCode"],"title":"182.查找重复的电子邮箱","uri":"/182_duplicateemails/#题解"},{"categories":["LeetCode"],"content":" 方法一：使用 GROUP BY 和临时表重复的电子邮箱存在多次。要计算每封电子邮箱的存在次数，我们可以使用以下代码。 select Email, count(Email) as num from Person group by Email; 输出结果： +---------+-----+ | Email | num | |---------|-----| | a@b.com | 2 | | c@d.com | 1 | +---------+-----+ 以此作为临时表，我们可以得到下面的解决方案。 select Email from ( select Email, count(Email) as num from Person group by Email ) as statistic where num \u003e 1 ; ","date":"2020-04-05","objectID":"/182_duplicateemails/:3:0","series":null,"tags":["LeetCode"],"title":"182.查找重复的电子邮箱","uri":"/182_duplicateemails/#方法一使用-group-by-和临时表"},{"categories":["LeetCode"],"content":" 方法二：使用 GROUP BY 和 HAVING 条件向 GROUP BY 添加条件的一种更常用的方法是使用 HAVING 子句，该子句更为简单高效。 所以我们可以将上面的解决方案重写为： select Email from Person group by Email having count(Email) \u003e 1; ","date":"2020-04-05","objectID":"/182_duplicateemails/:4:0","series":null,"tags":["LeetCode"],"title":"182.查找重复的电子邮箱","uri":"/182_duplicateemails/#方法二使用-group-by-和-having-条件"},{"categories":["LeetCode"],"content":"184.部门工资最高的员工","date":"2020-04-05","objectID":"/184_departmenthighestsalary/","series":null,"tags":["LeetCode"],"title":"184.部门工资最高的员工","uri":"/184_departmenthighestsalary/"},{"categories":["LeetCode"],"content":" 题目描述Employee 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。 示例： +----+-------+--------+--------------+ | Id | Name | Salary | DepartmentId | +----+-------+--------+--------------+ | 1 | Joe | 70000 | 1 | | 2 | Jim | 90000 | 1 | | 3 | Henry | 80000 | 2 | | 4 | Sam | 60000 | 2 | | 5 | Max | 90000 | 1 | +----+-------+--------+--------------+ Department 表包含公司所有部门的信息。 +----+----------+ | Id | Name | +----+----------+ | 1 | IT | | 2 | Sales | +----+----------+ 编写一个 SQL 查询，找出每个部门工资最高的员工。对于上述表，您的 SQL 查询应返回以下行（行的顺序无关紧要）。 +------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT | Max | 90000 | | IT | Jim | 90000 | | Sales | Henry | 80000 | +------------+----------+--------+ 说明： Max 和 Jim 在 IT 部门的工资都是最高的，Henry 在销售部的工资最高。 ","date":"2020-04-05","objectID":"/184_departmenthighestsalary/:1:0","series":null,"tags":["LeetCode"],"title":"184.部门工资最高的员工","uri":"/184_departmenthighestsalary/#题目描述"},{"categories":["LeetCode"],"content":" 题解","date":"2020-04-05","objectID":"/184_departmenthighestsalary/:2:0","series":null,"tags":["LeetCode"],"title":"184.部门工资最高的员工","uri":"/184_departmenthighestsalary/#题解"},{"categories":["LeetCode"],"content":" 方法：使用 JOIN 和 IN 子句思路： 因为 Employee 表包含 Salary 和 DepartmentId 字段，我们可以以此在部门内查询最高工资。 SELECT DepartmentId, MAX(Salary) FROM Employee GROUP BY DepartmentId; 注意：有可能有多个员工同时拥有最高工资，所以最好在这个查询中不包含雇员名字的信息。 +--------------+-------------+ | DepartmentId | MAX(Salary) | |--------------|-------------| | 1 | 90000 | | 2 | 80000 | +--------------+-------------+ 然后，我们可以把表 Employee 和 Department 连接，再在这张临时表里用 IN 语句查询部门名字和工资的关系。 SELECT Department.name AS 'Department', Employee.name AS 'Employee', Salary FROM Employee JOIN Department ON Employee.DepartmentId = Department.Id WHERE (Employee.DepartmentId , Salary) IN ( SELECT DepartmentId, MAX(Salary) FROM Employee GROUP BY DepartmentId ) ; 结果 +------------+----------+--------+ | Department | Employee | Salary | |------------|----------|--------| | Sales | Henry | 80000 | | IT | Max | 90000 | +------------+----------+--------+ ","date":"2020-04-05","objectID":"/184_departmenthighestsalary/:3:0","series":null,"tags":["LeetCode"],"title":"184.部门工资最高的员工","uri":"/184_departmenthighestsalary/#方法使用-join-和-in-子句"},{"categories":["LeetCode"],"content":"141.环形链表","date":"2020-04-04","objectID":"/141_linkedlistcycle/","series":null,"tags":["LeetCode"],"title":"141.环形链表","uri":"/141_linkedlistcycle/"},{"categories":["LeetCode"],"content":" 141.环形链表","date":"2020-04-04","objectID":"/141_linkedlistcycle/:0:0","series":null,"tags":["LeetCode"],"title":"141.环形链表","uri":"/141_linkedlistcycle/#141环形链表"},{"categories":["LeetCode"],"content":"136.只出现一次的数字","date":"2020-04-03","objectID":"/136_singlenumber/","series":null,"tags":["LeetCode"],"title":"136.只出现一次的数字","uri":"/136_singlenumber/"},{"categories":["LeetCode"],"content":" 题目描述给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次，找出那个只出现一次的元素 示例 1： 输入：[2, 2, 1] 输出：1 示例 2： 输入：[4, 1, 2, 1, 2] 输出：4 示例 3： 输入：n = 1 输出：0 说明： 你的算法应该具有线性时间复杂度。你可以不使用额外空间来实现吗？ ","date":"2020-04-03","objectID":"/136_singlenumber/:1:0","series":null,"tags":["LeetCode"],"title":"136.只出现一次的数字","uri":"/136_singlenumber/#题目描述"},{"categories":["LeetCode"],"content":" 题解","date":"2020-04-03","objectID":"/136_singlenumber/:2:0","series":null,"tags":["LeetCode"],"title":"136.只出现一次的数字","uri":"/136_singlenumber/#题解"},{"categories":["LeetCode"],"content":" 方法一：位运算如果没有时间复杂度和空间复杂度的限制，这道题有很多解法，可能的解法有以下几种： 使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。 使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。 使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素不重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的就是数组中只出现一次的数字。 上述三种解法都需要额外使用$ \\rm O(n) $的空间。其中$ \\tt{n} $是数组长度。如果要求使用线性时间复杂度和常数空间复杂度，上述三种解法显然都不满足要求。那么，如何才能做到线性时间复杂度和常数空间复杂度呢？ 答案是使用位运算。对于这道题，可使用异或运算$ \\tt{\\oplus} $。异或运算有一下三个性质。 任何数和$ \\tt{0} $做异或运算，结果仍然是原来的数，即$ \\tt{a \\oplus 0 = a} $。 任何数和自身做异或运算，结果是$ \\tt{0} $，即$ \\tt{a \\oplus a = 0} $。 异或运算满足交换律和结合律，即$ \\tt{a \\oplus b \\oplus a=b \\oplus a \\oplus a=b \\oplus (a \\oplus a)=b \\oplus0=b} $。 假设数组有$ \\tt{2m + 1} $个数，其中有$ \\tt{m} $个数各出现两次，一个数出现一次。令$ \\tt{a_{1}、a{2}、\\ldots、a{m}} $为出现两次的 $ \\tt{m} $个数，$ \\tt{a_{m+1}} $为出现一次的数。根据{% span red, 性质3 %}，数组中的全部元素的异或运算结果总是可以写成如下形式： $$ \\tt{(a_{1} \\oplus a_{1}) \\oplus (a_{2} \\oplus a_{2}) \\oplus \\cdots \\oplus (a_{m} \\oplus a_{m}) \\oplus a_{m+1}} $$ 根据{% span red, 性质2 %}和{% span red, 性质1 %}，上式可简化和计算得到如下结果： $$ \\tt{0 \\oplus 0 \\oplus \\cdots \\oplus 0 \\oplus a_{m+1} = a_{m+1}} $$ 因此，数组中的全部元素的异或运算结果即为数组中只出现一次的数字。 代码展示： Java： class Solution { public int singleNumber(int[] nums) { int single = 0; for (int num : nums) { single ^= num; } return single; } } Python： class Solution: def singleNumber(self, nums: List[int]) -\u003e int: return reduce(lambda x, y: x ^ y, nums) C++： class Solution { public: int singleNumber(vector\u003cint\u003e\u0026 nums) { int ret = 0; for (auto e: nums) ret ^= e; return ret; } }; 复杂度分析： 时间复杂度：$ \\rm{O(n)} $ ，其中$ \\tt{m} $是数组的长度。只需要对数组遍历一次。 空间复杂度：$ \\rm{O(1)} $。 ","date":"2020-04-03","objectID":"/136_singlenumber/:3:0","series":null,"tags":["LeetCode"],"title":"136.只出现一次的数字","uri":"/136_singlenumber/#方法一位运算"},{"categories":["LeetCode"],"content":"69.x的平方根","date":"2020-04-02","objectID":"/69_sqrtx/","series":null,"tags":["LeetCode"],"title":"69.x的平方根","uri":"/69_sqrtx/"},{"categories":["LeetCode"],"content":" 69.x的平方根","date":"2020-04-02","objectID":"/69_sqrtx/:0:0","series":null,"tags":["LeetCode"],"title":"69.x的平方根","uri":"/69_sqrtx/#69x的平方根"},{"categories":["LeetCode"],"content":"9.回文数","date":"2020-04-01","objectID":"/9_palindromenumber/","series":null,"tags":["LeetCode"],"title":"9.回文数","uri":"/9_palindromenumber/"},{"categories":["LeetCode"],"content":" 9.回文数","date":"2020-04-01","objectID":"/9_palindromenumber/:0:0","series":null,"tags":["LeetCode"],"title":"9.回文数","uri":"/9_palindromenumber/#9回文数"},{"categories":["主题文档"],"content":"这篇文档将展示如何在 DoIt 中使用 GoAT 和 Mermaid 创建 SVG 图表。","date":"2020-03-28","objectID":"/create-diagrams/","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/"},{"categories":["主题文档"],"content":" Note 你需要使用 Hugo v0.93.0 或更新的版本来创建自定义图表。 如果你不得不使用旧版的 Hugo，你可以使用 mermaid shortcode。 ","date":"2020-03-28","objectID":"/create-diagrams/:0:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#"},{"categories":["主题文档"],"content":" GoATGoATGo ASCII Tool 是 markdeep.mini.js 图像生成器的 Go 语言实现。 要使用 GoAT，只需将 ASCII 输入放在代码块中，并将语言设置为 goat。 ```goat // ASCII input here ``` 以下是使用 GoAT 生成 SVG 的一些示例。 查看更多示例 。 ","date":"2020-03-28","objectID":"/create-diagrams/:1:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#goat"},{"categories":["主题文档"],"content":" 树 ```goat . . . .--- 1 .-- 1 / 1 / \\ | | .---+ .-+ + / \\ .---+---. .--+--. | '--- 2 | '-- 2 / \\ 2 + + | | | | ---+ ---+ + / \\ / \\ .-+-. .-+-. .+. .+. | .--- 3 | .-- 3 \\ / 3 / \\ / \\ | | | | | | | | '---+ '-+ + 1 2 3 4 1 2 3 4 1 2 3 4 '--- 4 '-- 4 \\ 4 ``` 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 ","date":"2020-03-28","objectID":"/create-diagrams/:1:1","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#树"},{"categories":["主题文档"],"content":" 重叠 ```goat .-. .-. .-. .-. .-. .-. | | | | | | | | | | | | .---------. .--+---+--. .--+---+--. .--| |--. .--+ +--. .------|--. | | | | | | | | | | | | | | | | | | '---------' '--+---+--' '--+---+--' '--| |--' '--+ +--' '--|------' | | | | | | | | | | | | '-' '-' '-' '-' '-' '-' ``` ","date":"2020-03-28","objectID":"/create-diagrams/:1:2","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#重叠"},{"categories":["主题文档"],"content":" 线条装饰 ```goat ________ o * * .--------------. *---+--. | | o o | ^ \\ / | .----------. | | | '--* -+- | | v / \\ / | | \u003c------. | | | '-----\u003e .---(---' ---\u003e*\u003c--- / .+-\u003e*\u003c--o----' | | | | | \u003c--' ^ ^ | | | | | ^ \\ | '--------' | | \\/ *-----' o |\u003c-----\u003e| '-----' |__| v '------------' | /\\ *---------------' ``` ","date":"2020-03-28","objectID":"/create-diagrams/:1:3","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#线条装饰"},{"categories":["主题文档"],"content":" 线端 ```goat o--o *--o / / * o o o o o * * * * o o o o * * * * o o o o * * * * o--* *--* v v ^ ^ | | | | | | | | \\ \\ \\ \\ \\ \\ \\ \\ / / / / / / / / o--\u003e *--\u003e * o / / o * v ' o * v ' o * v \\ o * v \\ o * v / o * v / o--- *--- ^ ^ ^ ^ . . . . ^ ^ ^ ^ \\ \\ \\ \\ ^ ^ ^ ^ / / / / | | * o \\ \\ * o | | | | | | | | \\ \\ \\ \\ \\ \\ \\ \\ / / / / / / / / v v ^ ^ v v ^ ^ o * v ' o * v ' o * v \\ o * v \\ o * v / o * v / * o | | * o \\ \\ \u003c--o \u003c--* \u003c--\u003e \u003c--- ---o ---* ---\u003e ---- *\u003c-- o\u003c-- --\u003eo --\u003e* ``` ","date":"2020-03-28","objectID":"/create-diagrams/:1:4","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#线端"},{"categories":["主题文档"],"content":" 点网格 ```goat o o o o o * * * * * * * o o * o o o * * * o o o · * · · · · · · o o o o o * * * * * o o o o * o o o o * * * * * o * * · * * · · · · · · o o o o o * * * * * o * o o o o o o o o * * * * * o o o o o · o · · o · · * * · o o o o o * * * * * o * o o o o o o o * * * * o * o o · · · · o · · * · o o o o o * * * * * * * * * o o o o * * * o * o · · · · · · · * ``` · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · · ","date":"2020-03-28","objectID":"/create-diagrams/:1:5","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#点网格"},{"categories":["主题文档"],"content":" 大节点 ```goat .---. .-. .-. .-. .-. | A +-----\u003e| 1 +\u003c----\u003e| 2 |\u003c----+ 4 +------------------. | 8 | '---' '-' '+' '-' | '-' | ^ | ^ v | v | .-. .-+-. .-. .-+-. .-. .+. .---. | 3 +----\u003e| B |\u003c-----\u003e| 5 +----\u003e| C +----\u003e| 6 +----\u003e| 7 |\u003c----\u003e| D | '-' '---' '-' '---' '-' '-' '---' ``` A 1 2 3 4 B 5 C 6 8 7 D ","date":"2020-03-28","objectID":"/create-diagrams/:1:6","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#大节点"},{"categories":["主题文档"],"content":" 小网格 ```goat ___ ___ .---+---+---+---+---. .---+---+---+---. .---. .---. ___/ \\___/ \\ | | | | | | / \\ / \\ / \\ / \\ / | +---+ | / \\___/ \\___/ +---+---+---+---+---+ +---+---+---+---+ +---+ +---+ \\___/ b \\___/ \\ | | | b | | | \\ / \\a/ \\b/ \\ / \\ | +---+ | / a \\___/ \\___/ +---+---+---+---+---+ +---+---+---+---+ +---+ b +---+ \\___/ \\___/ \\ | | a | | | | / \\ / \\ / \\ / \\ / | a +---+ | \\___/ \\___/ '---+---+---+---+---' '---+---+---+---' '---' '---' ``` a b a b a b a b ","date":"2020-03-28","objectID":"/create-diagrams/:1:7","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#小网格"},{"categories":["主题文档"],"content":" 大网格 ```goat .----. .----. / \\ / \\ .-----+-----+-----. + +----+ +----. | | | | .-----+-----+-----+-----+ \\ / \\ / \\ | | | | / / / / / +----+ B +----+ + +-----+-----+-----+ +-----+-----+-----+-----+ / \\ / \\ / | | | | / / / / / + A +----+ +----+ | | B | | +-----+-----+-----+-----+ \\ / \\ / \\ +-----+-----+-----+ / / A / B / / '----+ +----+ + | | | | +-----+-----+-----+-----+ \\ / \\ / | A | | | / / / / / '----' '----' '-----+-----+-----' '-----+-----+-----+-----+ ``` A B A B A B ","date":"2020-03-28","objectID":"/create-diagrams/:1:8","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#大网格"},{"categories":["主题文档"],"content":" 复杂图表 ```goat +-------------------+ ^ .---. | A Box |__.--.__ __.--\u003e | .-. | | | | '--' v | * |\u003c--- | | +-------------------+ '-' | | Round *---(-. | .-----------------. .-------. .----------. .-------. | | | | Mixed Rounded | | | / Diagonals \\ | | | | | | | \u0026 Square Corners | '--. .--' / \\ |---+---| '-)-' .--------. '--+------------+-' .--. | '-------+--------' | | | | / Search / | | | | '---. | '-------' | '-+------' |\u003c----------\u003e| | | | v Interior | ^ ' \u003c---' '----' .-----------. ---. .--- v | .------------------. Diag line | .-------. +---. \\ / . | | if (a \u003e b) +---. .---\u003e| | | | | Curved line \\ / / \\ | | obj-\u003efcn() | \\ / | '-------' |\u003c--' + / \\ | '------------------' '--' '--+--------' .--. .--. | .-. +Done?+-' .---+-----. | ^ |\\ | | /| .--+ | | \\ / | | | Join \\|/ | | Curved | \\| |/ | | \\ | \\ / | | +----\u003e o --o-- '-' Vertical '--' '--' '-- '--' + .---. \u003c--+---+-----' | /|\\ | | 3 | v not:line 'quotes' .-' '---' .-. .---+--------. / A || B *bold* | ^ | | | Not a dot | \u003c---+---\u003c-- A dash--is not a line v | '-' '---------+--' / Nor/is this. --- ``` \u0026 A M S i o i q f b B x u j o e a ( - x d r a \u003e e f R \u003e c o C n u o b ( n r ) ) d n e e J d r o s i n N o R D t o i u a a n g d d l o i t n e D i a g o n a l s C V u e r r v t e i d c a l n o t A N C : o u l d r r i A a / I v n s i n e e h s t d - e - t r l B i h i i s i o n ' s r e q n . u * o o b t t o e l a s d ' * l i n e D o n S e e ? a r c 3 h ","date":"2020-03-28","objectID":"/create-diagrams/:1:9","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#复杂图表"},{"categories":["主题文档"],"content":" MermaidMermaid 是一个基于 JavaScript 的图表工具，它允许您使用文本和代码创建图表和可视化。 要使用 Mermaid，只需将 Mermaid 的代码输入放在代码块中，并将语言设置为 mermaid。 ```mermaid // mermaid diagram code here ``` 下面是一些使用 Mermaid 生成的 SVG 图表示例。 ","date":"2020-03-28","objectID":"/create-diagrams/:2:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#mermaid"},{"categories":["主题文档"],"content":" 流程图All Flowcharts are composed of nodes, geometric shapes and edges, the arrows or lines. The mermaid code defines the way that these nodes and edges are made and interact. ```mermaid graph TD; A--\u003eB; A--\u003eC; B--\u003eD; C--\u003eD; ``` graph TD; A--\u003eB; A--\u003eC; B--\u003eD; C--\u003eD; ","date":"2020-03-28","objectID":"/create-diagrams/:2:1","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#流程图"},{"categories":["主题文档"],"content":" 序列图A Sequence diagram is an interaction diagram that shows how processes operate with one another and in what order. ```mermaid sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003e\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail! John--\u003e\u003eAlice: Great! John-\u003e\u003eBob: How about you? Bob--\u003e\u003eJohn: Jolly good! ``` sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003e\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts prevail! John--\u003e\u003eAlice: Great! John-\u003e\u003eBob: How about you? Bob--\u003e\u003eJohn: Jolly good! ","date":"2020-03-28","objectID":"/create-diagrams/:2:2","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#序列图"},{"categories":["主题文档"],"content":" 甘特图A Gantt chart is a type of bar chart, first developed by Karol Adamiecki in 1896, and independently by Henry Gantt in the 1910s, that illustrates a project schedule and the amount of time it would take for any one project to finish. Gantt charts illustrate numbers of days between the start and finish dates of the terminal elements and summary elements of a project. ```mermaid gantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid excludes weekdays 2014-01-10 section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d ``` gantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid excludes weekdays 2014-01-10 section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d ","date":"2020-03-28","objectID":"/create-diagrams/:2:3","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#甘特图"},{"categories":["主题文档"],"content":" 类图The class diagram is the main building block of object-oriented modelling. It is used for general conceptual modelling of the structure of the application, and detailed modelling translating the models into programming code. Class diagrams can also be used for data modelling. The classes in a class diagram represent both the main elements, interactions in the application, and the classes to be programmed. ```mermaid classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label ``` classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label ","date":"2020-03-28","objectID":"/create-diagrams/:2:4","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#类图"},{"categories":["主题文档"],"content":" Git 图 ```mermaid gitGraph commit branch hotfix checkout hotfix commit branch develop checkout develop commit id:\"ash\" tag:\"abc\" branch featureB checkout featureB commit type:HIGHLIGHT checkout main checkout hotfix commit type:NORMAL checkout develop commit type:REVERSE checkout featureB commit checkout main merge hotfix checkout featureB commit checkout develop branch featureA commit checkout develop merge hotfix checkout featureA commit checkout featureB commit checkout develop merge featureA branch release checkout release commit checkout main commit checkout release merge main checkout develop merge release ``` gitGraph commit branch hotfix checkout hotfix commit branch develop checkout develop commit id:\"ash\" tag:\"abc\" branch featureB checkout featureB commit type:HIGHLIGHT checkout main checkout hotfix commit type:NORMAL checkout develop commit type:REVERSE checkout featureB commit checkout main merge hotfix checkout featureB commit checkout develop branch featureA commit checkout develop merge hotfix checkout featureA commit checkout featureB commit checkout develop merge featureA branch release checkout release commit checkout main commit checkout release merge main checkout develop merge release ","date":"2020-03-28","objectID":"/create-diagrams/:2:5","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#git-图"},{"categories":["主题文档"],"content":" 实体关系图 - 实验性An entity–relationship diagram (or ER diagram) describes interrelated things of interest in a specific domain of knowledge. A basic ER diagram is composed of entity types (which classify the things of interest) and specifies relationships that can exist between entities (instances of those entity types). ```mermaid erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses ``` erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses ","date":"2020-03-28","objectID":"/create-diagrams/:2:6","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#实体关系图---实验性"},{"categories":["主题文档"],"content":" 用户旅程图User journey diagrams describe at a high level of detail exactly what steps different users take to complete a specific task within a system, application or website. This technique shows the current (as-is) user workflow, and reveals areas of improvement for the to-be workflow. ```mermaid journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me ``` journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me ","date":"2020-03-28","objectID":"/create-diagrams/:2:7","series":null,"tags":["hugo","DoIt","主题文档"],"title":"如何在 DoIt 中创建图表","uri":"/create-diagrams/#用户旅程图"},{"categories":["主题文档"],"content":"Guide to setup PWA in DoIt","date":"2020-03-27","objectID":"/pwa-support/","series":null,"tags":["hugo","DoIt","主题文档"],"title":"PWA 支持","uri":"/pwa-support/"},{"categories":["主题文档"],"content":"了解如何在 DoIt 主题中配置渐进式网络应用程序 (PWA). ","date":"2020-03-27","objectID":"/pwa-support/:0:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"PWA 支持","uri":"/pwa-support/#"},{"categories":["主题文档"],"content":" 什么是 PWA？渐进式网络应用程序(PWA)是运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台网络应用程序.这些应用无处不在、功能丰富, 使其具有与原生应用相同的用户体验. ","date":"2020-03-27","objectID":"/pwa-support/:1:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"PWA 支持","uri":"/pwa-support/#什么是-pwa"},{"categories":["主题文档"],"content":" 为什么要配置 PWA？你并不需要将你的站点配置为一个 PWA. 传统的网站足以满足你想要分享的所有内容.但是, PWA 带来了一些可能有用的额外好处. 在用户安装 PWA 后, 页面将由 service worker 自动缓存, 这使得从第二次访问开始页面将被快速加载. 用户始终可以在离线时访问缓存的页面. 这些功能可能对某些网站（例如此文档站点）很有用, 但是将个人博客配置为 PWA 就没有多少意义.当然一切都取决于你的选择, 无论如何 DoIt 主题都将为你提供开启此功能的选项. ","date":"2020-03-27","objectID":"/pwa-support/:2:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"PWA 支持","uri":"/pwa-support/#为什么要配置-pwa"},{"categories":["主题文档"],"content":" 如何将使用 DoIt 主题的静态网站配置为 PWA?","date":"2020-03-27","objectID":"/pwa-support/:3:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"PWA 支持","uri":"/pwa-support/#如何将使用-doit-主题的静态网站配置为-pwa"},{"categories":["主题文档"],"content":" 配置 site.webmanifest你需要在 /static 文件夹下创建名为 site.webmanifest 的文件, 并在此文件提供有关你的 PWA 的信息. 以下是必填参数. name [必须] 你的 PWA 的名称. short_name [必须] 你的 PWA 的简称. start_url [必须] 你的 PWA 的起始地址.请默认填写\"/\". icons [必须] 你的 PWA 的图标.你可以将网站的 favicon 作为图标. 您还可以在 site.webmanifest 中设置其他可选值, 查看这篇文档来了解更多. 这是一份示例 site.webmanifest 文件. { \"name\": \"DoIt Theme Documentation\", \"short_name\": \"DoIt Docs\", \"start_url\": \"/\", \"description\": \"The documentation site for Hugo DoIt Theme\", \"theme_color\": \"#ffffff\", \"background_color\": \"#ffffff\", \"orientation\": \"portrait\", \"display\": \"standalone\", \"icons\": [ { \"src\": \"/android-chrome-192x192.png\", \"sizes\": \"192x192\", \"type\": \"image/png\" }, { \"src\": \"/android-chrome-512x512.png\", \"sizes\": \"512x512\", \"type\": \"image/png\" }, { \"src\": \"/apple-touch-icon.png\", \"sizes\": \"180x180\", \"type\": \"image/png\", \"purpose\": \"any maskable\" } ] } ","date":"2020-03-27","objectID":"/pwa-support/:3:1","series":null,"tags":["hugo","DoIt","主题文档"],"title":"PWA 支持","uri":"/pwa-support/#配置-sitewebmanifest"},{"categories":["主题文档"],"content":" 配置离线页面离线页面将在访客离线访问未缓存的页面时显示. 在/content目录下创建offline.md并在其中编写离线提示. Permalink 你需要确保离线页面的 Permalink 是 /offline, 否则你需要手动更改 service worker 中 OFFLINE_CACHE_FILES 和 OFFLINE_PAGE 的值. i18n 目前离线页面不支持 i18n, 如果你运行的是多语言网站, 请考虑在同一页面上编写多条不同语言的离线消息. 这是一个示例离线页面. --- title: \"Offline\" --- \u003e 你没有连接至互联网, 只有缓存的页面可用. ","date":"2020-03-27","objectID":"/pwa-support/:3:2","series":null,"tags":["hugo","DoIt","主题文档"],"title":"PWA 支持","uri":"/pwa-support/#配置离线页面"},{"categories":["主题文档"],"content":" 开启 enablePWA 选项前往 config.toml, 添加/修改 [params] 配置项下 enablePWA 选项的值为 true. [params] # ... enablePWA = true ","date":"2020-03-27","objectID":"/pwa-support/:3:3","series":null,"tags":["hugo","DoIt","主题文档"],"title":"PWA 支持","uri":"/pwa-support/#开启-enablepwa-选项"},{"categories":["主题文档"],"content":" 安装并使用你的 PWA如果一切顺利, 现在当你访问你的网站时, 浏览器将显示一个安装按钮. 安装 PWA 单击“安装”后, 你的网站将被安装为一个本地的原生应用程序. 安装完成 大功告成！你已成功将你的静态网站配置为了一个 PWA 🎉 如果你在配置过程中有任何问题, 你可以通过浏览器调试工具中的 Console 与 Application 面板来进行调试.你也可以用PWA Builder来检查你的网站以获得更多信息.你可以创建一个 discussion 来获得社区帮助或者提交 issue 来报告你遇到的任何 bug. ","date":"2020-03-27","objectID":"/pwa-support/:4:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"PWA 支持","uri":"/pwa-support/#安装并使用你的-pwa"},{"categories":["主题文档"],"content":"Hugo 和 DoIt 中的 Emoji 的用法指南.","date":"2020-03-26","objectID":"/emoji-support/","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/"},{"categories":["主题文档"],"content":"Emoji 可以通过多种方式在 Hugo 项目中启用. emojify 方法可以直接在模板中调用, 或者使用行内 Shortcodes. 要全局使用 emoji, 需要在你的网站配置中设置 enableEmoji 为 true, 然后你就可以直接在文章中输入 emoji 的代码. 它们以冒号开头和结尾, 并且包含 emoji 的 代码: 去露营啦! :tent: 很快就回来. 真开心! :joy: 呈现的输出效果如下: 去露营啦! ⛺ 很快就回来. 真开心! 😂 以下符号清单是 emoji 代码的非常有用的参考. ","date":"2020-03-26","objectID":"/emoji-support/:0:0","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#"},{"categories":["主题文档"],"content":" 表情与情感","date":"2020-03-26","objectID":"/emoji-support/:1:0","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#表情与情感"},{"categories":["主题文档"],"content":" 笑脸表情 图标 代码 图标 代码 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent ","date":"2020-03-26","objectID":"/emoji-support/:1:1","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#笑脸表情"},{"categories":["主题文档"],"content":" 爱意表情 图标 代码 图标 代码 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes ","date":"2020-03-26","objectID":"/emoji-support/:1:2","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#爱意表情"},{"categories":["主题文档"],"content":" 吐舌头表情 图标 代码 图标 代码 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face ","date":"2020-03-26","objectID":"/emoji-support/:1:3","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#吐舌头表情"},{"categories":["主题文档"],"content":" 带手的表情 图标 代码 图标 代码 🤗 hugs 🤔 thinking ","date":"2020-03-26","objectID":"/emoji-support/:1:4","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#带手的表情"},{"categories":["主题文档"],"content":" 中性表情 图标 代码 图标 代码 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face ","date":"2020-03-26","objectID":"/emoji-support/:1:5","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#中性表情"},{"categories":["主题文档"],"content":" 困倦的表情 图标 代码 图标 代码 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping ","date":"2020-03-26","objectID":"/emoji-support/:1:6","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#困倦的表情"},{"categories":["主题文档"],"content":" 不适的表情 图标 代码 图标 代码 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face ","date":"2020-03-26","objectID":"/emoji-support/:1:7","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#不适的表情"},{"categories":["主题文档"],"content":" 戴帽子的表情 图标 代码 图标 代码 🤠 cowboy_hat_face ","date":"2020-03-26","objectID":"/emoji-support/:1:8","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#戴帽子的表情"},{"categories":["主题文档"],"content":" 戴眼镜的表情 图标 代码 图标 代码 😎 sunglasses 🤓 nerd_face ","date":"2020-03-26","objectID":"/emoji-support/:1:9","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#戴眼镜的表情"},{"categories":["主题文档"],"content":" 担心的表情 图标 代码 图标 代码 😕 confused 😟 worried 🙁 slightly_frowning_face ☹ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face ","date":"2020-03-26","objectID":"/emoji-support/:1:10","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#担心的表情"},{"categories":["主题文档"],"content":" 否定的表情 图标 代码 图标 代码 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones ","date":"2020-03-26","objectID":"/emoji-support/:1:11","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#否定的表情"},{"categories":["主题文档"],"content":" 特殊打扮的表情 图标 代码 图标 代码 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot ","date":"2020-03-26","objectID":"/emoji-support/:1:12","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#特殊打扮的表情"},{"categories":["主题文档"],"content":" 猫脸表情 图标 代码 图标 代码 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat ","date":"2020-03-26","objectID":"/emoji-support/:1:13","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#猫脸表情"},{"categories":["主题文档"],"content":" 猴脸表情 图标 代码 图标 代码 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil ","date":"2020-03-26","objectID":"/emoji-support/:1:14","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#猴脸表情"},{"categories":["主题文档"],"content":" 情感 图标 代码 图标 代码 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2020-03-26","objectID":"/emoji-support/:1:15","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#情感"},{"categories":["主题文档"],"content":" 人与身体","date":"2020-03-26","objectID":"/emoji-support/:2:0","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#人与身体"},{"categories":["主题文档"],"content":" 张开手掌的手势 图标 代码 图标 代码 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute ","date":"2020-03-26","objectID":"/emoji-support/:2:1","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#张开手掌的手势"},{"categories":["主题文档"],"content":" 部分手指的手势 图标 代码 图标 代码 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand ","date":"2020-03-26","objectID":"/emoji-support/:2:2","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#部分手指的手势"},{"categories":["主题文档"],"content":" 一根手指的手势 图标 代码 图标 代码 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up ","date":"2020-03-26","objectID":"/emoji-support/:2:3","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#一根手指的手势"},{"categories":["主题文档"],"content":" 握紧的手势 图标 代码 图标 代码 👍 +1 thumbsup 👎 -1 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right ","date":"2020-03-26","objectID":"/emoji-support/:2:4","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#握紧的手势"},{"categories":["主题文档"],"content":" 两只手 图标 代码 图标 代码 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray ","date":"2020-03-26","objectID":"/emoji-support/:2:5","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#两只手"},{"categories":["主题文档"],"content":" 握住东西的手势 图标 代码 图标 代码 ✍️ writing_hand 💅 nail_care 🤳 selfie ","date":"2020-03-26","objectID":"/emoji-support/:2:6","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#握住东西的手势"},{"categories":["主题文档"],"content":" 身体部位 图标 代码 图标 代码 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips ","date":"2020-03-26","objectID":"/emoji-support/:2:7","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#身体部位"},{"categories":["主题文档"],"content":" 人 图标 代码 图标 代码 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman ","date":"2020-03-26","objectID":"/emoji-support/:2:8","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#人"},{"categories":["主题文档"],"content":" 身体动作 图标 代码 图标 代码 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man 🙎‍♀️ person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁‍♀️ information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋‍♀️ raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇 bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging ","date":"2020-03-26","objectID":"/emoji-support/:2:9","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#身体动作"},{"categories":["主题文档"],"content":" 人物角色 图标 代码 图标 代码 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮‍♂️ cop policeman 👮‍♀️ policewoman 🕵 detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷‍♂️ construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰 bride_with_veil 🤰 pregnant_woman ","date":"2020-03-26","objectID":"/emoji-support/:2:10","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#人物角色"},{"categories":["主题文档"],"content":" 幻想的人物 图标 代码 图标 代码 👼 angel 🎅 santa 🤶 mrs_claus ","date":"2020-03-26","objectID":"/emoji-support/:2:11","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#幻想的人物"},{"categories":["主题文档"],"content":" 人物活动 图标 代码 图标 代码 💆‍♀️ massage massage_woman 💆‍♂️ massage_man 💇‍♀️ haircut haircut_woman 💇‍♂️ haircut_man 🚶‍♂️ walking walking_man 🚶‍♀️ walking_woman 🏃‍♂️ runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯‍♀️ dancers dancing_women 👯‍♂️ dancing_men ","date":"2020-03-26","objectID":"/emoji-support/:2:12","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#人物活动"},{"categories":["主题文档"],"content":" 体育 图标 代码 图标 代码 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄‍♂️ surfer surfing_man 🏄‍♀️ surfing_woman 🚣‍♂️ rowboat rowing_man 🚣‍♀️ rowing_woman 🏊‍♂️ swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴‍♂️ bicyclist biking_man 🚴‍♀️ biking_woman 🚵‍♂️ mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling ","date":"2020-03-26","objectID":"/emoji-support/:2:13","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#体育"},{"categories":["主题文档"],"content":" 休息 图标 代码 图标 代码 🛀 bath 🛌 sleeping_bed ","date":"2020-03-26","objectID":"/emoji-support/:2:14","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#休息"},{"categories":["主题文档"],"content":" 家庭 图标 代码 图标 代码 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 💑 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👨‍👩‍👦 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍👧‍👧 family_woman_woman_girl_girl 👨‍👦 family_man_boy 👨‍👦‍👦 family_man_boy_boy 👨‍👧 family_man_girl 👨‍👧‍👦 family_man_girl_boy 👨‍👧‍👧 family_man_girl_girl 👩‍👦 family_woman_boy 👩‍👦‍👦 family_woman_boy_boy 👩‍👧 family_woman_girl 👩‍👧‍👦 family_woman_girl_boy 👩‍👧‍👧 family_woman_girl_girl ","date":"2020-03-26","objectID":"/emoji-support/:2:15","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#家庭"},{"categories":["主题文档"],"content":" 人物符号 图标 代码 图标 代码 🗣 speaking_head 👤 bust_in_silhouette 👥 busts_in_silhouette 👣 footprints ","date":"2020-03-26","objectID":"/emoji-support/:2:16","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#人物符号"},{"categories":["主题文档"],"content":" 动物与自然","date":"2020-03-26","objectID":"/emoji-support/:3:0","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#动物与自然"},{"categories":["主题文档"],"content":" 哺乳动物 图标 代码 图标 代码 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints ","date":"2020-03-26","objectID":"/emoji-support/:3:1","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#哺乳动物"},{"categories":["主题文档"],"content":" 鸟类 图标 代码 图标 代码 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊 dove 🦅 eagle 🦆 duck 🦉 owl ","date":"2020-03-26","objectID":"/emoji-support/:3:2","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#鸟类"},{"categories":["主题文档"],"content":" 两栖动物 icon code icon code 🐸 frog ","date":"2020-03-26","objectID":"/emoji-support/:3:3","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#两栖动物"},{"categories":["主题文档"],"content":" 爬虫类 图标 代码 图标 代码 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon ","date":"2020-03-26","objectID":"/emoji-support/:3:4","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#爬虫类"},{"categories":["主题文档"],"content":" 海洋动物 图标 代码 图标 代码 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell ","date":"2020-03-26","objectID":"/emoji-support/:3:5","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#海洋动物"},{"categories":["主题文档"],"content":" 虫类 图标 代码 图标 代码 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion ","date":"2020-03-26","objectID":"/emoji-support/:3:6","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#虫类"},{"categories":["主题文档"],"content":" 花类植物 图标 代码 图标 代码 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip ","date":"2020-03-26","objectID":"/emoji-support/:3:7","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#花类植物"},{"categories":["主题文档"],"content":" 其它植物 图标 代码 图标 代码 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2020-03-26","objectID":"/emoji-support/:3:8","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#其它植物"},{"categories":["主题文档"],"content":" 食物与饮料","date":"2020-03-26","objectID":"/emoji-support/:4:0","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#食物与饮料"},{"categories":["主题文档"],"content":" 水果 图标 代码 图标 代码 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato ","date":"2020-03-26","objectID":"/emoji-support/:4:1","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#水果"},{"categories":["主题文档"],"content":" 蔬菜 图标 代码 图标 代码 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut ","date":"2020-03-26","objectID":"/emoji-support/:4:2","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#蔬菜"},{"categories":["主题文档"],"content":" 快餐 图标 代码 图标 代码 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn ","date":"2020-03-26","objectID":"/emoji-support/:4:3","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#快餐"},{"categories":["主题文档"],"content":" 亚洲食物 图标 代码 图标 代码 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango ","date":"2020-03-26","objectID":"/emoji-support/:4:4","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#亚洲食物"},{"categories":["主题文档"],"content":" 海鲜 图标 代码 图标 代码 🦀 crab 🦐 shrimp 🦑 squid ","date":"2020-03-26","objectID":"/emoji-support/:4:5","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#海鲜"},{"categories":["主题文档"],"content":" 甜点 图标 代码 图标 代码 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot ","date":"2020-03-26","objectID":"/emoji-support/:4:6","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#甜点"},{"categories":["主题文档"],"content":" 饮料 图标 代码 图标 代码 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass ","date":"2020-03-26","objectID":"/emoji-support/:4:7","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#饮料"},{"categories":["主题文档"],"content":" 餐具 图标 代码 图标 代码 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2020-03-26","objectID":"/emoji-support/:4:8","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#餐具"},{"categories":["主题文档"],"content":" 旅游与地理","date":"2020-03-26","objectID":"/emoji-support/:5:0","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#旅游与地理"},{"categories":["主题文档"],"content":" 地图 图标 代码 图标 代码 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan ","date":"2020-03-26","objectID":"/emoji-support/:5:1","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#地图"},{"categories":["主题文档"],"content":" 地理现象 图标 代码 图标 代码 🏔 mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping ⛱ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park ","date":"2020-03-26","objectID":"/emoji-support/:5:2","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#地理现象"},{"categories":["主题文档"],"content":" 建筑物 图标 代码 图标 代码 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘 houses 🏚 derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty ","date":"2020-03-26","objectID":"/emoji-support/:5:3","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#建筑物"},{"categories":["主题文档"],"content":" 宗教建筑 图标 代码 图标 代码 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba ","date":"2020-03-26","objectID":"/emoji-support/:5:4","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#宗教建筑"},{"categories":["主题文档"],"content":" 其它地点 图标 代码 图标 代码 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent ","date":"2020-03-26","objectID":"/emoji-support/:5:5","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#其它地点"},{"categories":["主题文档"],"content":" 陆路运输 图标 代码 图标 代码 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍 motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction ","date":"2020-03-26","objectID":"/emoji-support/:5:6","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#陆路运输"},{"categories":["主题文档"],"content":" 水路运输 图标 代码 图标 代码 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship ","date":"2020-03-26","objectID":"/emoji-support/:5:7","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#水路运输"},{"categories":["主题文档"],"content":" 空中运输 图标 代码 图标 代码 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket ","date":"2020-03-26","objectID":"/emoji-support/:5:8","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#空中运输"},{"categories":["主题文档"],"content":" 旅馆 icon code icon code 🛎️ bellhop_bell ","date":"2020-03-26","objectID":"/emoji-support/:5:9","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#旅馆"},{"categories":["主题文档"],"content":" 时间 图标 代码 图标 代码 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 ","date":"2020-03-26","objectID":"/emoji-support/:5:10","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#时间"},{"categories":["主题文档"],"content":" 天空与天气 图标 代码 图标 代码 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈ cloud_with_lightning_and_rain 🌤 sun_behind_small_cloud 🌥 sun_behind_large_cloud 🌦 sun_behind_rain_cloud 🌧 cloud_with_rain 🌨 cloud_with_snow 🌩 cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬 wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☂️ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ☃️ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2020-03-26","objectID":"/emoji-support/:5:11","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#天空与天气"},{"categories":["主题文档"],"content":" 活动","date":"2020-03-26","objectID":"/emoji-support/:6:0","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#活动"},{"categories":["主题文档"],"content":" 事件 图标 代码 图标 代码 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟 tickets 🎫 ticket ","date":"2020-03-26","objectID":"/emoji-support/:6:1","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#事件"},{"categories":["主题文档"],"content":" 奖杯与奖牌 图标 代码 图标 代码 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal ","date":"2020-03-26","objectID":"/emoji-support/:6:2","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#奖杯与奖牌"},{"categories":["主题文档"],"content":" 体育运动 图标 代码 图标 代码 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski ","date":"2020-03-26","objectID":"/emoji-support/:6:3","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#体育运动"},{"categories":["主题文档"],"content":" 游戏 图标 代码 图标 代码 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards ","date":"2020-03-26","objectID":"/emoji-support/:6:4","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#游戏"},{"categories":["主题文档"],"content":" 艺术与工艺 图标 代码 图标 代码 🎭 performing_arts 🖼 framed_picture 🎨 art ","date":"2020-03-26","objectID":"/emoji-support/:6:5","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#艺术与工艺"},{"categories":["主题文档"],"content":" 物品","date":"2020-03-26","objectID":"/emoji-support/:7:0","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#物品"},{"categories":["主题文档"],"content":" 服装 图标 代码 图标 代码 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem ","date":"2020-03-26","objectID":"/emoji-support/:7:1","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#服装"},{"categories":["主题文档"],"content":" 声音 图标 代码 图标 代码 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell ","date":"2020-03-26","objectID":"/emoji-support/:7:2","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#声音"},{"categories":["主题文档"],"content":" 音乐 图标 代码 图标 代码 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio ","date":"2020-03-26","objectID":"/emoji-support/:7:3","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#音乐"},{"categories":["主题文档"],"content":" 乐器 图标 代码 图标 代码 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum ","date":"2020-03-26","objectID":"/emoji-support/:7:4","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#乐器"},{"categories":["主题文档"],"content":" 电话 图标 代码 图标 代码 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax ","date":"2020-03-26","objectID":"/emoji-support/:7:5","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#电话"},{"categories":["主题文档"],"content":" 电脑 图标 代码 图标 代码 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱 computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd ","date":"2020-03-26","objectID":"/emoji-support/:7:6","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#电脑"},{"categories":["主题文档"],"content":" 灯光与影像 图标 代码 图标 代码 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern ","date":"2020-03-26","objectID":"/emoji-support/:7:7","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#灯光与影像"},{"categories":["主题文档"],"content":" 书与纸张 图标 代码 图标 代码 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label ","date":"2020-03-26","objectID":"/emoji-support/:7:8","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#书与纸张"},{"categories":["主题文档"],"content":" 钱 图标 代码 图标 代码 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart ","date":"2020-03-26","objectID":"/emoji-support/:7:9","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#钱"},{"categories":["主题文档"],"content":" 邮件 图标 代码 图标 代码 ✉️ email envelope 📧 📧 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳 ballot_box ","date":"2020-03-26","objectID":"/emoji-support/:7:10","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#邮件"},{"categories":["主题文档"],"content":" 书写 图标 代码 图标 代码 ✏️ pencil2 ✒️ black_nib 🖋 fountain_pen 🖊 pen 🖌 paintbrush 🖍 crayon 📝 memo pencil ","date":"2020-03-26","objectID":"/emoji-support/:7:11","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#书写"},{"categories":["主题文档"],"content":" 办公 图标 代码 图标 代码 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒 spiral_notepad 🗓 spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇 paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket ","date":"2020-03-26","objectID":"/emoji-support/:7:12","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#办公"},{"categories":["主题文档"],"content":" 锁 图标 代码 图标 代码 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key ","date":"2020-03-26","objectID":"/emoji-support/:7:13","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#锁"},{"categories":["主题文档"],"content":" 工具 图标 代码 图标 代码 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡 dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜 clamp ⚖ balance_scale 🔗 link ⛓️ chains ","date":"2020-03-26","objectID":"/emoji-support/:7:14","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#工具"},{"categories":["主题文档"],"content":" 科学 图标 代码 图标 代码 ⚗️ alembic 🔬 microscope 🔭 telescope 🛰️ satellite ","date":"2020-03-26","objectID":"/emoji-support/:7:15","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#科学"},{"categories":["主题文档"],"content":" 医疗 图标 代码 图标 代码 💉 syringe 💊 pill ","date":"2020-03-26","objectID":"/emoji-support/:7:16","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#医疗"},{"categories":["主题文档"],"content":" 生活用品 图标 代码 图标 代码 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart ","date":"2020-03-26","objectID":"/emoji-support/:7:17","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#生活用品"},{"categories":["主题文档"],"content":" 其它物品 图标 代码 图标 代码 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2020-03-26","objectID":"/emoji-support/:7:18","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#其它物品"},{"categories":["主题文档"],"content":" 符号","date":"2020-03-26","objectID":"/emoji-support/:8:0","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#符号"},{"categories":["主题文档"],"content":" 交通标识 图标 代码 图标 代码 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage ","date":"2020-03-26","objectID":"/emoji-support/:8:1","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#交通标识"},{"categories":["主题文档"],"content":" 警告 图标 代码 图标 代码 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 🚱 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢ radioactive ☣ biohazard ","date":"2020-03-26","objectID":"/emoji-support/:8:2","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#警告"},{"categories":["主题文档"],"content":" 箭头 图标 代码 图标 代码 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top ","date":"2020-03-26","objectID":"/emoji-support/:8:3","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#箭头"},{"categories":["主题文档"],"content":" 宗教 图标 代码 图标 代码 🛐 place_of_worship ⚛️ atom_symbol 🕉 om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star ","date":"2020-03-26","objectID":"/emoji-support/:8:4","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#宗教"},{"categories":["主题文档"],"content":" 生肖 图标 代码 图标 代码 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus ","date":"2020-03-26","objectID":"/emoji-support/:8:5","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#生肖"},{"categories":["主题文档"],"content":" 影像符号 图标 代码 图标 代码 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭ next_track_button ⏯ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸ pause_button ⏹ stop_button ⏺ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off ","date":"2020-03-26","objectID":"/emoji-support/:8:6","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#影像符号"},{"categories":["主题文档"],"content":" 数学 图标 代码 图标 代码 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign ","date":"2020-03-26","objectID":"/emoji-support/:8:7","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#数学"},{"categories":["主题文档"],"content":" 标点符号 图标 代码 图标 代码 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash ","date":"2020-03-26","objectID":"/emoji-support/:8:8","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#标点符号"},{"categories":["主题文档"],"content":" 货币 图标 代码 图标 代码 💱 currency_exchange 💲 heavy_dollar_sign ","date":"2020-03-26","objectID":"/emoji-support/:8:9","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#货币"},{"categories":["主题文档"],"content":" 按键符号 图标 代码 图标 代码 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten ","date":"2020-03-26","objectID":"/emoji-support/:8:10","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#按键符号"},{"categories":["主题文档"],"content":" 字母符号 图标 代码 图标 代码 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 ","date":"2020-03-26","objectID":"/emoji-support/:8:11","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#字母符号"},{"categories":["主题文档"],"content":" 几何符号 图标 代码 图标 代码 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button ","date":"2020-03-26","objectID":"/emoji-support/:8:12","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#几何符号"},{"categories":["主题文档"],"content":" 其它符合 图标 代码 图标 代码 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2020-03-26","objectID":"/emoji-support/:8:13","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#其它符合"},{"categories":["主题文档"],"content":" 旗帜","date":"2020-03-26","objectID":"/emoji-support/:9:0","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#旗帜"},{"categories":["主题文档"],"content":" 常用旗帜 图标 代码 图标 代码 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳 white_flag 🏳️‍🌈 rainbow_flag ","date":"2020-03-26","objectID":"/emoji-support/:9:1","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#常用旗帜"},{"categories":["主题文档"],"content":" 国家和地区旗帜 图标 代码 图标 代码 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2020-03-26","objectID":"/emoji-support/:9:2","series":null,"tags":["hugo","DoIt","主题文档","emoji"],"title":"Emoji 支持","uri":"/emoji-support/#国家和地区旗帜"},{"categories":["主题文档"],"content":"DoIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode.","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/"},{"categories":["主题文档"],"content":"DoIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:0:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#"},{"categories":["主题文档"],"content":" style 注意 Hugo extended 版本对于 style shortcode 是必需的. style shortcode 用来在你的文章中插入自定义样式. style shortcode 有两个位置参数. 第一个参数是自定义样式的内容. 它支持  SASS 中的嵌套语法, 并且 \u0026 指代这个父元素. 第二个参数是包裹你要更改样式的内容的 HTML 标签, 默认值是 div. 一个 style 示例: {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈现的输出效果如下: This is a right-aligned paragraph. ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:1:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#style"},{"categories":["主题文档"],"content":" link link shortcode 是 Markdown 链接语法 的替代. link shortcode 可以提供一些其它的功能并且可以在代码块中使用. 支持本地资源引用的完整用法. link shortcode 有以下命名参数: href [必需] (第一个位置参数) 链接的目标. content [可选] (第二个位置参数) 链接的内容, 默认值是 href 参数的值. 支持 Markdown 或者 HTML 格式. title [可选] (第三个位置参数) HTML a 标签 的 title 属性, 当悬停在链接上会显示的提示. rel [可选] HTML a 标签 的 rel 补充属性. class [可选] HTML a 标签 的 class 属性. 一个 link 示例: {{\u003c link \"https://assemble.io\" \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" \u003e}} {{\u003c link \"mailto:contact@revolunet.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@revolunet.com\" \u003e}} {{\u003c link \"https://assemble.io\" Assemble \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" content=Assemble \u003e}} 呈现的输出效果如下: https://assemble.io mailto:contact@revolunet.com Assemble 一个带有标题的 link 示例: {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} 呈现的输出效果如下 (将鼠标悬停在链接上, 会有一行提示): Upstage ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:2:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#link"},{"categories":["主题文档"],"content":" image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lightgallery.js. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. 一个 image 示例: {{\u003c image src=\"/images/lighthouse.webp\" caption=\"Lighthouse (`image`)\" src_s=\"/images/lighthouse-small.webp\" src_l=\"/images/lighthouse-large.webp\" \u003e}} 呈现的输出效果如下: Lighthouse (image) ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:3:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#image"},{"categories":["主题文档"],"content":" admonitionadmonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 admonition shortcode 有以下命名参数: type [必需] (第一个位置参数) admonition 横幅的类型, 默认值是 note. title [可选] (第二个位置参数) admonition 横幅的标题, 默认值是 type 参数的值. open [可选] (第三个位置参数) 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip 一个 技巧 横幅 ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:4:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#admonition"},{"categories":["主题文档"],"content":" mermaidmermaid 是一个可以帮助你在文章中生成图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:5:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#mermaid"},{"categories":["主题文档"],"content":" 流程图一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}}graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:5:1","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#flowchart"},{"categories":["主题文档"],"content":" 时序图一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}}sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts prevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:5:2","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#sequence-diagram"},{"categories":["主题文档"],"content":" 甘特图一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}}gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:5:3","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#gantt"},{"categories":["主题文档"],"content":" 类图一个 类图 mermaid 示例: {{\u003c mermaid \u003e}}classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label {{\u003c /mermaid \u003e}} 呈现的输出效果如下: classDiagram Class01 \u003c|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u003e C2 : Where am i? Class09 --* C3 Class09 --|\u003e Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u003c--\u003e C2: Cool label ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:5:4","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#class-diagram"},{"categories":["主题文档"],"content":" 状态图一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}}stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: stateDiagram [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:5:5","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#state-diagram"},{"categories":["主题文档"],"content":" Git 图一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph commit branch hotfix checkout hotfix commit branch develop checkout develop commit id:\"ash\" tag:\"abc\" branch featureB checkout featureB commit type:HIGHLIGHT checkout main checkout hotfix commit type:NORMAL checkout develop commit type:REVERSE checkout featureB commit checkout main merge hotfix checkout featureB commit checkout develop branch featureA commit checkout develop merge hotfix checkout featureA commit checkout featureB commit checkout develop merge featureA branch release checkout release commit checkout main commit checkout release merge main checkout develop merge release {{\u003c /mermaid \u003e}} 呈现的输出效果如下: gitGraph commit branch hotfix checkout hotfix commit branch develop checkout develop commit id:\"ash\" tag:\"abc\" branch featureB checkout featureB commit type:HIGHLIGHT checkout main checkout hotfix commit type:NORMAL checkout develop commit type:REVERSE checkout featureB commit checkout main merge hotfix checkout featureB commit checkout develop branch featureA commit checkout develop merge hotfix checkout featureA commit checkout featureB commit checkout develop merge featureA branch release checkout release commit checkout main commit checkout release merge main checkout develop merge release ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:5:6","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#git-graph"},{"categories":["主题文档"],"content":" 饼图一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}}pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:5:7","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#pie"},{"categories":["主题文档"],"content":" echartsECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. 一个 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": { \"text\": \"折线统计图\", \"top\": \"2%\", \"left\": \"center\" }, \"tooltip\": { \"trigger\": \"axis\" }, \"legend\": { \"data\": [\"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\"], \"top\": \"10%\" }, \"grid\": { \"left\": \"5%\", \"right\": \"5%\", \"bottom\": \"5%\", \"top\": \"20%\", \"containLabel\": true }, \"toolbox\": { \"feature\": { \"saveAsImage\": { \"title\": \"保存为图片\" } } }, \"xAxis\": { \"type\": \"category\", \"boundaryGap\": false, \"data\": [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] }, \"yAxis\": { \"type\": \"value\" }, \"series\": [ { \"name\": \"邮件营销\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [120, 132, 101, 134, 90, 230, 210] }, { \"name\": \"联盟广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [220, 182, 191, 234, 290, 330, 310] }, { \"name\": \"视频广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [150, 232, 201, 154, 190, 330, 410] }, { \"name\": \"直接访问\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [320, 332, 301, 334, 390, 330, 320] }, { \"name\": \"搜索引擎\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [820, 932, 901, 934, 1290, 1330, 1320] } ] } {{\u003c /echarts \u003e}} 一个 YAML 格式的 echarts 示例: {{\u003c echarts \u003e}} title: text: 折线统计图 top: 2% left: center tooltip: trigger: axis legend: data: - 邮件营销 - 联盟广告 - 视频广告 - 直接访问 - 搜索引擎 top: 10% grid: left: 5% right: 5% bottom: 5% top: 20% containLabel: true toolbox: feature: saveAsImage: title: 保存为图片 xAxis: type: category boundaryGap: false data: - 周一 - 周二 - 周三 - 周四 - 周五 - 周六 - 周日 yAxis: type: value series: - name: 邮件营销 type: line stack: 总量 data: - 120 - 132 - 101 - 134 - 90 - 230 - 210 - name: 联盟广告 type: line stack: 总量 data: - 220 - 182 - 191 - 234 - 290 - 330 - 310 - name: 视频广告 type: line stack: 总量 data: - 150 - 232 - 201 - 154 - 190 - 330 - 410 - name: 直接访问 type: line stack: 总量 data: - 320 - 332 - 301 - 334 - 390 - 330 - 320 - name: 搜索引擎 type: line stack: 总量 data: - 820 - 932 - 901 - 934 - 1290 - 1330 - 1320 {{\u003c /echarts \u003e}} 一个 TOML 格式的 echarts 示例: {{\u003c echarts \u003e}} [title] text = \"折线统计图\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存为图片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"邮件营销\" type = \"line\" stack = \"总量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"联盟广告\" type = \"line\" stack = \"总量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"视频广告\" type = \"line\" stack = \"总量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接访问\" type = \"line\" stack = \"总量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"总量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈现的输出效果如下: echarts shortcode 还有以下命名参数: width [可选] (第一个位置参数) 数据可视化的宽度, 默认值是 100%. height [可选] (第二个位置参数) 数据可视化的高度, 默认值是 30rem. ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:6:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#echarts"},{"categories":["主题文档"],"content":" mapbox Mapbox GL JS 是一个 JavaScript 库, 它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. 一个简单的 mapbox 示例: {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} 呈现的输出效果如下: 一个带有自定义样式的 mapbox 示例: {{\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 或者 {{\u003c mapbox lng=-122.252 lat=37.453 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:7:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#mapbox"},{"categories":["主题文档"],"content":" musicmusic shortcode 基于 APlayer 和 MetingJS 提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:8:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#music"},{"categories":["主题文档"],"content":" 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"/images/Wavelength.webp\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:8:1","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#custom-music-url"},{"categories":["主题文档"],"content":" 音乐平台 URL 的自动识别music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:8:2","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#automatic-identification"},{"categories":["主题文档"],"content":" 自定义音乐平台, 类型和 IDmusic shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:8:3","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#custom-server"},{"categories":["主题文档"],"content":" 其它参数music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #448aff. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选] [all, one, none] 音乐列表的循环模式, 默认值是 none. order [可选] [list, random] 音乐列表的播放顺序, 默认值是 list. list-folded [可选] 初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选] 音乐列表的最大高度, 默认值是 340px. ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:8:4","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#other-parameters"},{"categories":["主题文档"],"content":" aplayer and audio 如果你需要针对音乐播放器的更多自定义选项（如自定义歌单，迷你模式，自定义音乐类型以及更多…），你可以使用 aplayer shortcode 配合 audio shortcode 以发挥 APlayer.js 的全部功能。 aplayer shortcode 用于创建一个 APlayer 播放器实例，audio shortcode 则用于设置音乐文件的相关信息。请查看 APlayer.js 的文档 来了解所有的可配置项。 一个 aplayer 和 audio 的示例： {{\u003c aplayer fixed=false mini=false autoplay=false theme=\"#b7daff\" loop=\"all\" order=\"list\" preload=\"auto\" volume=0.7 mutex=true lrcType=1 listFolded=false listMaxHeight=\"\" storageName=\"aplayer-setting\" \u003e}} {{\u003c audio name=\"Wavelength\" artist=\"oldmanyoung\" url=\"/music/Wavelength.mp3\" cover=\"/images/Wavelength.webp\" /\u003e}} {{\u003c audio name=\"Wavelength\" artist=\"oldmanyoung\" url=\"/music/Wavelength.mp3\" cover=\"/images/Wavelength.webp\" \u003e}} [00:00.00]APlayer audio1 [00:04.01]is [00:08.02]amazing {{\u003c /audio \u003e}} {{\u003c /aplayer \u003e}} 呈现的输出效果如下： 需要注意的是，这两个 shortcodes 并不能单独使用，并且必须使用命名参数来设置它们的属性。 如果你将 LRC 放置于 audio shortcode 之中，它会通过 JS 字符串方式传递给 APlayer，所以你需要将 lrcType 设置为 1。如果你通过配置 lrc 参数的方式来设置 LRC 文件的链接，那么它将会被通过 LRC 文件方式传递给 APlayer，则 lrcType 需要被设置为 3。 ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:9:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#aplayer-and-audio"},{"categories":["主题文档"],"content":" bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一个 bilibili 示例: {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} 呈现的输出效果如下: 如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.com/video/BV1TJ411C7An?p=3 一个带有 p 参数的 bilibili 示例: {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:10:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#bilibili"},{"categories":["主题文档"],"content":" typeittypeit shortcode 基于 TypeIt 提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:11:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#typeit"},{"categories":["主题文档"],"content":" 简单内容允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:11:1","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#simple-content"},{"categories":["主题文档"],"content":" 简单内容允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:11:1","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#id-6 class="},{"categories":["主题文档"],"content":" 代码内容代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:11:2","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#code-content"},{"categories":["主题文档"],"content":" 分组内容默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:11:3","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#code-content"},{"categories":["主题文档"],"content":" script script shortcode 用来在你的文章中插入  Javascript 脚本. 注意 脚本内容可以保证在所有的第三方库加载之后按顺序执行. 所以你可以自由地使用第三方库. 一个 script 示例: {{\u003c script \u003e}} console.log('Just DoIt!'); {{\u003c /script \u003e}} 你可以在开发者工具的控制台中看到输出. ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:12:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#script"},{"categories":["主题文档"],"content":" friend friend shortcode 用来在你的页面上插入友链. friend shortcode 有以下命名参数: name [必需] (第一个位置参数) 友站的名称. url [必需] (第二个位置参数) 友站的链接. avatar [必需] (第三个位置参数) 友站的头像. bio [必需] (第四个位置参数) 友站的简介. 一个 friend 示例: {{\u003c friend \"PCloud\" \"https://github.com/HEIGE-PCloud/\" \"https://avatars.githubusercontent.com/u/52968553?v=4\" \"This is PCloud~💤\" \u003e}} 或者 {{\u003c friend name=\"PCloud\" url=\"https://github.com/HEIGE-PCloud/\" avatar=\"https://avatars.githubusercontent.com/u/52968553?v=4\" bio=\"This is PCloud~💤\" \u003e}} 呈现的输出效果如下: PCloud This is PCloud~💤 ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:13:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#friend"},{"categories":["主题文档"],"content":" showcase showcase 用于在页面上插入一个个人项目的展示柜. showcase shortcode 有以下命名参数: title [required] (第一个位置参数) 项目名称. summary [required] (第二个位置参数) 项目简介. image [required] (第三个位置参数) 预览图的链接. link [required] (第四个位置参数) 项目主页的链接. column [optional] (fifth positional parameter) 这个参数定义一行显示几个 showcase. 默认的值是 2, 默认一行显示两个 showcase. 你可以将它改为 1, 2 或 3. 需要注意的是, 当用户使用小屏幕访问网站时, 每行显示的 showcase 数量将会被自动调整以保证最好的体验. 一个 showcase 示例: {{\u003c showcase title=\"Theme Documentation - Basics\" summary=\"Discover what the Hugo - DoIt theme is all about and the core-concepts behind it.\" image=\"/theme-documentation-basics/featured-image.webp\" link=\"/theme-documentation-basics\" \u003e}} Or {{\u003c showcase \"Theme Documentation - Basics\" \"Discover what the Hugo - DoIt theme is all about and the core-concepts behind it.\" \"/theme-documentation-basics/featured-image.webp\" \"/theme-documentation-basics\" \u003e}} 呈现的输出效果如下: 主题文档 - 基本概念 探索 Hugo - DoIt 主题的全部内容和背后的核心概念. 阅读全文 ","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:14:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#showcase"},{"categories":["主题文档"],"content":" math math 用于插入数学公式. 它可以阻止 Goldmark 将数学表达式中的特殊字符解析为 HTML 从而避免很多问题. 在 math 中, 你不再需要转义特殊字符. 一个 math 示例: {{\u003c math \u003e}}$\\|\\boldsymbol{x}\\|_{0}=\\sqrt[0]{\\sum_{i} x_{i}^{0}}${{\u003c /math \u003e}} Or {{\u003c math \u003e}} $$\\|\\boldsymbol{x}\\|_{0}=\\sqrt[0]{\\sum_{i} x_{i}^{0}}$$ {{\u003c /math \u003e}} 呈现的输出效果如下: $\\|\\boldsymbol{x}\\|_{0}=\\sqrt[0]{\\sum_{i} x_{i}^{0}}$ $$\\|\\boldsymbol{x}\\|_{0}=\\sqrt[0]{\\sum_{i} x_{i}^{0}}$$","date":"2020-03-06","objectID":"/theme-documentation-extended-shortcodes/:15:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/theme-documentation-extended-shortcodes/#math"},{"categories":["主题文档"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁.","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/"},{"categories":["主题文档"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. Hugo 使用 Markdown 为其简单的内容格式. 但是, Markdown 在很多方面都无法很好地支持. 你可以使用纯 HTML 来扩展可能性. 但这恰好是一个坏主意. 大家使用 Markdown, 正是因为它即使不经过渲染也可以轻松阅读. 应该尽可能避免使用 HTML 以保持内容简洁. 为了避免这种限制, Hugo 创建了 shortcodes. shortcode 是一个简单代码段, 可以生成合理的 HTML 代码, 并且符合 Markdown 的设计哲学. Hugo 附带了一组预定义的 shortcodes, 它们实现了一些非常常见的用法. 提供这些 shortcodes 是为了方便保持你的 Markdown 内容简洁. ","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/:0:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/#"},{"categories":["主题文档"],"content":" figurefigure 的文档 一个 figure 示例: {{\u003c figure src=\"/images/lighthouse.webp\" title=\"Lighthouse (figure)\" \u003e}} 呈现的输出效果如下: Lighthouse (figure) 输出的 HTML 看起来像这样: \u003cfigure\u003e \u003cimg src=\"/images/lighthouse.webp\"/\u003e \u003cfigcaption\u003e \u003ch4\u003eLighthouse (figure)\u003c/h4\u003e \u003c/figcaption\u003e \u003c/figure\u003e ","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/:1:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/#figure"},{"categories":["主题文档"],"content":" gistgist 的文档 一个 gist 示例: {{\u003c gist spf13 7896402 \u003e}} 呈现的输出效果如下: 输出的 HTML 看起来像这样: \u003cscript type=\"application/javascript\" src=\"https://gist.github.com/spf13/7896402.js\"\u003e\u003c/script\u003e ","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/:2:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/#gist"},{"categories":["主题文档"],"content":" highlighthighlight 的文档 一个 highlight 示例: {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} 呈现的输出效果如下: \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e ","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/:3:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/#highlight"},{"categories":["主题文档"],"content":" paramparam 的文档 一个 param 示例: {{\u003c param description \u003e}} 呈现的输出效果如下: Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. ","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/:4:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/#param"},{"categories":["主题文档"],"content":" ref 和 relrefref 和 relref 的文档 ","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/:5:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/#ref-and-relref"},{"categories":["主题文档"],"content":" tweettweet 的文档 一个 tweet 示例: {{\u003c tweet user=\"SanDiegoZoo\" id=\"1453110110599868418\" \u003e}} ","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/:6:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/#tweet"},{"categories":["主题文档"],"content":" vimeovimeo 的文档 一个 vimeo 示例: {{\u003c vimeo 146022717 \u003e}} 呈现的输出效果如下: ","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/:7:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/#vimeo"},{"categories":["主题文档"],"content":" youtubeDocumentation of youtube Example youtube input: {{\u003c youtube w7Ft2ymGmfc \u003e}} The rendered output looks like this: ","date":"2020-03-05","objectID":"/theme-documentation-built-in-shortcodes/:8:0","series":null,"tags":["hugo","DoIt","主题文档","shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/theme-documentation-built-in-shortcodes/#youtube"},{"categories":["主题文档"],"content":"了解如何在 DoIt 主题中快速, 直观地创建和组织内容.","date":"2020-03-04","objectID":"/theme-documentation-content/","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/"},{"categories":["主题文档"],"content":"了解如何在 DoIt 主题中快速, 直观地创建和组织内容. ","date":"2020-03-04","objectID":"/theme-documentation-content/:0:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#"},{"categories":["主题文档"],"content":" 内容组织以下是一些方便你清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 本地资源引用 有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. 引用的优先级符合以上的顺序. 在这个主题中的很多地方可以使用上面的本地资源引用, 例如 链接, 图片, image shortcode, music shortcode 和前置参数中的部分参数. 页面资源或者 assets 目录中的图片处理会在未来的版本中得到支持. 非常酷的功能! ","date":"2020-03-04","objectID":"/theme-documentation-content/:1:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#contents-organization"},{"categories":["主题文档"],"content":" 作者配置我们鼓励你在 mysite/data/authors 下创建你的作者个人资料 author_name.toml. 在你的资料中, 你可以添加个人链接, 邮箱, 以及支持 i18n 的姓名. 以下是 Alice.toml 的示例: link = \"https://alice.example.com\" email = \"alice@example.com\" name = \"Alice\" [zh-cn] name = \"爱丽丝\" 在创建作者个人资料后, 您可以在文章的前置参数中指定您的姓名. 之后, 该文章将自动著上你的名字, 并可以根据作者进行分类. --- authors: [Alice] --- 您也可以为一篇文章注明多个作者. --- authors: [Alice, Bob, Catherine] --- ","date":"2020-03-04","objectID":"/theme-documentation-content/:2:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#author-setup"},{"categories":["主题文档"],"content":" 前置参数Hugo 允许你在文章内容前面添加 yaml, toml 或者 json 格式的前置参数. 注意 不是所有的以下前置参数都必须在你的每篇文章中设置. 只有在文章的参数和你的 网站设置 中的 page 部分不一致时才有必要这么做. 这是一个前置参数例子: --- title: \"我的第一篇文章\" subtitle: \"\" date: 2020-03-04T15:58:26+08:00 lastmod: 2020-03-04T15:58:26+08:00 draft: true authors: [] description: \"\" license: \"\" images: [] tags: [] categories: [] series: [] series_weight: 1 seriesNavigation: true featuredImage: \"\" featuredImagePreview: \"\" hiddenFromHomePage: false hiddenFromSearch: false twemoji: false lightgallery: true ruby: true fraction: true fontawesome: true linkToMarkdown: true linkToSource: false linkToEdit: false linkToReport: false rssFullText: false license: '' toc: enable: true auto: true code: copy: true # ... table: sort: true # ... math: enable: true # ... mapbox: accessToken: \"\" # ... share: enable: true # ... comment: enable: true # ... library: css: # someCSS = \"some.css\" # 位于 \"assets/\" # 或者 # someCSS = \"https://cdn.example.com/some.css\" js: # someJS = \"some.js\" # 位于 \"assets/\" # 或者 # someJS = \"https://cdn.example.com/some.js\" seo: images: [] # ... outdatedArticleReminder: enable: false # ... sponsor: enable: false # ... related: enable: false count: 5 --- title: 文章标题. subtitle: 文章副标题. date: 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置. lastmod: 上次修改内容的日期时间. draft: 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染. authors: 文章作者. description: 文章内容的描述. license: 这篇文章特殊的许可. images: 页面图片, 用于 Open Graph 和 Twitter Cards. tags: 文章的标签. categories: 文章所属的类别. series: 文章所属的系列. series_weight: 自定义文章在系列中的位置. seriesNavigation: 是否使用系列导航. featuredImage: 文章的特色图片. featuredImagePreview: 用在主页预览的文章特色图片. hiddenFromHomePage: 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: 如果设为 true, 这篇文章会使用 twemoji. lightgallery: 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: 如果设为 true, 这篇文章会使用 分数扩展语法. fontawesome: 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法. linkToMarkdown: 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. linkToSource: 如果设为 false, 则关闭页脚 view source 的链接. 你可以将其设置为一个指向文章原始文件的链接. 使用魔法变量 {path} 来获取文章的相对路径, 这篇文章的 {path} 是 posts/theme-documentation-content/index.en.md. linkToEdit: 如果设为 false, 则关闭页脚 编辑此页 的链接. 你可以将其设置为一个用于编辑这个页面的链接. 使用魔法变量 {path} 来获取这篇文章的相对路径, 这篇文章的 {path} 是 posts/theme-documentation-content/index.zh-cn.md. linkToReport: 如果设为 false, 则关闭页脚 报告问题 的链接. 你可以将其设置为一个用于报告此页面中错误的链接. 使用魔法变量 {path} 来获取文章的相对路径, 这篇文章的 {path} 是 posts/theme-documentation-content/index.en.md, 使用 {title} 来获取文章的标题, 这篇文章的 {title} 为 Theme Documentation - Content, 使用 {url} 来获取文章的链接, 这篇文章的 {url} 为 https://hugodoit.pages.dev/theme-documentation-content/. rssFullText: 如果设为 true, 在 RSS 中将会显示全文内容. enableLastMod: 如果设为 true，在文章的顶部将会显示上次修改内容的日期时间. enableWordCount: 如果设为 true, 在文章的顶部将会显示文章的字数. enableReadingTime: 如果设为 true, 在文章的顶部将会显示文章的阅读时间. license: 许可协议信息 (支持 HTML 格式). toc: 和 网站配置 中的 params.page.toc 部分相同. code: 和 网站配置 中的 params.page.code 部分相同. table: 和 网站配置 中的 params.page.table 部分相同. math: 和 网站配置 中的 params.page.math 部分相同. mapbox: 和 网站配置 中的 params.page.mapbox 部分相同. share: 和 网站配置 中的 params.page.share 部分相同. comment: 和 网站配置 中的 params.page.comment 部分相同. library: 和 网站配置 中的 params.page.library 部分相同. seo: 和 网站配置 中的 params.page.seo 部分相同. outdatedArticleReminder: 和 网站配置 中的 params.page.outdatedArticleReminder 部分相同. sponsor: 和 网站配置 中的 params.sponsor 部分相同. related: 和 网站配置 中的 params.page.related 部分相同. 技巧 featuredImage 和 featuredImagePreview 支持本地资源引用的完整用法. 如果带有在前置参数中设置了 name: featured-image 或 name: featured-image-preview 属性的页面资源, 没有必要在设置 featuredImage 或 featuredImagePreview: resources: - name: featured-image src: featured-image.jpg - name: featured-image-preview src: featured-image-preview.jpg ","date":"2020-03-04","objectID":"/theme-documentation-content/:3:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#front-matter"},{"categories":["主题文档"],"content":" 内容摘要DoIt 主题使用内容摘要在主页中显示大致文章信息. Hugo 支持生成文章的摘要. 文章摘要预览 ","date":"2020-03-04","objectID":"/theme-documentation-content/:4:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#内容摘要"},{"categories":["主题文档"],"content":" 自动摘要拆分默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能, 请在 网站配置 中将 hasCJKLanguage 设置为 true. ","date":"2020-03-04","objectID":"/theme-documentation-content/:4:1","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#自动摘要拆分"},{"categories":["主题文档"],"content":" 手动摘要拆分另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. 注意 请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格. ","date":"2020-03-04","objectID":"/theme-documentation-content/:4:2","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#手动摘要拆分"},{"categories":["主题文档"],"content":" 前置参数摘要你可能希望摘要不是文章开头的文字. 在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要. ","date":"2020-03-04","objectID":"/theme-documentation-content/:4:3","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#前置参数摘要"},{"categories":["主题文档"],"content":" 使用文章描述作为摘要你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 DoIt 主题会将你的文章描述作为摘要. ","date":"2020-03-04","objectID":"/theme-documentation-content/:4:4","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#使用文章描述作为摘要"},{"categories":["主题文档"],"content":" 摘要选择的优先级顺序由于可以通过多种方式指定摘要, 因此了解顺序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前没有内容, 则使用描述作为摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 则将按照手动摘要拆分的方法获得摘要. 如果文章前置参数中有摘要变量, 那么将以该值作为摘要. 按照自动摘要拆分方法. 注意 不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等. ","date":"2020-03-04","objectID":"/theme-documentation-content/:4:5","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#摘要选择的优先级顺序"},{"categories":["主题文档"],"content":" Markdown 基本语法这部分内容在 Markdown 基本语法页面 中介绍. ","date":"2020-03-04","objectID":"/theme-documentation-content/:5:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#markdown-基本语法"},{"categories":["主题文档"],"content":" Markdown 扩展语法DoIt 主题提供了一些扩展的语法便于你撰写文章. ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#extended-markdown-syntax"},{"categories":["主题文档"],"content":" Emoji 支持这部分内容在 Emoji 支持页面 中介绍. ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:1","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#emoji-支持"},{"categories":["主题文档"],"content":" 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 公式块默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 行内公式默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. 信息 你可以使用 math shortcode 以避免特殊字符造成问题. Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:2","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#数学公式"},{"categories":["主题文档"],"content":" 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 公式块默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 行内公式默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. 信息 你可以使用 math shortcode 以避免特殊字符造成问题. Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:2","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#公式块"},{"categories":["主题文档"],"content":" 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 公式块默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 行内公式默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. 信息 你可以使用 math shortcode 以避免特殊字符造成问题. Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:2","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#行内公式"},{"categories":["主题文档"],"content":" 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 公式块默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 行内公式默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. 信息 你可以使用 math shortcode 以避免特殊字符造成问题. Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:2","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#copy-tex"},{"categories":["主题文档"],"content":" 数学公式DoIt 基于 $ \\KaTeX $ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. 技巧 有一份 $ \\KaTeX $ 中支持的 $ \\TeX $ 函数 清单. 公式块默认的公式块分割符是 $$/$$ 和 \\\\[/\\\\]: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] 行内公式默认的行内公式分割符是 $/$ 和 \\\\(/\\\\): $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\\\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\) 呈现的输出效果如下: $ c = \\pm\\sqrt{a^2 + b^2} $ 和 \\( f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\) 技巧 你可以在 网站配置 中自定义公式块和行内公式的分割符. 信息 你可以使用 math shortcode 以避免特殊字符造成问题. Copy-texCopy-tex 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 在选择并复制 $ \\KaTeX $ 渲染的公式时, 会将其 $ \\LaTeX $ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 LaTeX 源代码. mhchemmhchem 是一个 $ \\KaTeX $ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:2","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#mhchem"},{"categories":["主题文档"],"content":" 字符注音或者注释DoIt 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:3","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#ruby"},{"categories":["主题文档"],"content":" 分数 DoIt 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:4","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#fraction"},{"categories":["主题文档"],"content":" Font AwesomeDoIt 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 去露营啦! :(fas fa-campground fa-fw): 很快就回来. 真开心! :(far fa-grin-tears): 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:5","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#fontawesome"},{"categories":["主题文档"],"content":" 转义字符在某些特殊情况下 (编写这个主题文档时 ), 你的文章内容会与 Markdown 的基本或者扩展语法冲突, 并且无法避免. 转义字符语法可以帮助你渲染出想要的内容: {?X} -\u003e X 例如, 两个 : 会启用 emoji 语法. 但有时候这不是你想要的结果. 可以像这样使用转义字符语法: {?:}joy: 呈现的输出效果如下: :joy: 而不是 😂 技巧 这个方法可以间接解决一个还未解决的 Hugo 的 issue. 另一个例子是: [link{?]}(#escape-character) 呈现的输出效果如下: [link](#escape-character) 而不是 link. ","date":"2020-03-04","objectID":"/theme-documentation-content/:6:6","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 内容","uri":"/theme-documentation-content/#escape-character"},{"categories":["主题文档"],"content":"探索 Hugo - DoIt 主题的全部内容和背后的核心概念.","date":"2020-03-03","objectID":"/theme-documentation-basics/","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/"},{"categories":["主题文档"],"content":"探索 Hugo - DoIt 主题的全部内容和背后的核心概念. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:0:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#"},{"categories":["主题文档"],"content":" 准备由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.83.0). 为什么不支持早期版本的 Hugo? 由于 WebP 图像处理 在 Hugo 0.83.0版本 中被引入, 本主题只支持高于 0.83.0 的 Hugo 版本. 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:1:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#准备"},{"categories":["主题文档"],"content":" 安装以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:2:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#安装"},{"categories":["主题文档"],"content":" 创建你的项目Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2020-03-03","objectID":"/theme-documentation-basics/:2:1","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#创建你的项目"},{"categories":["主题文档"],"content":" 安装主题DoIt 主题的仓库是: https://github.com/HEIGE-PCloud/DoIt. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/HEIGE-PCloud/DoIt.git themes/DoIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/HEIGE-PCloud/DoIt.git themes/DoIt ","date":"2020-03-03","objectID":"/theme-documentation-basics/:2:2","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#安装主题"},{"categories":["主题文档"],"content":" 基础配置以下是 DoIt 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"DoIt\" [params] # DoIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false 注意 在构建网站时, 你可以使用 --theme 选项设置主题. 但是, 我建议你修改配置文件 (config.toml) 将本主题设置为默认主题. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:2:3","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#basic-configuration"},{"categories":["主题文档"],"content":" 创建你的第一篇文章以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:2:4","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#创建你的第一篇文章"},{"categories":["主题文档"],"content":" 在本地启动网站使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览 技巧 当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新. 注意 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2020-03-03","objectID":"/theme-documentation-basics/:2:5","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#在本地启动网站"},{"categories":["主题文档"],"content":" 构建网站当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2020-03-03","objectID":"/theme-documentation-basics/:2:6","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#构建网站"},{"categories":["主题文档"],"content":" 配置","date":"2020-03-03","objectID":"/theme-documentation-basics/:3:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#配置"},{"categories":["主题文档"],"content":" 网站配置除了 Hugo 全局配置 和 菜单配置 之外, DoIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # DoIt 主题版本 version = \"0.3.X\" # 网站名称 title = \"我的全新 Hugo 网站\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"black\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径, 仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 开启 PWA 支持 enablePWA = false # [试验性功能] 缓存图床图片，详情请见：https://github.com/HEIGE-PCloud/DoIt/pull/860#issue-1574342372 cacheRemoteImages = false # 版权信息 license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"DoIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"algolia\", \"fuse\") type = \"fuse\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.search.fuse] # https://fusejs.io/api/options.html isCaseSensitive = false minMatchCharLength = 2 findAllMatches = false location = 0 threshold = 0.3 distance = 100 ignoreLocation = false useExtendedSearch = false ignoreFieldNorm = false # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 主题切换模式 # 主题切换模式 (\"switch\", \"select\") themeChangeMode = \"select\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 托管服务信息 (支持 HTML 格式) # \u003ca title=\"Github Pages\" href=\"https://docs.github.com/en/pages/\" target=\"_blank\" rel=\"noopener noreffer\"\u003eGitHub Pages\u003c/a\u003e hostedOn = '' # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息, 仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 最近更新文章设置 [params.section.recentlyUpdated] enable = false rss = false days = 30 maxCount = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱, 用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL # 将你的头像文件放置于 static 或者 assets 目录下 # 文件路径是相对于 static 或者 assets 目录的 avatarURL = \"/images/avatar.webp\" # 头像的链接指向的 URL avatarLinkURL = \"\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odno","date":"2020-03-03","objectID":"/theme-documentation-basics/:3:1","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#site-configuration"},{"categories":["主题文档"],"content":" 网站图标, 浏览器配置, 网站清单强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:3:2","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#网站图标-浏览器配置-网站清单"},{"categories":["主题文档"],"content":" 自定义样式 注意 Hugo extended 版本对于自定义样式是必需的. 通过定义自定义 .scss 样式文件, DoIt 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 assets/css. 在 assets/css/_override.scss 中, 你可以覆盖 themes/DoIt/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 assets/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:3:3","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#自定义样式"},{"categories":["主题文档"],"content":" 多语言和 i18nDoIt 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换 ","date":"2020-03-03","objectID":"/theme-documentation-basics/:4:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#多语言和-i18n"},{"categories":["主题文档"],"content":" 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 英语 en en 简体中文 zh-cn zh-CN 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl 俄语 ru ru 罗马尼亚语 ro ro 越南语 vi vi Arabic ar ar Catalan ca ca Hindi hi hi Indonesian id id Telugu te te Thai th th Turkish tr tr Ukrainian uk uk Traditional Chinese zh-tw zh-tw ","date":"2020-03-03","objectID":"/theme-documentation-basics/:4:1","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#language-compatibility"},{"categories":["主题文档"],"content":" 基本配置学习了 Hugo如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: # [en, zh-cn, fr, pl, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 然后, 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为两个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 注意 请注意, 菜单中仅显示翻译的页面. 它不会替换为默认语言内容. 技巧 也可以使用 文章前置参数 来翻译网址. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:4:2","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#基本配置"},{"categories":["主题文档"],"content":" 修改默认的翻译字符串翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件, 并从 themes/DoIt/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-03","objectID":"/theme-documentation-basics/:4:3","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#修改默认的翻译字符串"},{"categories":["主题文档"],"content":" 搜索 基于 Lunr.js 或 algolia, DoIt 主题支持搜索功能. ","date":"2020-03-03","objectID":"/theme-documentation-basics/:5:0","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#搜索"},{"categories":["主题文档"],"content":" 输出配置为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-03","objectID":"/theme-documentation-basics/:5:1","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#输出配置"},{"categories":["主题文档"],"content":" 搜索配置基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 (\"algolia\", \"fuse\") type = \"fuse\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.search.fuse] # https://fusejs.io/api/options.html isCaseSensitive = false minMatchCharLength = 2 findAllMatches = false location = 0 threshold = 0.3 distance = 100 ignoreLocation = false useExtendedSearch = false ignoreFieldNorm = false 怎样选择搜索引擎? 以下是两种搜索引擎的对比: fuse: 简单, 无需同步 index.json, 没有 contentLength 的限制, 性能高 algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 文章内容被 h2 和 h3 HTML 标签切分来提高查询效果并且基本实现全文搜索. contentLength 用来限制 h2 和 h3 HTML 标签开头的内容部分的最大长度. 关于 algolia 的使用技巧 你需要上传 index.json 到 algolia 来激活搜索功能. 你可以使用浏览器来上传 index.json 文件但是一个自动化的脚本可能效果更好. Algolia Atomic 是一个不错的选择. 为了兼容 Hugo 的多语言模式, 你需要上传不同语言的 index.json 文件到对应的 algolia index, 例如 zh-cn/index.json 或 fr/index.json… ","date":"2020-03-03","objectID":"/theme-documentation-basics/:5:2","series":null,"tags":["hugo","DoIt","主题文档"],"title":"主题文档 - 基本概念","uri":"/theme-documentation-basics/#搜索配置"},{"categories":["主题文档"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"/basic-markdown-syntax/","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["主题文档"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意 这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 DoIt 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧  将此页保存为书签, 以备将来参考! ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:0:0","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#"},{"categories":["主题文档"],"content":" 标题从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID 要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:1:0","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#标题"},{"categories":["主题文档"],"content":" 注释注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:2:0","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#注释"},{"categories":["主题文档"],"content":" 水平线HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:3:0","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#水平线"},{"categories":["主题文档"],"content":" 段落按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:4:0","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#段落"},{"categories":["主题文档"],"content":" 内联 HTML 元素如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:5:0","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#内联-html-元素"},{"categories":["主题文档"],"content":" 强调","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:0","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#强调"},{"categories":["主题文档"],"content":" 加粗用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:1","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#加粗"},{"categories":["主题文档"],"content":" 斜体用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:2","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#斜体"},{"categories":["主题文档"],"content":" 删除线按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:3","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#删除线"},{"categories":["主题文档"],"content":" 组合加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:4","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#组合"},{"categories":["主题文档"],"content":" 引用用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:7:0","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#引用"},{"categories":["主题文档"],"content":" 列表","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:0","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#列表"},{"categories":["主题文档"],"content":" 无序列表一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:1","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#无序列表"},{"categories":["主题文档"],"content":" 有序列表一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧 如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:2","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#有序列表"},{"categories":["主题文档"],"content":" 任务列表任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框, 请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:3","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#任务列表"},{"categories":["主题文档"],"content":" 代码","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:0","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#代码"},{"categories":["主题文档"],"content":" 行内代码用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:1","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#行内代码"},{"categories":["主题文档"],"content":" 缩进代码将几行代码缩进至少四个空格, 例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:2","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#缩进代码"},{"categories":["主题文档"],"content":" 围栏代码块使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:3","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#围栏代码块"},{"categories":["主题文档"],"content":" 语法高亮GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它, 只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意 Hugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:4","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#语法高亮"},{"categories":["主题文档"],"content":" 表格通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:10:0","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#表格"},{"categories":["主题文档"],"content":" 链接","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:0","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#links"},{"categories":["主题文档"],"content":" 基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上, 没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:1","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#基本链接"},{"categories":["主题文档"],"content":" 添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上, 会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:2","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#添加一个标题"},{"categories":["主题文档"],"content":" 定位标记定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意 定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:3","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#定位标记"},{"categories":["主题文档"],"content":" 脚注脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:12:0","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#脚注"},{"categories":["主题文档"],"content":" 图片图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The Stormtroopocat 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The Dojocat 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧 DoIt 主题提供了一个包含更多功能的 图片的 shortcode. 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:13:0","series":null,"tags":["hugo","DoIt","主题文档","Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/#图片"},{"categories":null,"content":" 我磊子 目前是一名程序猿 。 我只知道一件事，就是我一无所知。 ","date":"2019-08-02","objectID":"/about/:1:0","series":null,"tags":null,"title":"关于磊子","uri":"/about/#我"},{"categories":null,"content":" 兴趣爱好{% tabs tab-id %} 漫威的影视作品、X-Men 系列。 科幻类，例如：Interstellar、Prometheus、The Expanse、I, Robot、WALL·E 诺兰大导演的作品，例如：Inception、The Prestige 赵雷 周杰伦 云吸猫。 此外，也热衷于欣赏和学习这方面的知识：产品设计、科学。 {% endtabs %} ","date":"2019-08-02","objectID":"/about/:2:0","series":null,"tags":null,"title":"关于磊子","uri":"/about/#兴趣爱好"},{"categories":null,"content":" 关于本站本站是个人博客，不放置任何推广链接。内容以技术积累为主，也不排除会写一些生活方面或者其它主题的内容。随缘更新。 ","date":"2019-08-02","objectID":"/about/:3:0","series":null,"tags":null,"title":"关于磊子","uri":"/about/#关于本站"},{"categories":null,"content":" 联系方式 echo \"aHpsZWlpQG91dGxvb2suY29t\" | base64 -d ","date":"2019-08-02","objectID":"/about/:4:0","series":null,"tags":null,"title":"关于磊子","uri":"/about/#联系方式"},{"categories":["code"],"content":"CSS 重难点整理，包括元素类型、盒模型、选择器、布局等内容。","date":"2019-07-17","objectID":"/css/","series":["Weeb"],"tags":["Language"],"title":"CSS 知识总结","uri":"/css/"},{"categories":["code"],"content":" 行内元素与块元素行内元素： 和其它元素布局在同一行 宽高不可控，默认为内部文字或图片的宽度 内外边距横向有效，纵向可设置但无实际效果 只能容纳文本或其他行内元素 块元素： 在新行上开始 宽高内外边距可控，默认为全宽 可以容纳其他行内元素与块元素 ","date":"2019-07-17","objectID":"/css/:1:0","series":["Weeb"],"tags":["Language"],"title":"CSS 知识总结","uri":"/css/#行内元素与块元素"},{"categories":["code"],"content":" Box 模型 content-box：w3c 标准盒模型 (宽高不包括 padding 和 border) border-box：ie 盒模型 (怪异模型) (宽高包括 padding 和 border) ","date":"2019-07-17","objectID":"/css/:2:0","series":["Weeb"],"tags":["Language"],"title":"CSS 知识总结","uri":"/css/#box-模型"},{"categories":["code"],"content":" BFC 块格式上下文一个独立的容器，不受外部影响，不影响外部。 形成条件： 根元素 position 为 fixed 或 absolute float 浮动元素 (除了 none) overflow 为 hidden、auto 或 scroll display 为 inline-block 或 table-cell 等 display 为 flex、grid 的直接子元素 布局规则： 内部 box 在垂直方向顺序放置 同 BFC 内相邻 box 的 margin 会合并 BFC 区域不会与 float box 重叠 (传统的自适应两栏布局) ","date":"2019-07-17","objectID":"/css/:3:0","series":["Weeb"],"tags":["Language"],"title":"CSS 知识总结","uri":"/css/#bfc-块格式上下文"},{"categories":["code"],"content":" Flex 布局 flex: auto;：flex: 0 1 auto; flex: none;：flex: 0 0 auto; flex: 1;：flex: 1 1 0%; ","date":"2019-07-17","objectID":"/css/:4:0","series":["Weeb"],"tags":["Language"],"title":"CSS 知识总结","uri":"/css/#flex-布局"},{"categories":["code"],"content":" CSS 选择器","date":"2019-07-17","objectID":"/css/:5:0","series":["Weeb"],"tags":["Language"],"title":"CSS 知识总结","uri":"/css/#css-选择器"},{"categories":["code"],"content":" 伪类与伪元素 伪类：元素的特定状态，例如 :hover、:first-child 等选中的都是已经确实存在的元素，CSS3 指定使用单冒号 伪元素：原本并不在文档树中的元素，例如 ::before、:first-letter，如果不单独创建个 span 就无法直接选中 ，CSS3 标准要求使用双冒号，但兼容单冒号 ","date":"2019-07-17","objectID":"/css/:5:1","series":["Weeb"],"tags":["Language"],"title":"CSS 知识总结","uri":"/css/#伪类与伪元素"},{"categories":["code"],"content":" 运算符 后代选择器 div p：div 内所有的 p，包括嵌套下去在别的元素里的 子元素选择器 div\u003ep：div 内所有直接子元素 p，不包括嵌套下去的 相邻兄弟选择器 div+p：位于 div 后的第一个 p，同级，注意 div 不被选中 后续兄弟选择器 div~p：所有位于 div 后的 p，同级，注意 div 不被选中 ","date":"2019-07-17","objectID":"/css/:5:2","series":["Weeb"],"tags":["Language"],"title":"CSS 知识总结","uri":"/css/#运算符"},{"categories":["code"],"content":" 选择器优先级一个选择器的优先级由四个分量构成，每匹配一个规则各在对应位置上加一分： 千位：内联样式 百位：ID 选择器 十位：类选择器、伪类、属性选择器 个位：元素选择器、伪元素 选择器 权重 内容 h1 0001 元素选择器 h1 + p::first-letter 0003 2 元素选择器 + 1 伪元素 li \u003e a[href*=\"en-US\"] \u003e .inline-warning 0022 2 元素 + 1 属性选择器 + 1 类 #ident 0100 1 ID 选择器 覆盖 !important 唯一的办法就是另一个 !important 具有相同优先级而且顺序靠后，或者更高优先级。 ","date":"2019-07-17","objectID":"/css/:5:3","series":["Weeb"],"tags":["Language"],"title":"CSS 知识总结","uri":"/css/#选择器优先级"},{"categories":["code"],"content":" 百分比参照 position: absolute：最后一个已定位的父元素 border-radius：自身 ","date":"2019-07-17","objectID":"/css/:6:0","series":["Weeb"],"tags":["Language"],"title":"CSS 知识总结","uri":"/css/#百分比参照"},{"categories":["code"],"content":" BEM 命名法 .block, .block__element, .block--modifier { } block：某个元素或组件 block__element：block 的后代，是完整 block 的一部分 block--modifier：block 的不同状态或不同版本 可以配合 CSS Module 使用将类名进行 HASH。 ","date":"2019-07-17","objectID":"/css/:7:0","series":["Weeb"],"tags":["Language"],"title":"CSS 知识总结","uri":"/css/#bem-命名法"},{"categories":["code"],"content":"前端应用笔记，包括前端安全、性能优化、移动兼容等内容。","date":"2019-07-17","objectID":"/front-end/","series":["Weeb"],"tags":["Language"],"title":"Front End","uri":"/front-end/"},{"categories":["code"],"content":" CSRF 和 XSS 攻击","date":"2019-07-17","objectID":"/front-end/:1:0","series":["Weeb"],"tags":["Language"],"title":"Front End","uri":"/front-end/#csrf-和-xss-攻击"},{"categories":["code"],"content":" CSRF 跨站请求伪造 用户访问并登陆 a.org a.org 生成并返回 Cookie 给用户 用户访问 b.org，其中有指向 a.org 的图片、链接和表单等 授权 Cookie 被发送给 a.org，造成影响 防御方法： 简易：Referrer 检查 (不可靠) 服务端生成并保存 Token，写入 DOM，客户端发起请求时携带 服务端生成 Token 不保存，写入 DOM 和 Cookie，客户端请求时携带二者，服务端比对 客户端生成 Token，写入 DOM 和 Cookie，请求时携带二者，服务端比对 JWT (一旦签发过期前永远有效)： 服务器认证后，返回含有用户信息的 JSON 对象 客户端每次请求都发送该对象用于验证 ","date":"2019-07-17","objectID":"/front-end/:1:1","series":["Weeb"],"tags":["Language"],"title":"Front End","uri":"/front-end/#csrf-跨站请求伪造"},{"categories":["code"],"content":" XSS 跨站脚本利用对用户输入没有限制的漏洞，获取到跨站脚本，在脚本中发起带有 Cookie 的请求给恶意站点。 ","date":"2019-07-17","objectID":"/front-end/:1:2","series":["Weeb"],"tags":["Language"],"title":"Front End","uri":"/front-end/#xss-跨站脚本"},{"categories":["code"],"content":" 相关 Cookie 字段 SameSite: Lax 为现代浏览器的默认值，只允许第一方链接及第三方 GET 请求；Strict 仅允许第一方；None 传统允许跨域。 HttpOnly：JS 中无法获取 ","date":"2019-07-17","objectID":"/front-end/:1:3","series":["Weeb"],"tags":["Language"],"title":"Front End","uri":"/front-end/#相关-cookie-字段"},{"categories":["code"],"content":" 性能优化","date":"2019-07-17","objectID":"/front-end/:2:0","series":["Weeb"],"tags":["Language"],"title":"Front End","uri":"/front-end/#性能优化"},{"categories":["code"],"content":" 指标 FCP - First Contentful Paint：第一个元素被渲染 LCP - Largest Contentful Paint：可见最大元素被渲染 FID - First Input Delay：第一次交互到响应 TTI - Time to Interactive：所有元素被加载完成 TBT - Total Blocking Time：FCP 到 TTI 之间阻塞时间的总长 ","date":"2019-07-17","objectID":"/front-end/:2:1","series":["Weeb"],"tags":["Language"],"title":"Front End","uri":"/front-end/#指标"},{"categories":["code"],"content":" 网络 减少 HTTP 请求：合并资源文件，小图片内联，雪碧图 (background-position) 等 (这里暂不考虑 HTTP/2) 减小资源体积：gzip (服务器) ，webp 图片 (picture 和 srcset) 缓存：CDN 缓存，HTTP 缓存 (Cache-Control，Last-Modified，Etag 304) ，Service Worker (拦截 HTTP 请求) ","date":"2019-07-17","objectID":"/front-end/:2:2","series":["Weeb"],"tags":["Language"],"title":"Front End","uri":"/front-end/#网络"},{"categories":["code"],"content":" HTTP/2 服务端推送：PUSH 方法；例如请求 .html 时服务端主动尝试返回 .css 和 .js 等资源 多路复用：尝试将多个 HTTP 请求合并一起发送；在 HTTP/1.1 中，keep-alive 可以使 TCP 连接保持打开，但数据传输依旧是 请求 A =\u003e 响应 A =\u003e 请求 B =\u003e 响应 B 的模式，而在 HTTP/2 中，就可以实现 请求 A 和 B =\u003e 响应 A 和 B；在使用 HTTP/2 的情况下，“减少 HTTP 请求” 这类的性能优化并不一定在所有情况下都能有效 首部压缩：HTTP 头压缩和复用等 二进制分帧：将信息分割为更小的帧，并对它们采用二进制编码，其中例如 HTTP 头会被封装到 Headers 帧 ","date":"2019-07-17","objectID":"/front-end/:2:3","series":["Weeb"],"tags":["Language"],"title":"Front End","uri":"/front-end/#http2"},{"categories":["code"],"content":" DOM 与渲染 基础内容：头部 CSS (异步) ，JS 的 async 与 defer DOM 操作：减少大规模 DOM 操作，使用 class 修改样式，使用 CSS 动画和 requestAnimationFrame 事件代理：列表内每个元素设置一个事件 vs 整个列表设置事件 (可冒泡) ","date":"2019-07-17","objectID":"/front-end/:2:4","series":["Weeb"],"tags":["Language"],"title":"Front End","uri":"/front-end/#dom-与渲染"},{"categories":["code"],"content":" 移动 Web 开发","date":"2019-07-17","objectID":"/front-end/:3:0","series":["Weeb"],"tags":["Language"],"title":"Front End","uri":"/front-end/#移动-web-开发"},{"categories":["code"],"content":" 兼容移动端浏览器的碎片化比桌面端严重，设备之间的差距也很大，很多系统内置 WebView 的更新不及时，因此要注意新特性的兼容。 个人使用 Modernizr 检测兼容性问题，视情况引入 polyfill；原生新特性可以利用 Babel 转译。 ","date":"2019-07-17","objectID":"/front-end/:3:1","series":["Weeb"],"tags":["Language"],"title":"Front End","uri":"/front-end/#兼容"},{"categories":["code"],"content":" 性能移动端性能相对来说一定是较差的，不仅仅针对于移动端，类似减少大规模 DOM 操作、小图片的 base64 内联和 lazyload 之类都是有效果的。 ","date":"2019-07-17","objectID":"/front-end/:3:2","series":["Weeb"],"tags":["Language"],"title":"Front End","uri":"/front-end/#性能"},{"categories":["code"],"content":" 像素 px：CSS 内的 px，浏览器使用的单位 (例如：320x568) 物理像素：设备屏幕本身像素 (例如：640x1136) DPR：设备像素缩放比 (1px = DPR^2 x dp，例如当 DPR=2 时，一个 CSS 像素等于四个物理像素) 因此在这种情况下，直接指定 1px CSS 边框实际是 2px 物理像素的边框。 PPI：一般单位英寸像素密度较高 同时，各个设备的 viewport 定义一般不同，因此一般手动指定 viewport 宽度为设备宽度： \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e 两种设计模式： 直接根据计算出的 CSS 像素进行设计，比如上文的 320x568 DPR=2，缩放比设为 0.5，根据设备物理像素进行设计 对于边框问题： 利用 CSS Media Query 检查 -webkit-min-device-pixel-ratio，设置小数边框 (兼容性问题) 利用 JS 检查 DPR 动态设置 viewport meta 头里的缩放 (initial-scale) 和根元素上的字体大小；这个方案需要全局使用 rem 单位，适合新项目 利用图片，border-image 或 background-image transform: scale(0.5)，比例利用 CSS Media Query 检查 ","date":"2019-07-17","objectID":"/front-end/:3:3","series":["Weeb"],"tags":["Language"],"title":"Front End","uri":"/front-end/#像素"},{"categories":["code"],"content":" 交互为了触屏操作而产生的 300 毫秒问题，普通网页一般没事，但要有 APP 体验的话需要解决。 使用 touch (start、move、end、cancel) 相关事件代替 click，注意点击穿透问题，A 上面的 B 元素 touchstart 触发后，若 A 消失则 B 的 click 会被触发。 弹性滚动： div { -webkit-overflow-scrolling: touch; } ","date":"2019-07-17","objectID":"/front-end/:3:4","series":["Weeb"],"tags":["Language"],"title":"Front End","uri":"/front-end/#交互"},{"categories":["code"],"content":"JavaScript 重难点整理，包括数据类型、执行上下文、事件循环等内容。","date":"2019-07-17","objectID":"/js/","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/"},{"categories":["code"],"content":" 数据","date":"2019-07-17","objectID":"/js/:1:0","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#数据"},{"categories":["code"],"content":" 数据类型七种基本数据类型，一种复杂数据类型： number：+-(2^53-1) 范围内的数字 string：字符串 boolean：true 和 false null：未知的值 undefined：未定义的值 bigint：任意长度的整数 symbol：唯一标识符 object：复杂的数据结构 数据存储： 栈：基本类型和引用类型地址 堆：引用类型地址实际指向的数据 ","date":"2019-07-17","objectID":"/js/:1:1","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#数据类型"},{"categories":["code"],"content":" 类型检查typeof 运算符： typeof (()=\u003e{}) 会返回 \"function\" typeof [] 会返回 \"object\" typeof null 会返回 \"object\"，但实际上它并不是一个对象 instanceof 运算符： 支持继承的对象检测方法 Object.prototype.toString.call([])： Object.prototype.toString.call([]) === '[object Array]' Object.prototype.toString.call(()=\u003e{}) === '[object Function]' ","date":"2019-07-17","objectID":"/js/:1:2","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#类型检查"},{"categories":["code"],"content":" 类型转换 window.isNaN('abc')：true Number.isNaN('abc')：此方法不进行类型转换，因此为 false [0] == true：数组调用 toString 再变为数字 0，因此为 false ","date":"2019-07-17","objectID":"/js/:2:0","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#类型转换"},{"categories":["code"],"content":" 执行上下文和变量提升区别 let 和 var： let 拥有块级作用域 let 声明的全局变量不是全局对象的属性 let 用于循环中可以正常创建副本 let 不允许重定义 执行上下文可以理解为当前代码的执行环境，它会形成一个作用域： 全局环境 函数环境 eval 变量提升被认为是对执行上下文工作方式的一种认识，例如： function test() { console.log(foo); console.log(bar); var foo = 'Hello'; console.log(foo); var bar = function () { return 'world'; }; function foo() { return 'hello'; } } test(); 等价于： function test() { // 函数声明提升，且优先于变量声明 function foo() { return 'hello'; } // 变量声明提升，但 foo 已经存在，忽略 var 定义 // var foo = undefined; // 变量声明提升，函数表达式和其他变量赋值一致不提升 var bar = undefined; // 执行阶段 console.log(foo); // [Function] console.log(bar); // undefined foo = 'Hello'; console.log(foo); // Hello bar = function () { return 'world'; }; } test(); ","date":"2019-07-17","objectID":"/js/:3:0","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#执行上下文和变量提升"},{"categories":["code"],"content":" 闭包闭包简单来说就是函数中的函数；闭包可以通过一个函数去访问原本在外层无法直接访问到的数据，并且保证数据不被回收。 ","date":"2019-07-17","objectID":"/js/:3:1","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#闭包"},{"categories":["code"],"content":" 暂时性死区和直接使用 var 定义不同，由于没有变量提升，let、const 定义的变量在声明之前使用会报错。 ","date":"2019-07-17","objectID":"/js/:3:2","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#暂时性死区"},{"categories":["code"],"content":" Event Loop 事件循环首先将事件分为宏任务与微任务： 宏任务：主线 JS 代码、事件、setTimeout 和 setInterval 等 微任务：process.nextTick 和 Promise 回调等 事件循环流程： 首先执行主线同步任务 当遇到异步任务时将任务搁置一边独立执行，当异步任务有了结果将其放入对应的异步任务队列 主线同步任务执行完毕，检查微任务队列是否有内容，若有则一直执行至清空 进入下一轮循环，检查宏任务队列是否有内容，若有则一直执行至清空 继续执行主线同步任务 代码例： console.log('Start'); const timer1 = setTimeout(() =\u003e { console.log('Timer 1'); }, 0); const promise1 = new Promise((resolve, reject) =\u003e { console.log('Promise 1'); resolve('Promise 1 Fulfilled'); }); promise1 .then((val) =\u003e { console.log(val); return 'Promise 1 Then Fulfilled'; }) .then((val) =\u003e { console.log(val); const timer3 = setTimeout(() =\u003e { console.log('Timer 3 in Promise 1'); }); }); const promise2 = new Promise((resolve, reject) =\u003e { const timer2 = setTimeout(() =\u003e { console.log('Timer 2 in Promise 2'); resolve(); }); }); promise2 .then(() =\u003e { console.log('Promise 2 Then 1'); }) .then(() =\u003e { console.log('Promise 2 Then 2'); }); console.log('End'); /* 执行结果 * Start * Promise 1 * End * Promise 1 Fulfilled * Promise 1 Then Fulfilled * Timer 1 * Timer 2 in Promise 2 * Promise 2 Then 1 * Promise 2 Then 2 * Timer 3 in Promise 1 */ 解析： 首先执行主线同步任务，输出 Start、Promise 1 和 End 此时宏任务队列中有 timer1 和 timer2；微任务队列中有 promise1 的第一个 then 检查微任务队列，输出 Promise 1 Fulfilled 和 Promise 1 Then Fulfilled 此时宏任务队列中有 timer1、timer2 和 timer3；微任务队列中为空 下一轮循环，输出 Timer 1；微任务队列仍为空 下一轮循环，输出 Timer 2 in Promise 2；微任务队列中加入 promise2 的第一个 then 优先微任务队列，输出 Promise 2 Then 1 和 Promise 2 Then 2 下一轮循环，输出 Timer 3 in Promise 1 注意：在 Promise 同步构造函数中，在没有返回值的情况下，resolve() 后的代码依旧会被执行，只是无法再使用 reject() 改变该 Promise 的状态。 ","date":"2019-07-17","objectID":"/js/:4:0","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#event-loop-事件循环"},{"categories":["code"],"content":" Map 与 WeakMap WeakMap 的 key 只接受使用对象 WeakMap 不支持迭代，keys() 等方法无法使用 在 Map 中，若将某对象设置为 key，则后期将对该对象的直接引用置为 null，GC 不会回收，通过 Map.keys() 可以找到该对象；而在 WeakMap 中，该对象会被回收，但无法保证 GC 何时工作。 ","date":"2019-07-17","objectID":"/js/:5:0","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#map-与-weakmap"},{"categories":["code"],"content":" 遍历和迭代for...in...： 遍历对象及其原型链上可枚举属性 遍历数组元素及自定义属性 返回 string 类型的 key Object.keys()： 遍历对象本身的可枚举属性 遍历数组元素及自定义属性 返回 string 类型的 key for...of...： 遍历任何可迭代对象 (普通对象不支持) 返回 any 类型的 value ","date":"2019-07-17","objectID":"/js/:6:0","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#遍历和迭代"},{"categories":["code"],"content":" Promise Promise.all()：所有成功则成功；任一失败则失败 Promise.any()：任一成功则成功；所有失败则失败 Promise.race()：任一成功则成功；任一失败则失败 Promise.allSettled()：所有都成功或失败最后返回结果 ","date":"2019-07-17","objectID":"/js/:7:0","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#promise"},{"categories":["code"],"content":" This 指向绑定对于 this 指向在函数执行时才能确定，创建时无法确定。 对于一般函数，this 指向调用者： var x = 1; var obj = { x: 2, say: function () { console.log(this.x); }, }; obj.say(); // 2 (obj.x) var x = 1; function Obj() { this.x = 2; const say = function () { console.log(this.x); }; say(); } const obj = new Obj(); // 1 (window.x) 对于箭头函数，this 指向其父级执行上下文： var x = 1; var obj = { x: 2, say: () =\u003e { console.log(this.x); }, }; obj.say(); // 1 (window.x) var x = 1; function Obj() { this.x = 2; const say = () =\u003e { console.log(this.x); }; say(); } const obj = new Obj(); // 2 (obj.x) call、apply、bind 都用于绑定 this 指向： call：第一参数为 this 指向，剩余参数为参数列表，临时改变 this 并立即执行 apply：第一参数为 this 指向，第二参数为参数数组，临时改变 this 并立即执行 bind：第一参数为 this 指向，剩余参数为参数列表，返回 this 指向确定的函数，同时在调用返回的函数时还可以添加剩余参数 ","date":"2019-07-17","objectID":"/js/:8:0","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#this-指向绑定"},{"categories":["code"],"content":" 继承与原型链每个实例对象都有一个私有属性 __proto__ 指向它的原型对象，该原型对象也有原型，一直到 null 为止。 __proto__：常见的浏览器原型链实现 getPrototypeOf() 获取 [[Prototype]]：等价于 __proto__ prototype 函数才有，指向原型对象；原型对象也有 constructor 属性与之对应 function Dog [[Prototype]] prototype ==\u003e \u003c== constructor __proto__ ==\u003e Object.prototype dog1 ^^ __proto__ ==\u003e null __proto__ ===========|| ","date":"2019-07-17","objectID":"/js/:9:0","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#继承与原型链"},{"categories":["code"],"content":" 模拟实现 new function genInstance(Constructor, ...args) { // const obj = {}; // obj.__proto__ = Constructor.prototype; const obj = Object.create(Constructor.prototype); const ret = Constructor.call(obj, ...args); if (ret \u0026\u0026 typeof ret === 'object') { return ret; } return obj; } ","date":"2019-07-17","objectID":"/js/:9:1","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#模拟实现-new"},{"categories":["code"],"content":" 原型链继承 function Parent() { this.names = []; } Parent.prototype.getNames = function () { console.log(this.names); }; function Child() {} Child.prototype = new Parent(); const child1 = new Child(); const child2 = new Child(); child1.names.push('1'); console.log(child2.getName()); // ['1'] 引用类型的属性会被所有子实例共享 无法向 Parent 传参 ","date":"2019-07-17","objectID":"/js/:9:2","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#原型链继承"},{"categories":["code"],"content":" 组合继承引入经典继承 (借用构造函数)： function Parent() { this.names = []; } Parent.prototype.getNames = function () { console.log(this.names); }; function Child() { Parent.call(this, arguments); // 借用构造函数 } Child.prototype = new Parent(); Child.prototype.constructor = Child; const child1 = new Child(); const child2 = new Child(); child1.names.push('1'); console.log(child2.getName()); // [] 调用了两次父构造函数，导致 Child.prototype 和 child1 中有重复的 names ","date":"2019-07-17","objectID":"/js/:9:3","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#组合继承"},{"categories":["code"],"content":" 寄生组合继承引入寄生式继承 (使用父原型而不是父实例作为 Child.prototype)： function Parent() { this.names = []; } Parent.prototype.getNames = function () { console.log(this.names); }; function Child() { Parent.call(this, arguments); // 借用构造函数 } Child.prototype = Object.create(Parent.prototype); Child.prototype.constructor = Child; ","date":"2019-07-17","objectID":"/js/:9:4","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#寄生组合继承"},{"categories":["code"],"content":" DOM API","date":"2019-07-17","objectID":"/js/:10:0","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#dom-api"},{"categories":["code"],"content":" Element 与 Node Node 是一个基类，DOM 中的 Element、Text 和 Comment 都继承于它 Node 包含了其内部的 Element 结点，除此之外还有直接插入的文本，注释等内容 NodeList 和 ElementCollcetion 都不是真正的数组 ","date":"2019-07-17","objectID":"/js/:10:1","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#element-与-node"},{"categories":["code"],"content":" 元素相关属性 clientHeight：content + padding offsetHeight：content + padding + border + scrollbar scrollHeight：滚动部分总高度，包括当前不可见部分 scrollTop：滚动部分顶端距离可见部分顶端的高度 offsetTop：当前元素顶部距离最近父元素顶部的距离 ","date":"2019-07-17","objectID":"/js/:10:2","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#元素相关属性"},{"categories":["code"],"content":" 事件、冒泡和捕获事件传播的三个阶段： 捕获阶段 目标阶段 冒泡阶段 当一个事件发生在一个元素上，它会首先运行在该元素上的处理程序，然后运行其父元素上的处理程序，然后一直向上到其他祖先上的处理程序；几乎所有事件都会冒泡，但也有例如 focus 的事件不会冒泡。 event.target：是引发事件的目标元素，冒泡过程中不会发生变化 this：当前元素，其中有一个当前正在运行的处理程序 ","date":"2019-07-17","objectID":"/js/:10:3","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#事件冒泡和捕获"},{"categories":["code"],"content":" ESM 与 CommonJS 模块","date":"2019-07-17","objectID":"/js/:11:0","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#esm-与-commonjs-模块"},{"categories":["code"],"content":" 加载与解析CJS 模块同步加载，输出的是值的拷贝；对于基本类型，一旦输出，模块内部的变化影响不到这个值；对于引用类型，效果同引用类型的赋值操作；通过导出 getter 函数可以获取模块内部的变化；ES 模块是动态引用，并且不会缓存值。 由于 CJS 模块是同步的，因此可以放在代码段的任何位置；而 ESM 只是静态定义，在代码解析阶段就会被执行：import 会被提升到头部执行，export 与 var 定义的变量提升有类似的效果。 两种模块都不会重复执行。 ","date":"2019-07-17","objectID":"/js/:11:1","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#加载与解析"},{"categories":["code"],"content":" 循环依赖CJS 模块当遇到 require() 语句时，会执行模块中的代码，得到的是已经执行部分的结果。 ","date":"2019-07-17","objectID":"/js/:11:2","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#循环依赖"},{"categories":["code"],"content":" ES6+ 新要素 let 和 const 扩展运算符 箭头函数 class Map 和 Set ","date":"2019-07-17","objectID":"/js/:12:0","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#es6-新要素"},{"categories":["code"],"content":" 箭头函数特性 没有自己的 this，内部 this 指向父级执行上下文 无法作为构造函数，没有 prototype 属性 无法使用 arguments，需要 rest 参数 无法作为 generator 函数使用 ","date":"2019-07-17","objectID":"/js/:12:1","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#箭头函数特性"},{"categories":["code"],"content":" ES 标准流程 Stage 0：开放提交，提议、想法 Stage 1：正式建议，初步 demo 和标准 Stage 2：草案，标准语言解释和实验性实现 Stage 3：接近完成，等待测试、审核和用户反馈 Stage 4：确认会被包含到将来的标准中 ","date":"2019-07-17","objectID":"/js/:13:0","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JavaScript","uri":"/js/#es-标准流程"},{"categories":["code"],"content":"JavaScript 常见手写，包括防抖、节流、柯里、扁平、去重等各类手写。","date":"2019-07-17","objectID":"/js-insts/","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/"},{"categories":["code"],"content":" 工具函数","date":"2019-07-17","objectID":"/js-insts/:1:0","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#工具函数"},{"categories":["code"],"content":" 防抖与节流 /** * 防抖：仅执行一次 */ const debounce = \u003cF extends (...args: any[]) =\u003e any\u003e(func: F, delay = 300) =\u003e { let timer: number | null = null; const ret = (...args: any) =\u003e { if (timer) { window.clearTimeout(timer); } timer = window.setTimeout(() =\u003e { func(...args); timer = null; }, delay); }; return ret as (...args: Parameters\u003cF\u003e) =\u003e void; }; element.onclick = debounce(myFunc); /** * 节流：限制最小执行间隔 */ const throttle = \u003cF extends (...args: any[]) =\u003e any\u003e(func: F, delay = 300) =\u003e { let timer: number | null = null; const ret = (...args: any) =\u003e { if (!timer) { timer = window.setTimeout(() =\u003e { func(...args); timer = null; }, delay); } }; return ret as (...args: Parameters\u003cF\u003e) =\u003e void; }; window.onresize = throttle(myFunc); ","date":"2019-07-17","objectID":"/js-insts/:1:1","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#防抖与节流"},{"categories":["code"],"content":" 柯里化将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)： /** * @param {Function} func * @return {Function} */ function curry(func) { return function curried(...args) { if (args.length \u003e= func.length) { return func.apply(this, args); } else { return function (...args2) { return curried.apply(this, [...args, ...args2]); }; } }; } ","date":"2019-07-17","objectID":"/js-insts/:1:2","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#柯里化"},{"categories":["code"],"content":" 扁平化 数组 // 标准递归 function flatten(arr) { return arr.reduce((pre, cur) =\u003e { return pre.concat(Array.isArray(cur) ? flatten(cur) : cur); }, []); } // 字符串分割 function flatten(arr) { return Array.prototype.toString .call(arr) .split(',') .map((val) =\u003e Number(val)); } // 重复扩展直至扁平 function flatten(arr) { while (arr.some((val) =\u003e Array.isArray(val))) { arr = [...arr]; } return arr; } 对象输入： { a: 1, b: [1, 2, { c: true }, [3]], d: { e: 2, f: 3 }, g: null, } /** * @param {Array} input * @param {string} name * @param {Object} res */ function _flatten(input, name, res) { for (let key of Object.keys(input)) { let baseName = name; const val = input[key]; if (val === null || val === undefined) { continue; } if (/^[0-9]/.exec(`${key}`)) { baseName += `[${key}]`; } else if (baseName === '') { baseName += `${key}`; } else { baseName += `.${key}`; } if (typeof val === 'object') { _flatten(val, baseName, res); } else { res[baseName] = val; } } } /** * @param {Array} input * @return {Object} */ function flatten(input) { const res = {}; _flatten(input, '', res); return res; } ","date":"2019-07-17","objectID":"/js-insts/:1:3","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#扁平化"},{"categories":["code"],"content":" 扁平化 数组 // 标准递归 function flatten(arr) { return arr.reduce((pre, cur) =\u003e { return pre.concat(Array.isArray(cur) ? flatten(cur) : cur); }, []); } // 字符串分割 function flatten(arr) { return Array.prototype.toString .call(arr) .split(',') .map((val) =\u003e Number(val)); } // 重复扩展直至扁平 function flatten(arr) { while (arr.some((val) =\u003e Array.isArray(val))) { arr = [...arr]; } return arr; } 对象输入： { a: 1, b: [1, 2, { c: true }, [3]], d: { e: 2, f: 3 }, g: null, } /** * @param {Array} input * @param {string} name * @param {Object} res */ function _flatten(input, name, res) { for (let key of Object.keys(input)) { let baseName = name; const val = input[key]; if (val === null || val === undefined) { continue; } if (/^[0-9]/.exec(`${key}`)) { baseName += `[${key}]`; } else if (baseName === '') { baseName += `${key}`; } else { baseName += `.${key}`; } if (typeof val === 'object') { _flatten(val, baseName, res); } else { res[baseName] = val; } } } /** * @param {Array} input * @return {Object} */ function flatten(input) { const res = {}; _flatten(input, '', res); return res; } ","date":"2019-07-17","objectID":"/js-insts/:1:3","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#数组"},{"categories":["code"],"content":" 扁平化 数组 // 标准递归 function flatten(arr) { return arr.reduce((pre, cur) =\u003e { return pre.concat(Array.isArray(cur) ? flatten(cur) : cur); }, []); } // 字符串分割 function flatten(arr) { return Array.prototype.toString .call(arr) .split(',') .map((val) =\u003e Number(val)); } // 重复扩展直至扁平 function flatten(arr) { while (arr.some((val) =\u003e Array.isArray(val))) { arr = [...arr]; } return arr; } 对象输入： { a: 1, b: [1, 2, { c: true }, [3]], d: { e: 2, f: 3 }, g: null, } /** * @param {Array} input * @param {string} name * @param {Object} res */ function _flatten(input, name, res) { for (let key of Object.keys(input)) { let baseName = name; const val = input[key]; if (val === null || val === undefined) { continue; } if (/^[0-9]/.exec(`${key}`)) { baseName += `[${key}]`; } else if (baseName === '') { baseName += `${key}`; } else { baseName += `.${key}`; } if (typeof val === 'object') { _flatten(val, baseName, res); } else { res[baseName] = val; } } } /** * @param {Array} input * @return {Object} */ function flatten(input) { const res = {}; _flatten(input, '', res); return res; } ","date":"2019-07-17","objectID":"/js-insts/:1:3","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#对象"},{"categories":["code"],"content":" 去重 Array.prototype.unique = function () { const arr = this; return arr.filter((val, idx) =\u003e arr.indexOf(val) === idx); }; ","date":"2019-07-17","objectID":"/js-insts/:1:4","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#去重"},{"categories":["code"],"content":" 深拷贝 // 可以通过 WeakMap 解决循环引用问题，同时保证内存被回收 const map = new WeakMap(); function cloneDeep(src) { if (src \u0026\u0026 typeof src === 'object') { if (map.has(src)) { return map.get(src); } else { map.set(src, src); } const ret = Array.isArray(src) ? [] : {}; for (let key of Object.keys(src)) { ret[key] = cloneDeep(src[key]); } return ret; } else { return src; } } ","date":"2019-07-17","objectID":"/js-insts/:1:5","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#深拷贝"},{"categories":["code"],"content":" Promise","date":"2019-07-17","objectID":"/js-insts/:2:0","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#promise"},{"categories":["code"],"content":" Promise 构造函数Promises/A+ 标准中仅指定了 Promise 对象的 then 方法的行为，其它一切我们常见的方法、函数都并没有指定。 class Promise { constructor(func) { // 初始化状态 const self = this; this.status = 'pending'; this.data = undefined; this.onResolvedCallbacks = []; this.onRejectedCallbacks = []; // API 函数 function resolve(value) { if (self.status === 'pending') { self.status = 'resolved'; self.data = value; self.onResolvedCallbacks.forEach((func) =\u003e { func(); }); } } function reject(reason) { if (self.status === 'pending') { self.status = 'rejected'; self.data = reason; self.onRejectedCallbacks.forEach((func) =\u003e { func(); }); } } // 执行同步构造器 try { func(resolve, reject); } catch (e) { reject(e); } } then(onResolved, onRejected) { // 检查参数 if (typeof onResolved !== 'function') { onResolved = function () {}; } if (typeof onRejected !== 'function') { onRejected = function () {}; } // resolve 或 reject 则执行对应回调 if (this.status === 'resolved') { return new Promise((resolve, reject) =\u003e { try { resolve(onResolved(this.data)); } catch (e) { reject(e); } }); } if (this.status === 'rejected') { return new Promise((resolve, reject) =\u003e { try { resolve(onRejected(this.data)); } catch (e) { reject(e); } }); } // pending 状态则等待 pending 完成 if (this.status === 'pending') { return new Promise((resolve, reject) =\u003e { this.onResolvedCallbacks.push(() =\u003e { try { resolve(onResolved(this.data)); } catch (e) { reject(e); } }); this.onRejectedCallbacks.push(() =\u003e { try { resolve(onRejected(this.data)); } catch (e) { reject(e); } }); }); } } } ","date":"2019-07-17","objectID":"/js-insts/:2:1","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#promise-构造函数"},{"categories":["code"],"content":" Polyfill Promise.all() /** * @param {Array} arr * @return {Promise\u003cany[]\u003e} */ function promiseAll(arr) { return new Promise((resolve, reject) =\u003e { let pending = arr.length; const results = new Array(arr.length); arr.forEach((p, idx) =\u003e { p.then( (res) =\u003e { results[idx] = res; if (--pending === 0) { resolve(results); } }, (e) =\u003e reject(e) ); }); }); } ","date":"2019-07-17","objectID":"/js-insts/:2:2","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#polyfill-promiseall"},{"categories":["code"],"content":" Promise 并发限制 /** * @param {number} limit * @param {Array} arr * @param {Function} fetch * @return {Promise\u003cany[]\u003e} */ async function asyncPool(limit, arr, fetch) { const pending = []; const results = []; let index = 0; // 入池用下标 // 入池一个 async function push() { // 若已经全部进入池子则等待全部完成 if (index \u003e= arr.length) { return; } // 获得一个 Promise const p = fetch(arr[index]); pending.push(p); results.push(p); // Promise 完成后在 pending 中删除 p.then(() =\u003e pending.splice(pending.indexOf(p), 1)); if (pending.length \u003e= limit) { await Promise.race(pending); } index++; await push(); } await push(); return await Promise.all(results); } ","date":"2019-07-17","objectID":"/js-insts/:2:3","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#promise-并发限制"},{"categories":["code"],"content":" 原生 API","date":"2019-07-17","objectID":"/js-insts/:3:0","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#原生-api"},{"categories":["code"],"content":" bind() Function.prototype.bind = function (...args) { const func = this; // 需要绑定的函数 const ctx = args[0]; // 绑定的 this const params = args.slice(1); // bind 时传入的参数 return (...args) =\u003e func.apply(ctx, [...params, ...args]); }; ","date":"2019-07-17","objectID":"/js-insts/:3:1","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#bind"},{"categories":["code"],"content":" instanceof function instanceOf(inst, func) { let proto = Object.getPrototypeOf(inst); while (true) { if (!proto) { return false; } if (proto === func.prototype) { return true; } proto = Object.getPrototypeOf(proto); } } ","date":"2019-07-17","objectID":"/js-insts/:3:2","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#instanceof"},{"categories":["code"],"content":" newJavaScript - 模拟实现 new ","date":"2019-07-17","objectID":"/js-insts/:3:3","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#new"},{"categories":["code"],"content":" reduce() 实现 map() Array.prototype.mapPolyfill = function (func, thisValue) { const self = thisValue || this; const ret = []; this.reduce((pre, cur, idx, arr) =\u003e { return ret.push(func.call(self, cur, idx, arr)); }, ret); return ret; }; ","date":"2019-07-17","objectID":"/js-insts/:3:4","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#reduce-实现-map"},{"categories":["code"],"content":" 语言特性","date":"2019-07-17","objectID":"/js-insts/:4:0","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#语言特性"},{"categories":["code"],"content":" Iterable 对象 const object = { a: 1, b: 2, c: 3, // 本质是一个 Generator 函数 *[Symbol.iterator]() { for (const key of Object.keys(this)) { yield this[key]; } }, }; console.log(...object); // 1 2 3 object.d = 4; console.log(...object); // 1 2 3 4 ","date":"2019-07-17","objectID":"/js-insts/:4:1","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#iterable-对象"},{"categories":["code"],"content":" LazyMan (事件循环) new LazyMan('Tony') .eat('lunch') .eat('dinner') .sleepFirst(5) .sleep(10) .eat('junk food'); // Hi I am Tony // 等待了5秒... // I am eating lunch // I am eating dinner // 等待了10秒... // I am eating junk food class LazyMan { constructor(name) { this.taskList = []; console.log(`Hi I am ${name}`); // 等待第一次事件循环 // 即 tasklist 初始化完成 setTimeout(() =\u003e { this.next(); }, 0); } next() { const func = this.taskList.shift(); func \u0026\u0026 func(); } eat(food) { const func = () =\u003e { console.log(`I am eating ${food}`); this.next(); }; this.taskList.push(func); return this; } sleepFirst(time) { const func = () =\u003e { setTimeout(() =\u003e { console.log(`等待了${time}秒...`); this.next(); }, time * 1000); }; this.taskList.unshift(func); return this; } sleep(time) { const func = () =\u003e { setTimeout(() =\u003e { console.log(`等待了${time}秒...`); this.next(); }, time * 1000); }; this.taskList.push(func); return this; } } ","date":"2019-07-17","objectID":"/js-insts/:4:2","series":["Weeb"],"tags":["Language","JavaScript"],"title":"JS Insts","uri":"/js-insts/#lazyman-事件循环"},{"categories":["code"],"content":"React 重点整理，包括一些框架特定的内容、特性，以及与其他框架的对比等。","date":"2019-07-17","objectID":"/react/","series":["Weeb"],"tags":["Language","React"],"title":"React","uri":"/react/"},{"categories":["code"],"content":" 对比 Vue.js","date":"2019-07-17","objectID":"/react/:1:0","series":["Weeb"],"tags":["Language","React"],"title":"React","uri":"/react/#对比-vuejs"},{"categories":["code"],"content":" 数据更新 Vue：Vue 2 通过 getter、setter 与函数包裹；Vue 3 使用 Proxy；数据变化时自动更新显示 React：手动 setState 或通过 Redux 等库触发数据变化和视图更新 ","date":"2019-07-17","objectID":"/react/:1:1","series":["Weeb"],"tags":["Language","React"],"title":"React","uri":"/react/#数据更新"},{"categories":["code"],"content":" 组件通信 Vue：父组件单向传值给子组件，子组件 emit 事件给父组件监听 React：父组件单向传值给子组件，同时传递 handler 函数给组件调用 props \u003c=\u003e onEvent() Context.Provider \u003c=\u003e useContext Redux / MobX ","date":"2019-07-17","objectID":"/react/:1:2","series":["Weeb"],"tags":["Language","React"],"title":"React","uri":"/react/#组件通信"},{"categories":["code"],"content":" Diff 算法 节点比对区别：例如节点 class 更改，React 视为同节点，仅更新其属性 列表比对区别：都通过 key 优化，但 Vue 采用双端对比 ","date":"2019-07-17","objectID":"/react/:1:3","series":["Weeb"],"tags":["Language","React"],"title":"React","uri":"/react/#diff-算法"},{"categories":["code"],"content":" Hooks 和类组件的区别最大的区别函数组件每次渲染都会有独立 props 和 state，而 class 组件总是会通过 this 拿到最新的 props 和 state；即函数式组件捕获了渲染所使用的值。 例如有一个在一秒后会变化为 B 的 prop 为 name，目前为 A；有一个 button 的 handleClick 在三秒后会 alert(this.props.name)；在类组件中 alert 的结果会是 B，因为 this 已经指向了最新的 props。 而在函数组件中，alert(props.name) 得到的却是调用 handleClick 时 (即变化前) 的 A。 这也是造成一些额外问题的原因，例如 useEffect 未正确指定其依赖于某个 count 值却在三秒后 setState(count+1)，这里的 count 就永远为固定值了。 对于 setState 问题可以使用 setState((state)=\u003estate+1) 解决，对于异步函数中获取到旧值可以使用 useRef 解决。 ","date":"2019-07-17","objectID":"/react/:2:0","series":["Weeb"],"tags":["Language","React"],"title":"React","uri":"/react/#hooks-和类组件的区别"},{"categories":["code"],"content":"Vue.js 重点整理，包括一些框架特定的内容、特性，以及与其他框架的对比等。","date":"2019-07-17","objectID":"/vuejs/","series":["Weeb"],"tags":["Language","Vue.js"],"title":"Vue.js","uri":"/vuejs/"},{"categories":["code"],"content":" MVC 与 MVVMMVC： View 把操作转移到 Controller 处理 Controller 完成业务逻辑后，要求 Model 改变状态 Controller 通知 Model 将新的数据发送到 View MVVM： View 把操作转移到 VM 处理 VM 完成业务逻辑后，要求 Model 改变状态 VM 与 View 双向绑定，VM 更新自动反映在 View 上 ","date":"2019-07-17","objectID":"/vuejs/:1:0","series":["Weeb"],"tags":["Language","Vue.js"],"title":"Vue.js","uri":"/vuejs/#mvc-与-mvvm"},{"categories":["code"],"content":" VDOM通过 JS 对象模拟庞大繁杂的 DOM 节点，通过特定的 render 方法将其渲染为实际的 DOM 元素。 Diff 算法指的是通过 VDOM 节点的比较得到 patch 对象，解析并更新需要更新的实际 DOM 元素；对于两棵树传统的 Diff 算法时间复杂度为 O(n^3)，VDOM 的算法中一般通过同级比较来简化。 Vue 中 diff 过程： 首先比较两个节点是否可以视为同一个，根据 key 和 selector 判断 若不同，则直接替换结点，例如 classname 不同 若相同，则对比这两个结点 文本不同则更新文本 一方有节点则进行子结点的增删 两方都有结点则进行子结点对比，此过程 Vue 使用双向判断 ","date":"2019-07-17","objectID":"/vuejs/:2:0","series":["Weeb"],"tags":["Language","Vue.js"],"title":"Vue.js","uri":"/vuejs/#vdom"},{"categories":["code"],"content":" 组件通信 props \u003c=\u003e $emit $parent \u003c=\u003e $children (不建议) provide \u003c=\u003e inject Vuex State Getters: 计算属性 Mutations: 同步 Actions: 异步 ","date":"2019-07-17","objectID":"/vuejs/:3:0","series":["Weeb"],"tags":["Language","Vue.js"],"title":"Vue.js","uri":"/vuejs/#组件通信"},{"categories":["code"],"content":" 响应式原理","date":"2019-07-17","objectID":"/vuejs/:4:0","series":["Weeb"],"tags":["Language","Vue.js"],"title":"Vue.js","uri":"/vuejs/#响应式原理"},{"categories":["code"],"content":" Vue 2当一个普通的对象转为响应式对象时，Vue 通过 Object.defineProperty 将其属性转为 getter 和 setter；当通过数据渲染组件时，watcher 会记录下依赖的数据；当数据改变，watcher 通知视图更新。 无法检测对象属性的添加、直接利用索引添加数组元素、改变数组长度等；解决方案为包裹数组方法和利用 $set 手动派发更新。 ","date":"2019-07-17","objectID":"/vuejs/:4:1","series":["Weeb"],"tags":["Language","Vue.js"],"title":"Vue.js","uri":"/vuejs/#vue-2"},{"categories":["code"],"content":" Vue 3同样是监听数据变化，Vue 3 使用 Proxy 拦截对所包括的响应式对象的操作，因此可以检测 Vue 2 中无法直接监测到的变化。 const dinner = { meal: 'tacos', }; const handler = { get(target, prop, receiver) { track(target, prop); // 跟踪更改它的函数 return Reflect.get(...arguments); }, set(target, key, value, receiver) { trigger(target, key); // 触发函数以便它可以更新最终值 return Reflect.set(...arguments); }, }; const proxy = new Proxy(dinner, handler); console.log(proxy.meal); ","date":"2019-07-17","objectID":"/vuejs/:4:2","series":["Weeb"],"tags":["Language","Vue.js"],"title":"Vue.js","uri":"/vuejs/#vue-3"},{"categories":["code"],"content":" Proxy 和 ReflectProxy 用于将一个对象包装起来并拦截对其的操作。 Reflect 是一个用于简化 Proxy 创建的对象。对于每个可被 Proxy 捕获的内部方法，在 Reflect 中都有一个对应的方法，其名称和参数与 Proxy 捕捉器相同。所以，我们可以使用 Reflect 来将操作转发给原始对象。 当某个对象继承了被 Proxy 包裹的对象时，内部函数通过 this 获取原型上的属性时可能会错误的被 Proxy 拦截，使用 Reflect 来避免。 ","date":"2019-07-17","objectID":"/vuejs/:4:3","series":["Weeb"],"tags":["Language","Vue.js"],"title":"Vue.js","uri":"/vuejs/#proxy-和-reflect"},{"categories":["code"],"content":" 批量更新和 nextTick响应式原理中提到数据改版 watcher 通知视图更新，对应的 watcher 其实是被推进类似 Event Loop 的队列，在下一个 tick 的时候将这个队列中的 watcher 全部取出并触发。nextTick 内部依靠 Promise.then 和 setTimeout 等原生异步队列相关的函数。 ","date":"2019-07-17","objectID":"/vuejs/:5:0","series":["Weeb"],"tags":["Language","Vue.js"],"title":"Vue.js","uri":"/vuejs/#批量更新和-nexttick"},{"categories":["code"],"content":" Router 模式 HASH 模式：由于 HASH 的变化浏览器可以记录，因此监听 hashchange 事件，在 HASH 中提供路径 History 模式：通过 H5 新增的两个 History API 方法 pushState 和 replaceState 不刷新页面的特性改变 URL，通过监听 popstate 事件得知页面变化，刷新和直接访问次级页面需要服务端配置 ","date":"2019-07-17","objectID":"/vuejs/:6:0","series":["Weeb"],"tags":["Language","Vue.js"],"title":"Vue.js","uri":"/vuejs/#router-模式"},{"categories":["code"],"content":" 模板编译 将模板字符串转换成元素的 AST 抽象语法树 优化语法树，标记静态节点 生成代码 render 函数，createElement ","date":"2019-07-17","objectID":"/vuejs/:7:0","series":["Weeb"],"tags":["Language","Vue.js"],"title":"Vue.js","uri":"/vuejs/#模板编译"},{"categories":["code"],"content":" 生命周期顺序渲染： 父 beforeCreate =\u003e 父 created =\u003e 父 beforeMount =\u003e 子 beforeCreate =\u003e 子 created =\u003e 子beforeMount =\u003e 子 mounted =\u003e 父 mounted 更新和销毁： 父 beforeUpdate =\u003e 子 beforeUpdate =\u003e 子 updated =\u003e 父 updated 父 beforeDestroy =\u003e 子 beforeDestroy =\u003e 子 destroyed =\u003e 父 destroyed ","date":"2019-07-17","objectID":"/vuejs/:8:0","series":["Weeb"],"tags":["Language","Vue.js"],"title":"Vue.js","uri":"/vuejs/#生命周期顺序"},{"categories":["code"],"content":" 简化样例 Observer let data = { name: 'name', detail: { age: 12, }, }; let initWatcher = null; class Watcher { constructor(data, key, cb) { this.data = date; this.key = key; this.cb = cb; // 触发 getter 初始化过程 initWatcher = this; this.preValue = data[key]; initWatcher = null; } update() { if (this.preValue !== this.data[this.key]) { this.cb(this.data[this.key]); } } } class Dependency { constructor() { this.watchers = []; } subscribe(watcher) { this.watchers.push(watcher); } notify() { this.watchers.forEach((watcher) =\u003e watcher.update()); } } class Observer { constructor() { this.observe(data); } observe(data) { if (!data || typeof data !== 'object') { return; } for (let key of Object.keys(data)) { this.observe(data[key]); this.defineProp(data, key, data[key]); } } defineProp(obj, key, value) { const dep = new Dependency(); Object.defineProperty(obj, key, { configurable: true, enumerable: true, get() { if (initWatcher) { dep.subscribe(initWatcher); } return value; }, set(newValue) { this.observe(newValue); value = newValue; dep.notify(); }, }); } } ","date":"2019-07-17","objectID":"/vuejs/:9:0","series":["Weeb"],"tags":["Language","Vue.js"],"title":"Vue.js","uri":"/vuejs/#简化样例-observer"},{"categories":["code"],"content":"计算机网络笔记，包括网络模型、TCP/UDP 协议、页面解析过程的内容。","date":"2019-07-17","objectID":"/web/","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/"},{"categories":["code"],"content":" OSI 七层与 TCP/IP 四层模型 OSI：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 TCP/IP：数据链路层、网络层、传输层、应用层 物理层：原始比特流传输 数据链路层：原始比特流到逻辑信号之间的转换 网络层：IP 协议 传输层：TCP 和 UDP 会话层：SSL 应用层：HTTP 和 FTP ","date":"2019-07-17","objectID":"/web/:1:0","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#osi-七层与-tcpip-四层模型"},{"categories":["code"],"content":" TCP 协议","date":"2019-07-17","objectID":"/web/:2:0","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#tcp-协议"},{"categories":["code"],"content":" 三次握手 起初两端都处于 CLOSED 状态，客户端向服务端发送 SYN 包等待服务端确认，客户端进入 SYN-SENT 状态 服务端发回 SYN + ACK 包确认连接请求，进入 SYN-RCVD 状态 客户端收到确认，向服务端发送 ACK 包确认建立连接，此时两端都处于 ESTABLISHED 状态 四次挥手与三次握手类似，区别是服务端再发回确认时分为两次；第一次先发送 ACK 确认客户端发来的 FIN 包，第二次发送服务端的 FIN 包等待 ACK。 ","date":"2019-07-17","objectID":"/web/:2:1","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#三次握手"},{"categories":["code"],"content":" 为什么是三次 为了实现可靠传输，协议双方都必须发送带有序列号的包，三次握手过程中则是 1000 =\u003e 1001+2000 =\u003e 2001；而为了保证双方都有发出的序列号并且都被确认，至少要三次连接才能完成 防止客户端认为已失效的连接请求传送到服务器端，但服务端却接受了导致错误 ","date":"2019-07-17","objectID":"/web/:2:2","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#为什么是三次"},{"categories":["code"],"content":" 数据传输 使用校验和、确认应答机制和重传机制来保证可靠传输 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制 ","date":"2019-07-17","objectID":"/web/:2:3","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#数据传输"},{"categories":["code"],"content":" UDP 协议无连接 (握手)；不可靠传输，无流量控制和拥塞控制，支持一对多、多对多等通信；应用于部分游戏等。 QUIC 和 WebRTC 基于 RUDP。 ","date":"2019-07-17","objectID":"/web/:3:0","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#udp-协议"},{"categories":["code"],"content":" 输入 URL 到页面加载 DNS 解析 TCP 连接 发送 HTTP 请求 服务器处理请求并返回 HTTP 响应 浏览器解析渲染页面 断开 TCP 连接 ","date":"2019-07-17","objectID":"/web/:4:0","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#输入-url-到页面加载"},{"categories":["code"],"content":" DNS 解析过程以 baidu.com 为例： 本地 DNS 缓存 本地 DNS 服务器 根 DNS 服务器 com 域 DNS 服务器 baidu.com 域 DNS 服务器 (CNAME 到 CDN 域名服务器请求解析) ","date":"2019-07-17","objectID":"/web/:5:0","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#dns-解析过程"},{"categories":["code"],"content":" 浏览器渲染页面的过程","date":"2019-07-17","objectID":"/web/:6:0","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#浏览器渲染页面的过程"},{"categories":["code"],"content":" WebKit 渲染过程 首先通过请求得到 HTML 解析 HTML 生成 DOM 树 遇见 CSS、图片等则异步加载，不会阻塞 DOM 树的生成 遇见普通的 JS (\u003cscript\u003e) 则阻塞 DOM 树加载，等到 JS 加载且执行完后继续生成 DOM 树 将 DOM 树 和 CSS 规则树合并到一起生成渲染树 遍历渲染树计算节点的信息并绘制到屏幕 ","date":"2019-07-17","objectID":"/web/:6:1","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#webkit-渲染过程"},{"categories":["code"],"content":" async 和 defer async：异步下载，执行时阻塞，可能在任何时候执行，顺序与定义先后无关 defer：异步下载，直到 DOMContentLoaded 触发前才执行，顺序由定义先后决定 动态插入：除非显式设置 false，否则类似 async 一起使用：async 优先，浏览器不支持时回退到 defer ","date":"2019-07-17","objectID":"/web/:6:2","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#async-和-defer"},{"categories":["code"],"content":" repaint 和 reflow (回流) repaint 是屏幕中一部分的内容重新渲染 reflow 则是因为某些元素的尺寸或存在与否改变了，因此需要重新计算相关联的所有渲染树 reflow 必然带来 repaint，但 repaint 不一定会带来 reflow 获取一个元素的 scrollTop 和 offsetTop 之类的属性时，浏览器为了保证值的正确也会回流取得最新的值。 ","date":"2019-07-17","objectID":"/web/:6:3","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#repaint-和-reflow-回流"},{"categories":["code"],"content":" HTTP超文本传输协议，本质是无状态的，使用 Cookies 可以创建有状态的会话；一般基于 TCP/IP 协议，默认端口 80；分为请求和响应两个部分。 ","date":"2019-07-17","objectID":"/web/:7:0","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#http"},{"categories":["code"],"content":" HTTP 请求 GET / HTTP/1.1 Host: developer.mozilla.org User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:77.0) Gecko/20100101 Firefox/77.0 Accept: text/css,*/*;q=0.1 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Cookie: dwf_sg_task_completion=False; _ga=GA1.2.2100708258.1587297770 HTTP 方法：GET、POST、OPTIONS 等 资源路径和 HTTP 协议版本号 其他 headers 如果是例如 POST，还会包含发送的信息 Connection: keep-alive：保持该网络连接打开 ","date":"2019-07-17","objectID":"/web/:7:1","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#http-请求"},{"categories":["code"],"content":" HTTP 响应 HTTP/2 200 OK Content-Type: image/png Content-Length: 63794 Last-Modified: Tue, 17 Dec 2019 00:26:34 GMT Cache-Control: public,max-age=31536000,immutable \u003c!DOCTYPE html\u003e \u003chtml lang=\"zh\"\u003e ... HTTP 版本号 状态码和状态信息：一般由三位构成 1xx 表示请求已经接受 2xx 表示请求已经处理 3xx 重定向 4xx 一般为客户端错误 5xx 一般为服务器错误 常见的：200 OK；403 Forbidden；404 Not Found；502 Bad Gateway 其他 headers 信息 ","date":"2019-07-17","objectID":"/web/:7:2","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#http-响应"},{"categories":["code"],"content":" 重定向链接的区别 301：永久重定向，浏览器可以做缓存 302：临时重定向，下次访问依旧用重定向之前的链接 307：类似临时重定向，不允许请求变为 GET 类型 308：类似永久重定向，不允许请求变为 GET 类型 ","date":"2019-07-17","objectID":"/web/:7:3","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#重定向链接的区别"},{"categories":["code"],"content":" 常见的信息头 Host：服务器域名 User-Agent：UA Cookie：Cookie 会一直被携带在 HTTP 请求内发送给服务器，localStorage 和 sessionStorage 仅和浏览器本地有关，且 sessionStorage 仅在当前浏览器窗口关闭之前有效 Cache-Control，If-Modified-Since，Etag，If-None-Match：HTTP 缓存相关 ","date":"2019-07-17","objectID":"/web/:7:4","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#常见的信息头"},{"categories":["code"],"content":" HTTP 缓存机制 发送 HTTP 请求时首先检查浏览器缓存 (是否存在或是否过期) 缓存有效则直接从缓存中得到资源 (强缓存) 缓存无效检查是否有 Etag 或 Last-Modified 有 Etag 则带 If-None-Match 请求资源 有 Last-Modified 则带 If-Modified-Since 请求资源 304 Not Modified (协商缓存) 或 200 OK 无则直接请求资源 200 OK no-cache：可携带 Etag 相关头实现 304 协商缓存，无强缓存 no-store：无任何缓存 ","date":"2019-07-17","objectID":"/web/:7:5","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#http-缓存机制"},{"categories":["code"],"content":" HTTPS 过程通过 TLS 协议对 HTTP 进行加密。 客户端发送 HTTPS 请求，并发送支持的密钥算法 服务端选择一种算法返回证书 (非对称加密) 客户端验证证书的有效性，生成随机密码，并用证书公钥加密随机密码发送给服务端 服务端接收到随机密码，用私钥解密，并用这个密码加密数据发送给客户端 客户端用随机密码解密传来的数据 (对称加密) 非对称加密：公钥加密私钥解密 ","date":"2019-07-17","objectID":"/web/:7:6","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#https-过程"},{"categories":["code"],"content":" HTTP 版本进步","date":"2019-07-17","objectID":"/web/:8:0","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#http-版本进步"},{"categories":["code"],"content":" HTTP/0.9相当原始的 HTTP 版本，仅支持 GET HTML。 ","date":"2019-07-17","objectID":"/web/:8:1","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#http09"},{"categories":["code"],"content":" HTTP/1.0 添加了 POST、HEAD 等请求 Content-Type：文件类型支持 缓存支持 ","date":"2019-07-17","objectID":"/web/:8:2","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#http10"},{"categories":["code"],"content":" HTTP/1.1 Connection: keep-alive 的默认支持 添加了 PUT、PATCH、OPTIONS、DELETE 等请求 新增了很多头字段、状态码 ","date":"2019-07-17","objectID":"/web/:8:3","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#http11"},{"categories":["code"],"content":" HTTP/2 服务端推送：PUSH 方法；例如请求 .html 时服务端主动尝试返回 .css 和 .js 等资源 多路复用：尝试将多个 HTTP 请求合并一起发送；在 HTTP/1.1 中，keep-alive 可以使 TCP 连接保持打开，但数据传输依旧是 请求 A =\u003e 响应 A =\u003e 请求 B =\u003e 响应 B 的模式，而在 HTTP/2 中，就可以实现 请求 A 和 B =\u003e 响应 A 和 B；在使用 HTTP/2 的情况下，“减少 HTTP 请求” 这类的性能优化并不一定在所有情况下都能有效 首部压缩：HTTP 头 压缩 二进制分帧：将信息分割为更小的帧，并对它们采用二进制编码，其中例如 HTTP 头会被封装到 Headers 帧 ","date":"2019-07-17","objectID":"/web/:8:4","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#http2"},{"categories":["code"],"content":" Cookie 和 Session 浏览器首次请求 服务器生成 Session 并保存，响应返回特定包含 Session 信息的 Cookie 浏览器再次请求带有这个 Cookie 服务器查询 Session 判断身份 区别： Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在内存、数据库、文件中；Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式。 ","date":"2019-07-17","objectID":"/web/:9:0","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#cookie-和-session"},{"categories":["code"],"content":" 跨域同源策略：协议、端口、域名都相同 JSONP 利用 script 标签没有跨域限制的特性，让服务器发回可执行的 JS 代码（函数），其参数就是要获取的数据。例如搜狐的当前城市 API，返回的就是 var returnCitySN = {} 手动设置 document.domain，实现二级域名相同 frame.postMessage({}) CORS CORS 分为简单请求和需预检的请求： 使用 GET、POST 或 HEAD 方法，请求头的类型和 Content-Type 都在限定内的会发出简单请求： 浏览器直接发送带有 Origin 头的请求 对于没有 cookie 的请求，服务器响应： Access-Control-Allow-Origin：* 或与 Origin 的值相同 对于具有凭据的请求，服务器应该设置： Access-Control-Allow-Origin：与 Origin 的相同 Access-Control-Allow-Credentials：true 需预检的请求： 浏览器将具有以下 header 的 OPTIONS 请求发送到相同的 URL： Access-Control-Request-Method：请求方法 Access-Control-Request-Headers：以逗号分隔的 header 列表 服务器响应： HTTP 状态码：200 Access-Control-Allow-Methods：允许方法的列表 Access-Control-Allow-Headers：允许 header 的列表 Access-Control-Max-Age：缓存秒数 预检通过后才发出实际请求，与简单请求流程相同。 ","date":"2019-07-17","objectID":"/web/:10:0","series":["Weeb"],"tags":["HTTP"],"title":"Web","uri":"/web/#跨域"}]